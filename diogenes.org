#+TITLE: Notizen zu Diogenes
#+AUTHOR: Michael Neidhart
#+DATE: 25. Juli 2023
#+STARTUP: show3levels

* Allgemeines:
- Zur Analyse ist folgende Umgebungsvariable zu setzen:
#+begin_src sh
 export Diogenes_Debug=1
#+end_src

* Diogenes::Base

** Globale Variablen
#+begin_src perl
  our(%encoding, %context, @contexts, %choices, %list_labels, %auths,
      %lists, %work, %lang, %author, %last_work, %work_start_block,
      %level_label, %sub_works, %top_levels, %last_citation, $bibliography,
      %coptic_encoding, %database, @databases, @filters)
    ;

  ...

  our($RC_DEBUG, $OS, $config_dir);
  $RC_DEBUG = 0;
#+end_src
*** %encoding                                                     :EXPORT_OK:
**** Definiert in diogenes.map:
***** $Diogenes::Base::encoding{Unicode_Entities}
***** $UTF_8_post
This subroutine is called after the match to add underdots, etc. etc.
All the nice characters that Unicode gives us, which otherwise are
left up to the formatting layer.
***** $Diogenes::Base::encoding{'UTF-8-CB'}                        :Standart:
****** $Diogenes::Base::encoding{'UTF-8-CB'}{post_match} = $UTF_8_post;
***** OBSOLET
****** $Diogenes::Base::encoding{'UTF-8-CX'}
******* $Diogenes::Base::encoding{'UTF-8-CX'}{post_match} = $UTF_8_post;
****** $Diogenes::Base::encoding{'UTF-8-DB'}
******* $Diogenes::Base::encoding{'UTF-8-DB'}{post_match} = $UTF_8_post;
****** $Diogenes::Base::encoding{WinGreek}
****** $Diogenes::Base::encoding{SMK_GreekKeys}
****** $Diogenes::Base::encoding{ISO_8859_7}
****** $Diogenes::Base::encoding{DOS_CP_737}
****** $Diogenes::Base::encoding{SuperGreek}
****** $Diogenes::Base::encoding{SIL_Composite}
****** $Diogenes::Base::encoding{Babel_7}
****** $Diogenes::Base::encoding{SPIonic}
****** $Diogenes::Base::encoding{Babel}
****** $Diogenes::Base::encoding{SGreek}
***** KOPTISCH
****** $Diogenes::Base::coptic_encoding{'UTF-8'}
******* $Diogenes::Base::coptic_encoding{'UTF-8'}{post_match} = $UTF_8_post;
****** $Diogenes::Base::coptic_encoding{'UTF-8-old'}
****** $Diogenes::Base::coptic_encoding{Koptos}

$Diogenes::Base::encoding{'UTF-8-DB'}{post_match} = $UTF_8_post;
*** %context                                                      :EXPORT_OK:
#+begin_src perl
$context{g} = {
    'sentence'  => '[.;]',
    'clause'    => '[.;:]',
    'phrase'    => '[.;:,_]', 
    'paragraph' => '[@{}]'
};
$context{l} = {
    'clause'    => '[.!?;:]',
    'sentence'  => '[.!?]',
    'phrase'    => '[.!?;:,_]',
    'paragraph' => '[@{}<>]'
};
#+end_src
*** @contexts                                                     :EXPORT_OK:
#+begin_src perl
@contexts = (
    'paragraph',
    'sentence',
    'clause',
    'phrase',
    '1 line',
    '2 lines',
    '5 lines',
    '10 lines',
    '50 lines',
    );
#+end_src
*** %choices                                                      :EXPORT_OK:
#+begin_src perl
%choices =  (
    'PHI Latin Corpus' => 'phi',
    'TLG Texts' => 'tlg',
    'TLG Bibliography' => 'bib',
    'Duke Documentary Papyri' => 'ddp',
    'Classical Inscriptions' =>'ins',
    'Christian Inscriptions' => 'chr',
    'Miscellaneous PHI Texts' => 'misc',
    'PHI Coptic Texts' => 'cop',
    );
#+end_src
*** %list_labels
*** %auths
*** %lists
*** %work                                                         :EXPORT_OK:
*** %lang
*** %author                                                       :EXPORT_OK:
*** %last_work                                                    :EXPORT_OK:
*** %work_start_block                                             :EXPORT_OK:
*** %level_label                                                  :EXPORT_OK:
*** %sub_works
*** %top_levels                                                   :EXPORT_OK:
*** %last_citation                                                :EXPORT_OK:
*** $bibliography
*** %coptic_encoding
*** %database                                                     :EXPORT_OK:
#+begin_src perl
%database =  (
    'phi' => 'PHI Latin Corpus',
    'tlg' => 'TLG Texts',
    'ddp' => 'Duke Documentary Papyri',
    'ins' => 'Classical Inscriptions',
    'chr' => 'Christian Inscriptions',
    'misc' => 'Miscellaneous PHI Texts',
    'cop' => 'PHI Coptic Texts',
    'bib' => 'TLG Bibliography',
    );
#+end_src
*** @databases                                                    :EXPORT_OK:
#+begin_src perl
@databases = qw(tlg phi ddp ins chr cop misc);
#+end_src

*** @filters                                                      :EXPORT_OK:
*** $RC_DEBUG
*** $OS und $code_page
#+begin_src perl
  use Encode;
  BEGIN {
    $OS = ($^O=~/MSWin/i or $^O=~/Win32/i or $^O =~/dos/) ? 'windows' :
      ($^O=~/darwin/i) ? 'mac' : 'unix';

    if ($OS eq 'windows' ) {
      eval "use Win32; 1" or die $@;
    }
  }

  # For Windows pathnames
  our $code_page;
  if ($OS eq 'windows') {
    $code_page = Win32::GetACP() || q{};
    if ($code_page) {
      $code_page = 'cp'.$code_page;
      $code_page = Encode::resolve_alias($code_page) || q{};
      print STDERR "Code page: $code_page\n";
    }
  }
#+end_src

*** $config_dir
** Exporter
#+begin_src perl
  use Exporter;
@Diogenes::Base::ISA = qw(Exporter Diogenes::UnicodeInput);
@Diogenes::Base::EXPORT_OK = qw(%encoding %context @contexts
    %choices %work %author %last_work %work_start_block %level_label
    %top_levels %last_citation %database @databases @filters);
#+end_src
** windows_filename
#+begin_src perl
  sub windows_filename {
    my ($filename) = @_;
    if ($code_page and not $code_page =~ m/utf|65001/) {
      # my $ret = Encode::from_to($filename, 'utf8', $codepage);
	# print STDERR "Codepage conversion failed\n" unless defined $ret;
      $filename = Encode::encode($code_page, $filename);
    }
    return $filename;
  }
#+end_src
** require 'Diogenes.map'
#+begin_src perl
   eval "require 'Diogenes.map';";
   $Diogenes::Base::map_error = $@;
   # Add in the built-in encodings
   $encoding{Beta} = {};
   $encoding{Ibycus} = {};
   $encoding{Transliteration} = {};
   # UTF-8 is just an alias for -CB (precomposed characters)
   $encoding{'UTF-8'} = $encoding{'UTF-8-CB'};
#+end_src

Diogenes.map definiert %encoding
** Konstanten und flush buffer $|
#+begin_src perl
# Here are some handy constants
use constant MASK     => hex '7f';
use constant RMASK    => hex '0f';
use constant LMASK    => hex '70';
use constant OFF_MASK => hex '1fff';
$| = 1;
#+end_src
** Defaults
Default values for all Diogenes options.
Overridden by rc files and constructor args.

#+begin_src perl
# Default values for all Diogenes options.
# Overridden by rc files and constructor args.
my %defaults = (
    type => 'phi',
    output_format => 'ascii',
    highlight => 1,
    printer => 0,
    input_lang => '',
    input_raw => 0,
    input_pure => 0,
    input_beta => 0,
    debug => 0,
    bib_info => 1,
    max_context => 20,
    encoding => 'UTF-8',
    
    # System-wide defaults
    tlg_dir => '',
    phi_dir => '',
    ddp_dir => '',
    tll_pdf_dir => '',
    # Not a dir but a file path, but this makes the Electron code easier
    old_pdf_dir => '',
    authtab => 'authtab.dir',
    tlg_file_prefix => 'tlg',
    phi_file_prefix => 'lat',
    ddp_file_prefix => 'ddp',
    ins_file_prefix => 'ins',
    chr_file_prefix => 'chr',
    cop_file_prefix => 'cop',
    misc_file_prefix => 'civ',
    uppercase_files => 0,
    dump_file => '', 
    blacklist_file => '', 
    blacklisted_works_file => '', 
    ibycus4 => 0,
    prosody => 0,
    psibycus => 0,
    idt_suffix => '.idt',
    txt_suffix => '.txt',
    latex_pointsize => '',
    latex_baseskip => '',
    latex_counter => 1,

    # Slower, but not rooted at the start of words
    use_tlgwlinx => 0,
    
    # Lines per pass in browser
    browse_lines => 29,
    
    # Pattern to match
    pattern => '',
    pattern_list => [],
    min_matches => 1,
    context => 'sentence',
    reject_pattern => '',
    
    # The max number of lines for different types of context
    overflow => {
        'sentence'      => 10,
        'clause'        => 5,
        'phrase'        => 3,
        'paragraph'     => 20,
    },
    
    # Additional file handle to write raw output to 
    aux_out => undef,
    input_source => undef,
    
    coptic_encoding => 'UTF-8',
    input_encoding => 'Unicode',

    # These are obsolete -- kept to avoid errors in old config files
    cgi_input_format => '',
    perseus_server => '',

    cgi_default_corpus => 'TLG Texts', 
    cgi_default_encoding => 'UTF-8', 
    cgi_buttons => 'Go to Context', 
    cgi_font => '', 
    default_criteria => 'All',
    cgi_multiple_fields => 6,
    check_mod_perl => 0,

    perseus_links => 1, # links to Perseus morphological parser 
    perseus_show => "split",

    hit_html_start => '<font color="red"><b><u>',
    hit_html_end => '</u></b></font>',
    quiet => 0,

    line_print_modulus => 5,

    # Chronological search may be a bit slower, but negligible these days.
    tlg_use_chronology => 1,

    # For multiple matching, count multiple matches for each pattern
    repeat_matches => 0,

    # obsolete
    user => 'default',

    # Use the bug-prone ToC in the idt file (maybe for slow computers)
    use_idt_browsing => 0,

    # After this many characters of search output, stop chunk after current author
    chunk_size => 1000000,
    seen_author_list => [],
    hits => 0,
    );
#+end_src
*** Main
**** type => 'phi'
**** output_format => 'ascii'
**** highlight => 1
**** printer => 0
**** input_lang => ''
**** input_raw => 0
**** input_pure => 0
**** input_beta => 0
**** debug => 0
**** bib_info => 1
**** max_context => 20
**** encoding => 'UTF-8'
    
*** System-wide defaults
**** tlg_dir => ''
**** phi_dir => ''
**** ddp_dir => ''
**** tll_pdf_dir => ''
**** old_pdf_dir => ''
# Not a dir but a file path, but this makes the Electron code easier
**** authtab => 'authtab.dir'
**** tlg_file_prefix => 'tlg'
**** phi_file_prefix => 'lat'
**** ddp_file_prefix => 'ddp'
**** ins_file_prefix => 'ins'
**** chr_file_prefix => 'chr'
**** cop_file_prefix => 'cop'
**** misc_file_prefix => 'civ'
**** uppercase_files => 0
**** dump_file => ''
**** blacklist_file => ''
**** blacklisted_works_file => ''
**** ibycus4 => 0
**** prosody => 0
**** psibycus => 0
**** idt_suffix => '.idt'
**** txt_suffix => '.txt'
**** latex_pointsize => ''
**** latex_baseskip => ''
**** latex_counter => 1
**** use_tlgwlinx => 0
Slower, but not rooted at the start of words

*** Lines per pass in browser
**** browse_lines => 29

*** Patterns
**** pattern => ''
**** pattern_list => []
**** min_matches => 1
**** context => 'sentence'
**** reject_pattern => ''
    
*** The max number of lines for different types of context

**** overflow =>
***** 'sentence'      => 10,
***** 'clause'        => 5,
***** 'phrase'        => 3,
***** 'paragraph'     => 20,
    
*** Additional file handle to write raw output to 
**** aux_out => undef,
**** input_source => undef,

*** Encodings
**** coptic_encoding => 'UTF-8'
**** input_encoding => 'Unicode'

*** Obsolete
#+begin_src perl
    # These are obsolete -- kept to avoid errors in old config files
    cgi_input_format => '',
    perseus_server => '',

    cgi_default_corpus => 'TLG Texts', 
    cgi_default_encoding => 'UTF-8', 
    cgi_buttons => 'Go to Context', 
    cgi_font => '', 
    default_criteria => 'All',
    cgi_multiple_fields => 6,
    check_mod_perl => 0,

    perseus_links => 1, # links to Perseus morphological parser 
    perseus_show => "split",

    hit_html_start => '<font color="red"><b><u>',
    hit_html_end => '</u></b></font>',
    quiet => 0,

    line_print_modulus => 5,

    # obsolete
    user => 'default',
#+end_src

*** tlg_use_chronology => 1,
    Chronological search may be a bit slower, but negligible these days.
 
*** repeat_matches => 0,
    For multiple matching, count multiple matches for each pattern

*** use_idt_browsing => 0,
    Use the bug-prone ToC in the idt file (maybe for slow computers)
 
*** chunk_size => 1000000,

*** seen_author_list => [],
*** hits => 0,
** validate
Validierung und Normalisierung der übergebenen Parameter: Der
Schlüsselbegriff muss in %defaults vorhanden sein!

#+begin_src perl
sub validate
{
    my $key = shift;
    $key =~ s/-?(\w+)/\L$1/;
    return $key if exists $defaults{$key};
    die ("Configuration file error in parameter: $key\n");
};
#+end_src

** get_user_config_dir
#+begin_src perl
  # The electron client sets the environment variable.
  sub get_user_config_dir
  {
      if ($ENV{'Diogenes_Config_Dir'})
      {
	  return $ENV{'Diogenes_Config_Dir'};

      }
      elsif ($OS eq 'unix')
      {
	  # Electron's config dirs, which we will want to use from the
	  # command-line if settings were earlier set from the GUI
	  if ($ENV{XDG_CONFIG_HOME} and -e "$ENV{XDG_CONFIG_HOME}/Diogenes") {
	      return "$ENV{XDG_CONFIG_HOME}/Diogenes/";
	  }
	  elsif (-e "$ENV{HOME}/.config/Diogenes") {
	      return "$ENV{HOME}/.config/Diogenes/";
	  }
	  elsif ($ENV{HOME})
	  {
	      # The old, pre-Electron config dir
	      return "$ENV{HOME}/.diogenes/";
	  }
	  else { warn "Could not find user profile dir! \n" }
      }
      elsif ($OS eq 'mac')
      {
	  if ($ENV{HOME})
	  {
	      return "$ENV{HOME}/Library/Application Support/Diogenes/";
	  }
	  else { warn "Could not find user profile dir! \n" }
      }
      elsif ($OS eq 'windows')
      {
	  if ($ENV{USERPROFILE})
	  {
	      if (-e "$ENV{USERPROFILE}\\AppData\\Roaming")
	      {
		  # Vista
		  return "$ENV{USERPROFILE}\\AppData\\Roaming\\Diogenes\\";
	      }
	      elsif (-e "$ENV{USERPROFILE}\\Application Data")
	      {
		  # Windows 2000 and XP
		  return "$ENV{USERPROFILE}\\Application Data\\Diogenes\\";
	      }
	      else { warn "Could not find user profile dir!! \n" }
	  }
	  else { warn "Could not find user profile dir! \n" }
      }
  }

# Global var for diogenes-server.pl
$config_dir = get_user_config_dir();
  
#+end_src
** read_config_files
#+begin_src perl
sub read_config_files
{
    my $self = shift;
    my %configuration = ();
    
    my @rc_files;
    
    # System-wide config files, in case they are needed.
    if ($OS eq 'unix')
    {
        @rc_files = ('/etc/diogenes.config');
    }
    elsif ($OS eq 'mac')
    {
        @rc_files = ('/Library/Application Support/Diogenes/diogenes.config');
    }
    elsif ($OS eq 'windows')
    {
        @rc_files = ('C:\\diogenes.config');
    }
    push @rc_files, $self->{auto_config};
    push @rc_files, $self->{user_config};
    
    my ($attrib, $val);
    
    foreach my $rc_file @rc_files
    {
        next unless $rc_file;
        print STDERR "Trying config file: $rc_file ... " if $RC_DEBUG;
        next unless -e $rc_file;
        open RC, '<:encoding(UTF-8)', "$rc_file" or die ("Can't open (apparently extant) file $rc_file: $!");
        print STDERR "Opened.\n" if $RC_DEBUG;
        local $/ = "\n";
        while (<RC>) 
        {
            next if m/^#/;
            next if m/^\s*$/;
            ($attrib, $val) = m#^\s*(\w+)[\s=]+((?:"[^"]*"|[\S]+)+)#;
            $val =~ s#"([^"]*)"#$1#g;
            print STDERR "parsing $rc_file for '$attrib' = '$val'\n" if $RC_DEBUG;
            die "Error parsing $rc_file for $attrib and $val: $_\n" unless 
                $attrib and defined $val;
            $attrib = validate($attrib);
            $configuration{$attrib} = $val;   
        }
        close RC or die ("Can't close $rc_file");
    }
    return %configuration;
}
#+end_src

Liest die folgenden Konfigurationsdateien ein:
- /etc/diogenes.config (Systemweite Konfiguration)
- $self->{auto_config} = File::Spec->catfile($user_config_dir, 'diogenes.prefs');
- $self->{user_config} = File::Spec->catfile($user_config_dir, 'diogenes.config');
Folgende Formate sind zulässig:
- Schlüssel Wert
- Schlüssel=Wert
- Schlüssel="Wert"

** TODO read_tlg_chronology
#+begin_src perl
  sub read_tlg_chronology {
      my $self = shift;
      return if $self->{tlg_chron_info} or $self->{tlg_ordered_filenames}
	or $self->{tlg_ordered_authnums};
      my ($vol, $dir, $file) = File::Spec->splitpath(module_path('Diogenes::Base'));
      my $chron_file = File::Spec->catpath( $vol, $dir, 'tlg-chronology.txt');
      open my $chron_fh, "<$chron_file" or die "Could not open $chron_file: $!";
      local $/ = "\n";
      while (<$chron_fh>) {
	  if (m/^(\d\d\d\d)\s+(.*?)$/) {
	      my $num = $1;
	      my $date = $2;
	      $date =~ s/\s+$//;
	      my $filename = $self->{tlg_file_prefix}.$num.$self->{txt_suffix};
	      my $path = File::Spec->catpath("", $self->{tlg_dir}, $filename);
	      if (-e $path) {
		  push @{ $self->{tlg_ordered_filenames} }, $filename;
		  push @{ $self->{tlg_ordered_authnums} }, $num;
		  $self->{tlg_chron_info}{$num} = $date;
	      }
	      else {
		  die "Missing TLG file: $filename\n";
	      }
	  }
	  else {
	      die "Badly formed line in $chron_file: $_";
	  }
      }
  }
#+end_src

** new                                                          :Constructor:
#+begin_src perl
sub new 
{
    my $proto = shift;
    my $type = ref($proto) || $proto;
    my $self = {};
    bless $self, $type;
    
    my %args;
    my %passed = @_;

    $args{ validate($_) } = $passed{$_} foreach keys %passed;

    my $user_config_dir = get_user_config_dir;
    # For prefs saved by Electron.js and Settings.cgi
    $self->{auto_config} = File::Spec->catfile($user_config_dir, 'diogenes.prefs');
    # For manual editing by the user
    $self->{user_config} = File::Spec->catfile($user_config_dir, 'diogenes.config');
    # For saving user-defined corpora
    $self->{filter_file} = File::Spec->catfile($user_config_dir, 'diogenes.corpora');

    # We just re-read the config file each time.  It would be nice to
    # do this only when needed, but then you need to arrange for
    # communication between one process doing the writing and another
    # doing the reading.

    %{ $self } = ( %{ $self }, %defaults, $self->read_config_files, %args );
    
    my @dirs = qw/tlg_dir phi_dir ddp_dir tll_pdf_dir old_pdf_dir/;

    # Make sure all the directories end in a '/' (except for empty
    # values).
    for my $dir @dirs
    {
        if ($OS eq 'windows') {
            $self->{$dir} = windows_filename($self->{$dir});
        }
        next if $dir eq 'old_pdf_dir';
        $self->{$dir} .= '/' unless $self->{$dir} eq '' or
            $self->{$dir} =~ m#[/\\]$#;
        # print STDERR "--$dir: $self->{$dir}\n";
    }
    
    # Clone values that are references, so we don't clobber what was passed.
    $self->{pattern_list} = [@{$self->{pattern_list}}] if $self->{pattern_list};
    $self->{seen_author_list} = [@{$self->{seen_author_list}}] if $self->{seen_author_list};
    $self->{overflow}     = {%{$self->{overflow}}}     if $self->{overflow};

    $self->{type} = 'tlg' if ref $self eq 'Diogenes_indexed';
    $self->{debug} = 1 if $ENV{Diogenes_Debug};
    
    unless ($self->{type} eq 'none')
    {
        $self->{word_key} = "";
        $self->{current_work} = 0;
        $self->{word_list} = {};
        $self->{auth_num} = 0;
        $self->{work_num} = 0;
        $self->{list_total} = 0;
    }
    print STDERR "\nTYPE: $self->{type}\n" if $self->{debug};
    print STDERR "input_lang: $self->{input_lang}\n" if $self->{debug};
    # Dummy object where no database access is desired -- e.g. to get at 
    # configuration values or to format some Greek input from elsewhere.
    if ($self->{type} eq 'none') 
    {
        $self->{cdrom_dir}   = undef;
        $self->{file_prefix} = "";
    }
    # PHI
    elsif ($self->{type} eq 'phi') 
    {
        $self->{cdrom_dir}   = $self->{phi_dir};
        $self->{file_prefix} = $self->{phi_file_prefix};
        $self->{input_lang} = 'l' unless $self->{input_lang};
    }
    
    # TLG
    elsif ($self->{type} eq 'tlg') 
    {
        $self->{cdrom_dir}   = $self->{tlg_dir};
        $self->{file_prefix} = $self->{tlg_file_prefix};
        $self->{input_lang} = 'g' unless $self->{input_lang};
    }
    
    # DDP
    elsif ($self->{type} eq 'ddp') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{ddp_file_prefix};
        $self->{input_lang} = 'g' unless $self->{input_lang};
        $self->{documentary} = 1;
    }
    
    # INS
    elsif ($self->{type} eq 'ins') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{ins_file_prefix};
        $self->{documentary} = 1;
    }
    # CHR
    elsif ($self->{type} eq 'chr') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{chr_file_prefix};
        $self->{documentary} = 1;
    }
    
    # COP
    elsif ($self->{type} eq 'cop') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{cop_file_prefix};
        $self->{latin_handler} = \&beta_latin_to_utf;
        $self->{coptic_encoding} = 'beta' if 
            $args{output_format} and $args{output_format} eq 'beta';
        $self->{input_lang} = 'c' unless $self->{input_lang};
    }
    
    # CIV
    elsif ($self->{type} eq 'misc') 
    {
        $self->{cdrom_dir}   = $self->{phi_dir};
        $self->{file_prefix} = $self->{misc_file_prefix};
    }
    # BIB
    elsif ($self->{type} eq 'bib') 
    {
        $self->{cdrom_dir}   = $self->{tlg_dir};
        $self->{file_prefix} = 'doccan';
    }
    else 
    {
        die ("I did not understand the type => $self->{type}\n");
    }

    # For all searches:
    
    if (exists $self->{pattern}
        and not exists $self->{pattern_list})
    {
        $self->{pattern_list} = [$self->{pattern}];
        $self->{min_matches_int} = 1;
    }
    elsif ($self->{pattern})
    {
        push @{ $self->{pattern_list} }, $self->{pattern};
    }
    $self->{word_pattern} = $self->{pattern};

    if ($self->{input_encoding} eq 'BETA code') {
        $self->{input_beta} = 1;
    }
    
    # With Unicode we don't have to guess whether the input is Latin or Greek
    if ($self->{input_encoding} eq 'Unicode') {
        $self->unicode_make_patterns;
    }
    elsif (ref $self eq 'Diogenes::Indexed') 
    {
        $self->{pattern} = $self->simple_latin_to_beta ($self->{pattern});
    }
    elsif (ref $self eq 'Diogenes::Search') 
    {
        if ($self->{input_lang} =~ /^g/i)   
        { 
            $self->make_greek_patterns_translit; 
        }
        elsif ($self->{input_lang} =~ /^l/i) 
        { 
            $self->make_latin_pattern;
        }
    }

    if (defined $self->{cdrom_dir}
        and not -e File::Spec->catfile($self->{cdrom_dir}, 'authtab.dir')
        and -e File::Spec->catfile($self->{cdrom_dir}, 'AUTHTAB.DIR'))
    {
        $self->{uppercase_files} = 1;
    }
    
    # Evidently some like to mount their CD-Roms in uppercase
    if ($self->{uppercase_files})
    {
        $self->{$_} = uc $self->{$_} for 
            qw(file_prefix txt_suffix idt_suffix authtab tlg_file_prefix);
    }

    # This has to come after we have adjusted for uppercase
    if ($self->{type} eq 'tlg' and $self->{tlg_use_chronology}) {
        $self->read_tlg_chronology;
    }

    
    # min_matches_int is for "internal", since we have to munge it here
    $self->{min_matches_int} = '';
    unless (ref $self eq 'Diogenes_indexed')
    {
        $self->{min_matches_int} = $self->{min_matches};
        $self->{min_matches_int} = 1 if $self->{min_matches} eq 'any';
        $self->{min_matches_int} =  scalar @{ $self->{pattern_list} } if 
            $self->{min_matches} eq 'all';
    }
    print STDERR "MM: $self->{min_matches}\n" if $self->{debug};
    print STDERR "MMI: $self->{min_matches_int}\n" if $self->{debug};
    
    $self->{context} = $1 if 
        $self->{context} =~ /(sentence|paragraph|clause|phrase|level|\d+\s*(?:lines?)?)/i;
    $self->{context} = lc $self->{context};
    die "Undefined value for context.\n" unless defined $self->{context};
    die "Illegal value for context: $self->{context}\n" unless 
        $self->{context} =~ 
        m/^(?:sentence|paragraph|clause|phrase|level|\d+\s*(?:lines?)?)$/;
    $self->{numeric_context} = ($self->{context} =~ /\d/) ? 1 : 0;
    print STDERR "Context: $self->{context}\n" if $self->{debug};
    
    # Check for external encoding
    die "You have asked for an external output encoding ($self->{encoding}), "
        . "but I was not able to load a Diognes.map file in which such encodings "
        . "are defined: $Diogenes::Base::map_error \n"  
        if  $self->{encoding} and $Diogenes::Base::map_error;
    die "You have specified an encoding ($self->{encoding}) that does not "
        . "appear to have been defined in your Diogenes.map file.\n\n"
        . "The following Greek encodings are available:\n"
        . (join "\n", $self->get_encodings)
        . "\n\n"
        if $self->{encoding} and not exists $encoding{$self->{encoding}};
    
    # Some defaults       
    if (not $self->{encoding})
    {
        # force encoding Ibycus for repaging output removing hyphens and
        # using TLG non-ascii markers for section references.  PAM 090102
        $self->{encoding} = 'Ibycus' if $self->{output_format} =~ m/repaging/i;
        $self->{encoding} = 'Ibycus' if $self->{output_format} =~ m/latex/i;
        $self->{encoding} = 'Transliteration' if $self->{output_format} =~ m/ascii/i;
        $self->{encoding} = 'UTF-8' if $self->{output_format} =~ m/html/i;
        $self->{encoding} = 'Beta' if $self->{output_format} =~ m/beta/i;
    }
    
    $self->set_handlers;    
    
    print STDERR "Using prefix: $self->{file_prefix}\nUsing pattern(s): ",
    join "\n\n", @{ $self->{pattern_list} }, "\n\n" if $self->{debug};
    print STDERR "Using reject pattern: $self->{reject_pattern}\n" if 
        $self->{debug} and $self->{reject_pattern};
    
    # Read in some preliminary data, except for a dummy object
    if (($self->{type} eq 'none') or ($self->parse_authtab))
    {
        if ($self->{bib_info})
        {
            $self->read_tlg_biblio if $self->{type} eq 'tlg';
            $self->read_phi_biblio if $self->{type} eq 'phi';
        }
    }
    return $self;
}
#+end_src

*** Erstellung der Instanz
Die Instanz wird erzeugt als leeres Hash. Sie kann sowohl von der
Klasse aus als auch von einer Schwesterklasse aus aufgerufem werden
#+begin_src perl
    my $proto = shift;
    my $type = ref($proto) || $proto;
    my $self = {};
    bless $self, $type;
#+end_src

*** Übertragung der Argumente
Die Funktion validate normalisiert die Argumente (lc, ohne -) und
prüft, ob die jeweiligen Schlüsselbegriffe in %default vorhanden ist.
#+begin_src perl
    my %args;
    my %passed = @_;

    $args{ validate($_) } = $passed{$_} foreach keys %passed;
#+end_src

*** Einlesen der Konfigurationsdateien und Aktualisierung des Objekts
get_user_config_dir bestimmt nach System und Environment-Variable den
Pfad zu dem Konfigurationsverzeichnis. Dann werden in auto_config,
user_config und filter_file die die Pfade zu den drei
Konfigurationsdteien angelegt. Schließlich wird das Objekt
zusammengesetzt: Erst das bisherige Objekt, dann die %defaults, dann
die Konfigurationsdateien und schließlich die Argumente (wobei die
späteren Daten die früheren überschreiben).

#+begin_src perl
    my $user_config_dir = get_user_config_dir;
    # For prefs saved by Electron.js and Settings.cgi
    $self->{auto_config} = File::Spec->catfile($user_config_dir, 'diogenes.prefs');
    # For manual editing by the user
    $self->{user_config} = File::Spec->catfile($user_config_dir, 'diogenes.config');
    # For saving user-defined corpora
    $self->{filter_file} = File::Spec->catfile($user_config_dir, 'diogenes.corpora');

    # We just re-read the config file each time.  It would be nice to
    # do this only when needed, but then you need to arrange for
    # communication between one process doing the writing and another
    # doing the reading.

    %{ $self } = ( %{ $self }, %defaults, $self->read_config_files, %args );
#+end_src

*** Nachbearbeitung der Pfade in @dirs
Alle in @dirs enthaltenen Pfade erhalten ein / am Ende
#+begin_src perl
    my @dirs = qw/tlg_dir phi_dir ddp_dir tll_pdf_dir old_pdf_dir/;

    # Make sure all the directories end in a '/' (except for empty
    # values).
    for my $dir @dirs
    {
        if ($OS eq 'windows') {
            $self->{$dir} = windows_filename($self->{$dir});
        }
        next if $dir eq 'old_pdf_dir';
        $self->{$dir} .= '/' unless $self->{$dir} eq '' or
            $self->{$dir} =~ m#[/\\]$#;
        # print STDERR "--$dir: $self->{$dir}\n";
    }
#+end_src

*** Als Referenzen übergebene Werte werden kopiert
pattern_list, seen_author_list und overflow werden als Referenzen
übergeben und müssen kopiert werden, um auf eigene Werte zu verweisen.
#+begin_src perl
    # Clone values that are references, so we don't clobber what was passed.
    $self->{pattern_list} = [@{$self->{pattern_list}}] if $self->{pattern_list};
    $self->{seen_author_list} = [@{$self->{seen_author_list}}] if $self->{seen_author_list};
    $self->{overflow}     = {%{$self->{overflow}}}     if $self->{overflow};
#+end_src

*** Initialisierung einiger Standartwerted
**** TLG bei Indexed, Aktivierung von debug durch die Umgebungsvariable Diogenes_Debug
#+begin_src perl
    $self->{type} = 'tlg' if ref $self eq 'Diogenes_indexed';
    $self->{debug} = 1 if $ENV{Diogenes_Debug};
#+end_src
**** Laufvariablen in echten Objekten
#+begin_src perl
    unless ($self->{type} eq 'none')
    {
        $self->{word_key} = "";
        $self->{current_work} = 0;
        $self->{word_list} = {};
        $self->{auth_num} = 0;
        $self->{work_num} = 0;
        $self->{list_total} = 0;
    }
#+end_src
**** Ausgabe der ersten Debuginformation
#+begin_src perl
    print STDERR "\nTYPE: $self->{type}\n" if $self->{debug};
    print STDERR "input_lang: $self->{input_lang}\n" if $self->{debug};
#+end_src
**** Typspezifische Variablenwerte
***** Dummy-Objekt
#+begin_src perl
    # Dummy object where no database access is desired -- e.g. to get at 
    # configuration values or to format some Greek input from elsewhere.
    if ($self->{type} eq 'none') 
    {
        $self->{cdrom_dir}   = undef;
        $self->{file_prefix} = "";
    }
#+end_src
***** PHI
#+begin_src perl
    # PHI
    elsif ($self->{type} eq 'phi') 
    {
        $self->{cdrom_dir}   = $self->{phi_dir};
        $self->{file_prefix} = $self->{phi_file_prefix};
        $self->{input_lang} = 'l' unless $self->{input_lang};
    }
#+end_src
***** TLG
#+begin_src perl
    # TLG
    elsif ($self->{type} eq 'tlg') 
    {
        $self->{cdrom_dir}   = $self->{tlg_dir};
        $self->{file_prefix} = $self->{tlg_file_prefix};
        $self->{input_lang} = 'g' unless $self->{input_lang};
    }
#+end_src
***** DDP
#+begin_src perl
    # DDP
    elsif ($self->{type} eq 'ddp') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{ddp_file_prefix};
        $self->{input_lang} = 'g' unless $self->{input_lang};
        $self->{documentary} = 1;
    }
#+end_src
***** INS
#+begin_src perl
    # INS
    elsif ($self->{type} eq 'ins') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{ins_file_prefix};
        $self->{documentary} = 1;
    }
#+end_src
***** CHR
#+begin_src perl
    # CHR
    elsif ($self->{type} eq 'chr') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{chr_file_prefix};
        $self->{documentary} = 1;
    }
#+end_src
***** COP
#+begin_src perl
    # COP
    elsif ($self->{type} eq 'cop') 
    {
        $self->{cdrom_dir}   = $self->{ddp_dir};
        $self->{file_prefix} = $self->{cop_file_prefix};
        $self->{latin_handler} = \&beta_latin_to_utf;
        $self->{coptic_encoding} = 'beta' if 
            $args{output_format} and $args{output_format} eq 'beta';
        $self->{input_lang} = 'c' unless $self->{input_lang};
    }
#+end_src
***** CIV
#+begin_src perl
    # CIV
    elsif ($self->{type} eq 'misc') 
    {
        $self->{cdrom_dir}   = $self->{phi_dir};
        $self->{file_prefix} = $self->{misc_file_prefix};
    }
#+end_src
***** BIB
#+begin_src perl
    # BIB
    elsif ($self->{type} eq 'bib') 
    {
        $self->{cdrom_dir}   = $self->{tlg_dir};
        $self->{file_prefix} = 'doccan';
    }
#+end_src
***** Fallback
#+begin_src perl
    else 
    {
        die ("I did not understand the type => $self->{type}\n");
    }
#+end_src
**** pattern und pattern_list
Wenn es nur ein pattern gibt, wird pattern zur patternlist, ansonsten
wird pattern patternlist hinzugefügt. word_pattern wird mit pattern gleichgesetzt.
#+begin_src perl
    if (exists $self->{pattern}
        and not exists $self->{pattern_list})
    {
        $self->{pattern_list} = [$self->{pattern}];
        $self->{min_matches_int} = 1;
    }
    elsif ($self->{pattern})
    {
        push @{ $self->{pattern_list} }, $self->{pattern};
    }
    $self->{word_pattern} = $self->{pattern};
#+end_src
**** Enkodierungen
Betacode-Enkodierungen haben die spezielle Variable input_beta.
Unicode-Encodierungen ruft unicode-make-patterns auf, das wiederum
unicode_pattern aus Unicode:Input aufruft: Diese Methode stellt
aufgrund des verwendeten Zeichenvorrats die Enkodierung des Musters
fest und gibt es dann in Abhängigkeit mit der aktuellen Klasse in der
Kodierung zurück, das die Klasse für ihre Arbeit benötigt. Für alle
anderen Kodierugnen wird diese Arbeit hier erledigt.
#+begin_src perl
    if ($self->{input_encoding} eq 'BETA code') {
        $self->{input_beta} = 1;
    }
    
    # With Unicode we don't have to guess whether the input is Latin or Greek
    if ($self->{input_encoding} eq 'Unicode') {
        $self->unicode_make_patterns;
    }
    elsif (ref $self eq 'Diogenes::Indexed') 
    {
        $self->{pattern} = $self->simple_latin_to_beta ($self->{pattern});
    }
    elsif (ref $self eq 'Diogenes::Search') 
    {
        if ($self->{input_lang} =~ /^g/i)   
        { 
            $self->make_greek_patterns_translit; 
        }
        elsif ($self->{input_lang} =~ /^l/i) 
        { 
            $self->make_latin_pattern;
        }
    }
#+end_src
**** uppercase filenames
#+begin_src perl
      if (defined $self->{cdrom_dir}
        and not -e File::Spec->catfile($self->{cdrom_dir}, 'authtab.dir')
        and -e File::Spec->catfile($self->{cdrom_dir}, 'AUTHTAB.DIR'))
    {
        $self->{uppercase_files} = 1;
    }
    
    # Evidently some like to mount their CD-Roms in uppercase
    if ($self->{uppercase_files})
    {
        $self->{$_} = uc $self->{$_} for 
            qw(file_prefix txt_suffix idt_suffix authtab tlg_file_prefix);
    }
#+end_src
***** TLG read chronology
#+begin_src perl
    # This has to come after we have adjusted for uppercase
    if ($self->{type} eq 'tlg' and $self->{tlg_use_chronology}) {
        $self->read_tlg_chronology;
    }
#+end_src

**** TODO Minimal Matches Internal
#+begin_src perl
      # min_matches_int is for "internal", since we have to munge it here
    $self->{min_matches_int} = '';
    unless (ref $self eq 'Diogenes_indexed')
    {
        $self->{min_matches_int} = $self->{min_matches};
        $self->{min_matches_int} = 1 if $self->{min_matches} eq 'any';
        $self->{min_matches_int} =  scalar @{ $self->{pattern_list} } if 
            $self->{min_matches} eq 'all';
    }
    print STDERR "MM: $self->{min_matches}\n" if $self->{debug};
    print STDERR "MMI: $self->{min_matches_int}\n" if $self->{debug};
#+end_src

**** Normalisierung und Validierung der Kontextvariablen
#+begin_src perl
    $self->{context} = $1 if 
        $self->{context} =~ /(sentence|paragraph|clause|phrase|level|\d+\s*(?:lines?)?)/i;
    $self->{context} = lc $self->{context};
    die "Undefined value for context.\n" unless defined $self->{context};
    die "Illegal value for context: $self->{context}\n" unless 
        $self->{context} =~ 
        m/^(?:sentence|paragraph|clause|phrase|level|\d+\s*(?:lines?)?)$/;
    $self->{numeric_context} = ($self->{context} =~ /\d/) ? 1 : 0;
    print STDERR "Context: $self->{context}\n" if $self->{debug};
#+end_src

**** Fehlerbehandlung bei selbstdefinierten Enkodierungen
#+begin_src perl
    # Check for external encoding
    die "You have asked for an external output encoding ($self->{encoding}), "
        . "but I was not able to load a Diognes.map file in which such encodings "
        . "are defined: $Diogenes::Base::map_error \n"  
        if  $self->{encoding} and $Diogenes::Base::map_error;
    die "You have specified an encoding ($self->{encoding}) that does not "
        . "appear to have been defined in your Diogenes.map file.\n\n"
        . "The following Greek encodings are available:\n"
        . (join "\n", $self->get_encodings)
        . "\n\n"
        if $self->{encoding} and not exists $encoding{$self->{encoding}};
#+end_src

**** Standartkodierungen bei nicht gesetzter Kodierung
#+begin_src perl
    if (not $self->{encoding})
    {
        # force encoding Ibycus for repaging output removing hyphens and
        # using TLG non-ascii markers for section references.  PAM 090102
        $self->{encoding} = 'Ibycus' if $self->{output_format} =~ m/repaging/i;
        $self->{encoding} = 'Ibycus' if $self->{output_format} =~ m/latex/i;
        $self->{encoding} = 'Transliteration' if $self->{output_format} =~ m/ascii/i;
        $self->{encoding} = 'UTF-8' if $self->{output_format} =~ m/html/i;
        $self->{encoding} = 'Beta' if $self->{output_format} =~ m/beta/i;
    }
#+end_src

***** set_handlers
set_handlers definiert die Werte greek_handler und latin_handler:
Beides sind Referenzen auf Methoden, die Betacode in die jeweilige
Codierung umwandelnd.

Zusätzlich wird persues_morph auf 1 gesetzt, wenn der Output nach HTML
gehen soll.
#+begin_src perl
    $self->set_handlers;
#+end_src

**** Zusätzliche Debug-Informationen
- Prefix
- Pattern(s)
- Reject Pattern
#+begin_src perl
    print STDERR "Using prefix: $self->{file_prefix}\nUsing pattern(s): ",
    join "\n\n", @{ $self->{pattern_list} }, "\n\n" if $self->{debug};
    print STDERR "Using reject pattern: $self->{reject_pattern}\n" if 
        $self->{debug} and $self->{reject_pattern};
#+end_src

**** TLG-Biblio (?)
#+begin_src perl
    # Read in some preliminary data, except for a dummy object
    if (($self->{type} eq 'none') or ($self->parse_authtab))
    {
        if ($self->{bib_info})
        {
            $self->read_tlg_biblio if $self->{type} eq 'tlg';
            $self->read_phi_biblio if $self->{type} eq 'phi';
        }
    }
#+end_src

*** Rückgabe des fertigen Objekts
#+begin_src perl
    return $self;
#+end_src

** unicode_make_patterns
Methode, die sämtliche Muster von UnicodeInput::unicode_pattern
modifizieren lässt. Benutzt in new.
#+begin_src perl
    sub unicode_make_patterns {
      my $self = shift;
      $self->{reject_pattern} =
	$self->Diogenes::UnicodeInput::unicode_pattern($self->{reject_pattern});
      foreach my $pat @{ $self->{pattern_list} } {
	  $pat = $self->Diogenes::UnicodeInput::unicode_pattern($pat);
      }
    }
#+end_src

** check_db
Prüft, ob die aktuelle Datenbank verfügbar ist. Benutzt check_authtab.
#+begin_src perl
  # For nicest error handling, run check_db before doing a search to
# make sure current database is accessible
sub check_db
{
    my $self= shift;
    my $file = File::Spec->catfile($self->{cdrom_dir}, $self->{authtab});
    my $check = check_authtab($file);

    # Fix up the case where the "lat" prefix is wrong.
    if ($check and $self->{type} eq 'phi'
        and not -e File::Spec->catfile($self->{cdrom_dir}, $self->{file_prefix}.'0474'.$self->{txt_suffix})) {
        my $pre;
        # Look for Cicero
        foreach (qw(lat LAT phi PHI)) {
            if (-e File::Spec->catfile($self->{cdrom_dir}, $_.'0474'.$self->{txt_suffix})) {
                $pre = $_;
                last;
            }
        }
        if ($pre) {
            $self->{file_prefix} = $pre;
        }
        else {
            $self->barf('Found authtab, but could not find Cicero!');
            return undef;
        }
    }
    return $check;
}
#+end_src
** check_authtab
"Returns tlg, phi or ddp (or '' if not extant or recognized).  Class method."
#+begin_src perl
sub check_authtab
{
    my $file = shift;
    if (-e $file)
    {
        open AUTHTAB, "<$file" or warn ("Can't open (apparently extant) file $file: $!");
        my $buf;
        read AUTHTAB, $buf, 4;
        $buf =~ s/^\*//;
        $buf = lc $buf;
        $buf = 'phi' if $buf eq 'lat';
        $buf = 'ddp' if $buf eq 'ins' or $buf eq 'chr' or $buf eq 'cop';
        return $buf if $buf eq 'tlg' or $buf eq 'phi' or $buf eq 'ddp';
        return '';
    }
    return '';
}
#+end_src
** set_handlers
Legt die Kodierung für die Ausgabe fest (?). Benutzt von new.
#+begin_src perl
  sub set_handlers
{
    my $self = shift;
    
    if ($self->{encoding} =~ m/Beta/i)
    {
        $self->{greek_handler} = sub { return shift };
        $self->{latin_handler} = sub { return shift };
    }
    elsif ($self->{encoding} =~ m/Ibycus/i)
    {
        print STDERR "Ibycus encoding\n" if $self->{debug};
        $self->{greek_handler} = sub { beta_encoding_to_ibycus($self, shift)} ;
        $self->{latin_handler} = \&beta_encoding_to_latin1;
    }
    elsif ($self->{encoding} =~ m/Transliteration/i)
    {
        print STDERR "Transliteration encoding\n" if $self->{debug};
        $self->{greek_handler} = sub { beta_encoding_to_transliteration($self, shift)} ;
        $self->{latin_handler} = \&beta_encoding_to_latin1;
    }
    elsif ($self->{encoding} =~ m/ISO_8859_7/i)
    {
        $self->{greek_handler} = sub { beta_encoding_to_external($self, shift) }; 
        $self->{latin_handler} = sub { return shift };
    }
    elsif ($self->{encoding} =~ m/Babel/i)
    {
        $self->{greek_handler} = sub { beta_encoding_to_external($self, shift) }; 
        $self->{latin_handler} = \&beta_encoding_to_latin_tex;
    }
    elsif ($self->{encoding} =~ m/utf/i)
    {
        $self->{greek_handler} = sub { beta_encoding_to_external($self, shift) }; 
        $self->{latin_handler} = \&beta_latin_to_utf;
    }
    # The fall-back
    elsif (defined $encoding{$self->{encoding}})
    {
        $self->{greek_handler} = sub { beta_encoding_to_external($self, shift) }; 
        $self->{latin_handler} = \&beta_encoding_to_latin1;
    }
    else 
    {
        die "I don't know what to do with $self->{encoding}!\n";
    }

    $self->{perseus_morph} = 0 ; 
    $self->{perseus_morph} = 1 if 
        $self->{perseus_links} and $self->{output_format} =~ m/html/; 
    $self->{perseus_morph} = 0 if $self->{type} eq 'cop';
    $self->{perseus_morph} = 0 if $self->{encoding} =~ m/babel/i;
    
#       if ($self->{output_format} =~ m/html/i)
#       {
#               # Note that null chars need to stay in until the html or whatever is done.
#               # We make this a no-op instead of generating latin-1, because Netscape under
#               # Windows doesn't handle those chars properly with a Unicode font.
##              $self->{latin_handler} = sub {return shift };
#               $self->{latin_handler} = sub { beta_encoding_to_html($self, shift) };
#       }
#       if ($self->{output_format} =~ m/ascii/i)
#       {
#               $self->{latin_handler} = sub { beta_encoding_to_latin1(shift) };
#       }

}
#+end_src
** select_authors
#+begin_src perl
# Restricts the authors and works according to the settings passed,
# and returns the relevant authors and works.
sub select_authors 
{
    my $self = shift;
    my %passed = @_;
    my (%args, %req_authors, %req_a_w, %req_au, %req_auth_wk);
    my ($file, $baseline);
    
    $self->parse_lists if $self->{type} eq 'tlg' and not %list_labels;
    
    # A call with no params returns all authors.
    return $auths{$self->{type}} if (! %passed); 
    
    # This is how we get the categories into which the TLG authors are divided
    die "Only the TLG categorizes text by genre, date, etc.\n" 
        if $passed{'get_tlg_categories'} and $self->{type} ne 'tlg';
    return \%list_labels if $passed{'get_tlg_categories'};
    
    my @universal = (qw(criteria author_regex author_nums select_all previous_list) );
    my @other_attr = ($self->{type} eq 'tlg') ? keys %list_labels : ();
    my %valid = map {$_ => 1} (@universal, @other_attr);
    my $valid = sub 
    {
        my $key = shift;
        $key =~ s/-?(\w+)/\L$1/;
        return $key if exists $valid{$key};
        die ("I did not understand the parameter: $key\n");
    };
    $args{ $valid->($_) } = $passed{$_} foreach keys %passed;
    
    if ($args{'select_all'}) 
    {
        undef $self->{req_authors};
        undef $self->{req_auth_wk};
        undef $self->{filtered};
        undef @ARGV;
        return $auths{$self->{type}};
    }
    
    $self->{filtered} = 1;
    foreach my $k (keys %args) 
    {
        print STDERR "$k: $args{$k}\n" if $self->{debug};
        if ($k eq 'criteria') 
        {
            # do nothing
        }
        elsif ($k eq 'author_regex') 
        {
            $req_authors{ $_ }++ foreach
                keys %{ $self->match_authtab($args{$k}) };
        }                
        elsif ($k eq 'date') 
        {
            my ($start_date, $end_date, $var_flag, $incert_flag) = @{ $args{$k} };
            my ($start, $end, $varia, $incertum);
            my $n = 0;
            foreach (@{ $list_labels{date} })
            {
                $start = $n if $_ eq $start_date;
                $end = $n if $_ eq $end_date;
                $varia = $n if $_ =~ /vari/i;
                # Note the space at the end of Incertum
                $incertum = $n if $_ =~ /incert/i;
                $n++;
            }
            $start = 0 if $start_date =~ /--/;
            $end = length @{ $list_labels{date} } - 1 if $end_date =~ /--/;
            my @dates = ($start .. $end);
            push @dates, $varia if $var_flag;
            push @dates, $incertum if $incert_flag;
            
            foreach my $date (@{ $list_labels{date} }[@dates]) 
            {
                $req_authors{$_}++ foreach @{ $lists{'date'}{$date} };
            }
        }
        
        elsif ($k eq 'author_nums') 
        {
            if (ref $args{$k} eq 'ARRAY')
            {
                foreach my $a (@{ $args{$k} }) 
                {
                    my $auth = sprintf '%04d', $a;
                    $req_authors{$auth}++ ;
                }
            }
            elsif (ref $args{$k} eq 'HASH')
            {
                foreach my $a (keys %{ $args{$k} })
                {
                    my $auth = sprintf '%04d', $a;
                    $req_authors{$auth}++, next unless ref $args{$k}{$a};
                    $self->{check_word_stats} = 1;
                    foreach my $w (@{ $args{$k}{$a} })
                    {
                        my $work = sprintf '%03d', $w;
                        $req_auth_wk{$auth}{$work}++;
                    }
                }
            }
            else { die 'Error on parsing author_nums parameter' }
        }
        
        elsif ($k eq 'previous_list') 
        {
            die "You asked for a subset of the previous list, ".
                "but I have no record of such." unless $self->{prev_list};
            
            my ($au, $wk);
            foreach my $index (@{ $args{$k} }) 
            {
                die "You seem to have pointed to a non-extant ".
                    "member of the previous list" unless $self->{prev_list}[$index];
                if (ref $self->{prev_list}[$index]) 
                {
                    $self->{check_word_stats} = 1;
                    ($au, $wk) = @{ $self->{prev_list}[$index] };
                    $req_auth_wk{$au}{$wk}++;
                }
                else
                {
                    $au = $self->{prev_list}[$index];
                    $req_authors{$au}++;    
                }
            }
            delete $self->{prev_list};
        }

        else 
        {
            undef %req_au;
            undef %req_a_w;
            foreach my $x (map $lists{$k}{$_},  @{ $args{$k} }) 
            {
                if (ref $x eq 'ARRAY') 
                {
                    $req_au{$_}++ foreach @{ $x };
                }
                elsif (ref $x eq 'HASH')
                {
                    $self->{check_word_stats} = 1;
                    foreach my $au (keys %{ $x }) 
                    {
                        $req_a_w{$au}{$_}++ foreach @{ $x->{$au} };
                    }
                }
                else {  die "Error parsing argument $k => (". 
                            (join ', ', @{ $args{$k} }) .")"; }
            }
            
            # Eliminate duplicate hits on same author or work as selected via
            # different values of the same criterion
            $req_authors{$_}++ foreach keys %req_au;
            foreach my $au (keys %req_a_w) 
            {
                $req_auth_wk{$au}{$_}++ foreach keys %{ $req_a_w{$au} };
            }
        }
    }       
    
    # This makes `or' rather than `and' the default.  Better?
    $args{'criteria'} = 1 unless exists $args{'criteria'};
    $args{'criteria'} = ((keys %args) - 1) if 
        $args{'criteria'} =~ m/all/i; #the 1 is 'criteria' itself
    $args{'criteria'} = 1 if $args{'criteria'} =~ m/any/i;
    print STDERR "Criteria: ", $args{criteria}, "\n" if $self->{debug};
    
    # Eliminate auths & works that don't meet enough criteria
    undef $self->{req_auth_wk};
    undef $self->{req_authors};
    foreach (keys %req_authors) 
    {
        $self->{req_authors}{$_}++ if $req_authors{$_} >= $args{'criteria'};
    }               
    foreach my $au (keys %req_auth_wk) 
    {
        next if $self->{req_authors}{$au}; # already added to the list
        foreach my $wk ( keys %{ $req_auth_wk{$au} } ) 
        {
            local $^W;
            $self->{req_auth_wk}{$au}{$wk}++ if 
                ((0 + $req_authors{$au}) + (0 + $req_auth_wk{$au}{$wk}) 
                 >= $args{'criteria'});
        }
    }
    print STDERR Data::Dumper->Dump ([\$self->{req_authors}, \$self->{req_auth_wk}], 
                                     ['req_authors', 'req_auth_wk']) if $self->{debug};

    # NB. This is where we set up searches restricted by author.
    # Searches restricted by author/work are handled in Search.pm.  If
    # you mix both types of restriction (which the GUI does not
    # allow), the searches will be separate and sequential, which may
    # look odd from a chronological point of view.  So don't do that.

    @ARGV = ();
    # Only put into @ARGV those files we want to search in their entirety!
    if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
        # Do chronological sort of authors for TLG
        foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
            my $short_num = $num;
            $short_num =~ s/^0+//g;
            if (exists $self->{req_authors}{$num} or exists $self->{req_authors}{$short_num}) {
                push @ARGV, $self->{tlg_file_prefix} . (sprintf '%04d', $num) . $self->{txt_suffix};
            }
        }
    }
    else {
        foreach my $au (keys %{ $self->{req_authors} }) {
            $file = $self->{file_prefix} . (sprintf '%04d', $au) . $self->{txt_suffix};
            push @ARGV, $file;
        }
    }

    # print "\nusing \@ARGV: ", Data::Dumper->Dump ([\@ARGV], ['*ARGV']);
    warn "There were no texts matching your criteria" unless 
        @ARGV or $self->{req_auth_wk};
    
    return unless wantarray;
    
    # return auth & work names
    my ($basename, @ret);
    my $index = 0;
    my @ordered_authors = ();
    if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
        foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
            if (exists $self->{req_authors}{$num}) {
                push @ordered_authors, $num;
            }
        }
    }
    else {
        @ordered_authors = sort numerically keys %{ $self->{req_authors} };
    }

    foreach my $auth (@ordered_authors)
    {
        my $formatted_auth = $auths{$self->{type}}{$auth};
        $self->format_output(\$formatted_auth, 'l');
        push @ret, $formatted_auth;
        $self->{prev_list}[$index++] = $auth;
    }

    @ordered_authors = ();
    if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
        foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
            if (exists $self->{req_auth_wk}{$num}) {
                push @ordered_authors, $num;
            }
        }
    }
    else {
        @ordered_authors = sort numerically keys %{ $self->{req_auth_wk} };
    }

    foreach my $auth (@ordered_authors)
    {
        $basename = $auths{$self->{type}}{$auth};
        $self->format_output(\$basename, 'l');
        my $real_num = $self->parse_idt($auth);
        foreach my $work ( sort numerically keys %{ $self->{req_auth_wk}{$auth} } ) 
        {
            my $wk_name = $work{$self->{type}}{$real_num}{$work};
            $self->format_output(\$wk_name, 'l');
            push @ret, "$basename: $wk_name";
            $self->{prev_list}[$index++] = [$auth, $work];
        }
    }
    return @ret;
}
#+end_src
*** Initialisierung und Variablen
#+begin_src perl
  my $self = shift;
  my %passed = @_;
  my (%args, %req_authors, %req_a_w, %req_au, %req_auth_wk);
  my ($file, $baseline);
#+end_src

u/*** Die Hashes %list_labels und %lists werden gefüllt
Wenn %list_labels leer ist, wird dieser Hash aus den entsprechenden
Dateien gefüllt.

#+begin_src perl
    $self->parse_lists if $self->{type} eq 'tlg' and not %list_labels;
#+end_src

Die Schlüssel dieses Hash sind:
- genre
- genre_clx
- date
- epithet
- gender
- location

Unter diesen Schlüsseln befindet sich jeweils ein Array mit den
passenden Labeln: [[file:lib/Diogenes/Base.pm::1236]]
#+begin_src perl
  push @{ $list_labels{$type} }, $label;
#+end_src

Die Autornummern dagegen werden im Hash %labels unter den
Schlüsselwörtern $type und $label abgelegt:
[[file:lib/Diogenes/Base.pm::1249]]
#+begin_src perl
  push @{ $lists{$type}{$label} }, $auth_num;
#+end_src

Unter $auth_num wiederum wird die Liste der Werke abgelegt:
[[file:lib/Diogenes/Base.pm::1294]]
#+begin_src perl
  push @{ $lists{$type}{$label}{$auth_num} }, 
    map {sprintf '%03d', $_ } @works;
#+end_src

*** Ein Aufruf ohne Parameter gibt alle Autoren zurück
#+begin_src perl
      return $auths{$self->{type}} if (! %passed);
#+end_src

*** Ein Aufruf mit get_tlg_categories gibt eine Referenz auf %list_labels zurück
#+begin_src perl
    # This is how we get the categories into which the TLG authors are divided
    die "Only the TLG categorizes text by genre, date, etc.\n" 
        if $passed{'get_tlg_categories'} and $self->{type} ne 'tlg';
    return \%list_labels if $passed{'get_tlg_categories'};
#+end_src

*** Validierung der Übergabeparameter
Die Übergabeparameter müssen in @universal oder keys %list_labels
enthalten sein.
#+begin_src perl
      my @universal = (qw(criteria author_regex author_nums select_all previous_list) );
      my @other_attr = ($self->{type} eq 'tlg') ? keys %list_labels : ();
      my %valid = map {$_ => 1} (@universal, @other_attr);
      my $valid = sub 
      {
	  my $key = shift;
	  $key =~ s/-?(\w+)/\L$1/;
	  return $key if exists $valid{$key};
	  die ("I did not understand the parameter: $key\n");
      };
      $args{ $valid->($_) } = $passed{$_} foreach keys %passed;
#+end_src

*** -select_all
select_all mit egal welchem Wert setzt @ARGV sowie req_authors,
req_auth_wk und filtered auf undef und gibt schließlich alle Autoren
zurück, die zum aktuellen type (TLG, PHI, usw.) passen.
#+begin_src perl
      if ($args{'select_all'}) 
      {
	  undef $self->{req_authors};
	  undef $self->{req_auth_wk};
	  undef $self->{filtered};
	  undef @ARGV;
	  return $auths{$self->{type}};
      }
#+end_src

*** TODO Verarbeitung der übergebenen Argumente
Hier werden die übergebenen Argumente verarbeitet. Die möglichen
Schlüsselbegriffe sind:
**** criteria (wird später verarbeitet?)
**** author_regex      return @ret;
Die Autoren werden als ein großer String an match_authtab übergeben,
wobei die einzelnen regulären Ausdrücke durch Spatien oder Kommata
getrennt sind. Hierbei gibt es getrennte Routinen für alphabetische
und numerische Muster: Alphabetische Muster werden so belassen,
numerische in das vierstellige Format %04d übersetzt. Beide Arten von
Mustern werden dann im Hash $auths{$self->{type}} nachgeschlagen, und
aus dem Muster und dem Ergebnis wird der Hash %match angelegt.

***** filtered
Zunächst wird $self->filtered auf 1 gesetzt.
#+begin_src perl
      $self->{filtered} = 1;
#+end_src

***** Beginn der Schleife
#+begin_src perl
  foreach my $k (keys %args) 
  {
      print STDERR "$k: $args{$k}\n" if $self->{debug};
#+end_src

***** criteria
criteria wird erst im nächsten Schritt behandelt
#+begin_src perl
	  if ($k eq 'criteria') 
	  {
	      # do nothing
	  }
#+end_src

***** author_regex
#+begin_src perl
  elsif ($k eq 'author_regex') 
  {
      $req_authors{ $_ }++ foreach
	  keys %{ $self->match_authtab($args{$k}) };
  }
#+end_src

***** date
#+begin_src perl
  elsif ($k eq 'date') 
  {
      my ($start_date, $end_date, $var_flag, $incert_flag) = @{ $args{$k} };
      my ($start, $end, $varia, $incertum);
      my $n = 0;
      foreach (@{ $list_labels{date} })
      {
	  $start = $n if $_ eq $start_date;
	  $end = $n if $_ eq $end_date;
	  $varia = $n if $_ =~ /vari/i;
	  # Note the space at the end of Incertum
	  $incertum = $n if $_ =~ /incert/i;
	  $n++;
      }
      $start = 0 if $start_date =~ /--/;
      $end = length @{ $list_labels{date} } - 1 if $end_date =~ /--/;
      my @dates = ($start .. $end);
      push @dates, $varia if $var_flag;
      push @dates, $incertum if $incert_flag;

      foreach my $date (@{ $list_labels{date} }[@dates]) 
      {
	  $req_authors{$_}++ foreach @{ $lists{'date'}{$date} };
      }
  }
#+end_src

***** author_nums
#+begin_src perl	 
  elsif ($k eq 'author_nums') 
    {
	if (ref $args{$k} eq 'ARRAY')
	{
	    foreach my $a (@{ $args{$k} }) 
	    {
		my $auth = sprintf '%04d', $a;
		$req_authors{$auth}++ ;
	    }
	}
	elsif (ref $args{$k} eq 'HASH')
	{
	    foreach my $a (keys %{ $args{$k} })
	    {
		my $auth = sprintf '%04d', $a;
		$req_authors{$auth}++, next unless ref $args{$k}{$a};
		$self->{check_word_stats} = 1;
		foreach my $w (@{ $args{$k}{$a} })
		{
		    my $work = sprintf '%03d', $w;
		    $req_auth_wk{$auth}{$work}++;
		}
	    }
	}
	else { die 'Error on parsing author_nums parameter' }
    }
#+end_src

***** previous_list
#+begin_src perl
	  elsif ($k eq 'previous_list') 
	  {
	      die "You asked for a subset of the previous list, ".
		  "but I have no record of such." unless $self->{prev_list};

	      my ($au, $wk);
	      foreach my $index (@{ $args{$k} }) 
	      {
		  die "You seem to have pointed to a non-extant ".
		      "member of the previous list" unless $self->{prev_list}[$index];
		  if (ref $self->{prev_list}[$index]) 
		  {
		      $self->{check_word_stats} = 1;
		      ($au, $wk) = @{ $self->{prev_list}[$index] };
		      $req_auth_wk{$au}{$wk}++;
		  }
		  else
		  {
		      $au = $self->{prev_list}[$index];
		      $req_authors{$au}++;    
		  }
	      }
	      delete $self->{prev_list};
	  }
#+end_src

***** TODO else
Wenn die Schlüsselwörter mit keinem der vorangegangenen Begriffe
übereinstimmt, wird der Begriff als Schlüsselbegriff von %lists
behandelt: siehe [[*Die Hashes %list_labels und %lists werden gefüllt][hier.]]

#+begin_src perl
    else 
    {
	undef %req_au;
	undef %req_a_w;
	foreach my $x (map $lists{$k}{$_},  @{ $args{$k} }) 
	{
	    if (ref $x eq 'ARRAY') 
	    {
		$req_au{$_}++ foreach @{ $x };
	    }
	    elsif (ref $x eq 'HASH')
	    {
		$self->{check_word_stats} = 1;
		foreach my $au (keys %{ $x }) 
		{
		    $req_a_w{$au}{$_}++ foreach @{ $x->{$au} };
		}
	    }
	    else {  die "Error parsing argument $k => (". 
			(join ', ', @{ $args{$k} }) .")"; }
	}

	# Eliminate duplicate hits on same author or work as selected via
	# different values of the same criterion
	$req_authors{$_}++ foreach keys %req_au;
	foreach my $au (keys %req_a_w) 
	{
	    $req_auth_wk{$au}{$_}++ foreach keys %{ $req_a_w{$au} }
	}
    }
  }
#+end_src
 
*** TODO critera
Criteria ist die Anzahl der Bedigungen, die erfüllt sein müssen, dass
ein Autor resp. Werk in $self->required_authors aufgenommen wird (?).
#+begin_src perl
        # This makes `or' rather than `and' the default.  Better?
      $args{'criteria'} = 1 unless exists $args{'criteria'};
      $args{'criteria'} = ((keys %args) - 1) if 
	  $args{'criteria'} =~ m/all/i; #the 1 is 'criteria' itself
      $args{'criteria'} = 1 if $args{'criteria'} =~ m/any/i;
      print STDERR "Criteria: ", $args{criteria}, "\n" if $self->{debug};
#+end_src

*** TODO req_auth und req_auth_wk
#+begin_src perl
        # Eliminate auths & works that don't meet enough criteria
      undef $self->{req_auth_wk};
      undef $self->{req_authors};
      foreach (keys %req_authors) 
      {
	  $self->{req_authors}{$_}++ if $req_authors{$_} >= $args{'criteria'};
      }               
      foreach my $au (keys %req_auth_wk) 
      {
	  next if $self->{req_authors}{$au}; # already added to the list
	  foreach my $wk ( keys %{ $req_auth_wk{$au} } ) 
	  {
	      local $^W;
	      $self->{req_auth_wk}{$au}{$wk}++ if 
		  ((0 + $req_authors{$au}) + (0 + $req_auth_wk{$au}{$wk}) 
		   >= $args{'criteria'});
	  }
      }
      print STDERR Data::Dumper->Dump ([\$self->{req_authors}, \$self->{req_auth_wk}], 
				       ['req_authors', 'req_auth_wk']) if $self->{debug};
#+end_src

*** TODO Beschränkung auf die gewählten Autoren

#+begin_src perl
       # NB. This is where we set up searches restricted by author.
      # Searches restricted by author/work are handled in Search.pm.  If
      # you mix both types of restriction (which the GUI does not
      # allow), the searches will be separate and sequential, which may
      # look odd from a chronological point of view.  So don't do that.

      @ARGV = ();
      # Only put into @ARGV those files we want to search in their entirety!
      if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
	  # Do chronological sort of authors for TLG
	  foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
	      my $short_num = $num;
	      $short_num =~ s/^0+//g;
	      if (exists $self->{req_authors}{$num} or exists $self->{req_authors}{$short_num}) {
		  push @ARGV, $self->{tlg_file_prefix} . (sprintf '%04d', $num) . $self->{txt_suffix};
	      }
	  }
      }
      else {
	  foreach my $au (keys %{ $self->{req_authors} }) {
	      $file = $self->{file_prefix} . (sprintf '%04d', $au) . $self->{txt_suffix};
	      push @ARGV, $file;
	  }
      }

      # print "\nusing \@ARGV: ", Data::Dumper->Dump ([\@ARGV], ['*ARGV']);
      warn "There were no texts matching your criteria" unless 
	  @ARGV or $self->{req_auth_wk};

      return unless wantarray;
#+end_src

*** Rückgabe der Autoren und Werke
Wird nicht ausgeführt in /void context/.
**** Vollständige Autoren
#+begin_src perl     # return auth & work names
      my ($basename, @ret);
      my $index = 0;
      my @ordered_authors = ();
      if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
	  foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
	      if (exists $self->{req_authors}{$num}) {
		  push @ordered_authors, $num;
	      }
	  }
      }
      else {
	  @ordered_authors = sort numerically keys %{ $self->{req_authors} };
      }

      foreach my $auth (@ordered_authors)
      {
	  my $formatted_auth = $auths{$self->{type}}{$auth};
	  $self->format_output(\$formatted_auth, 'l');
	  push @ret, $formatted_auth;
	  $self->{prev_list}[$index++] = $auth;
      }
#+end_src

**** Einzelwerke
#+begin_src perl
      @ordered_authors = ();
      if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
	  foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
	      if (exists $self->{req_auth_wk}{$num}) {
		  push @ordered_authors, $num;
	      }
	  }
      }
      else {
	  @ordered_authors = sort numerically keys %{ $self->{req_auth_wk} };
      }

      foreach my $auth (@ordered_authors)
      {
	  $basename = $auths{$self->{type}}{$auth};
	  $self->format_output(\$basename, 'l');
	  my $real_num = $self->parse_idt($auth);
	  foreach my $work ( sort numerically keys %{ $self->{req_auth_wk}{$auth} } ) 
	  {
	      my $wk_name = $work{$self->{type}}{$real_num}{$work};
	      $self->format_output(\$wk_name, 'l');
	      push @ret, "$basename: $wk_name";
	      $self->{prev_list}[$index++] = [$auth, $work];
	  }
      }
#+end_src

**** Rückgabe
#+begin_src perl
        return @ret;
#+end_src
** do_format
do_format arbeitet mit $self->{input_source}, was eine Referenz auf
die auszugebende Datenstruktur darstellen soll. Die Arbeit macht
format_output.
#+begin_src perl
sub do_format
{
    my $self = shift;
    $self->begin_boilerplate;
    
    die "You must specify an input_source for do_format!\n" unless $self->{input_source};
    die "input_source should be a reference!\n" unless ref $self->{input_source};
    my $input = $self->{input_source};
    my $ref = ref $input;
    my $inp;
    if ($ref eq 'SCALAR')
    {
        $inp = $input;
        $self->format_output(\$inp);
        print $inp;
    }
    elsif ($ref eq 'ARRAY')
    {
        for (@{$input})
        {
            my $inp = $_;
            $self->format_output(\$inp);
            print $inp;
        }
    }
    elsif ($ref eq 'CODE')
    {
        while ($input->())
        {
            my $inp = $_;
            $self->format_output(\$inp);
            print $inp;
        }
    }
    else
    {
        local $/ =  "\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
        my $holder = $self->{latex_counter};
        $self->{latex_counter} = 0;
        while (<$input>)
        {
            my $inp = $_;
            $self->format_output(\$inp);
            print $inp;
        }
        $self->{latex_counter} = $holder;
    }
    
    $self->end_boilerplate;
    
}
#+end_src

** get_encodings
Einfacher Getter für die Schlüsselbegriffe von %encoding
#+begin_src perl
sub get_encodings
{
    return sort keys %encoding;
}
#+end_src

** encode_greek
Zwei Argumente: $enc und $ref. Führt eine Enkodierung von $ref mit der
Enkodierung $enc durch und stellt daraufhin $enc wieder her. Benutzt
[[*set_handlers][set_handlers]] und greek_with_latin
#+begin_src perl
sub encode_greek
{
    my ($self, $enc, $ref) = @_;
    my $old_encoding = $self->{encoding};
    $self->{encoding} = $enc;
    $self->set_handlers;
    $self->greek_with_latin($ref);
    $$ref =~ s/\x03\x01/"/g;
    $$ref =~ s/\x03\x02/%/g;
    $$ref =~ s/\x03\x03/_/g;
    $self->{encoding} = $old_encoding;
    $self->set_handlers;
}
#+end_src

** TODO parse_lists
Parse list3cla.bin, etc. for genre, date, etc. info. Only useful for
tlg searches.

#+begin_src perl
  sub parse_lists 
{
    my $self = shift;
    my @tlg_class_files = 
        ( qw(list3cla.bin list3clx.bin list3dat.bin list3epi.bin 
             list3fem.bin list3geo.bin) );
    my @tlg_classifications = 
        ( qw(genre genre_clx date epithet gender location) );
    if ($self->{uppercase_files}) 
    {
        @tlg_class_files = map {uc($_)} @tlg_class_files ;
    }
    
    my ($base_ptr, $ptr, $label, $j, $ord, $auth_num, @works, $old);
    my ($type, $high);
    my $d = 0;
    foreach my $file (@tlg_class_files) 
    {
        $type = shift @tlg_classifications;
        
        open BIN, "<$self->{cdrom_dir}$file" or die ("couldn't open $file: $!");
        binmode BIN;
        local $/;
        undef $/;
        
        my $buf = <BIN>;
        
        $base_ptr = unpack 'N', substr ($buf, 0, 4);
        my $i = 4;
        
        while ($i <= length $buf) 
        {
            $ptr = $base_ptr + unpack 'N', substr ($buf, $i, 4);
            $i += 4;
            
            last if ord (substr ($buf, $i, 1)) == 0;
            
            $label = Diogenes::Base::get_pascal_string(\$buf, \$i);       
            $self->beta_formatting_to_ascii(\$label, 'l') if $type eq 'date';
            $i++;
            push @{ $list_labels{$type} }, $label;
            $j = $ptr;
            $ord = ord (substr ($buf, $j, 1));
            
            until ($ord == 0) 
            {
                $auth_num = (unpack 'n', substr ($buf, $j, 2)) & hex '7fff';
                $auth_num = sprintf '%04d', $auth_num;
                $j += 2;
                $ord = ord (substr ($buf, $j, 1));
                
                if ( ($ord & hex '80') or ($ord == 0) ) 
                {
                    push @{ $lists{$type}{$label} }, $auth_num;
                    next;
                }
                @works = ();
                $old = 0;       
                until ( ($ord & hex '80') or ($ord == 0) ) 
                {
                    if ( $ord < hex '20' ) 
                    {
                        push @works, $ord;
                        $old = $ord;
                    }
                    elsif ( $ord == hex '20' ) 
                    {
                        warn("Ooops while parsing $file at $j") if $ord & hex '20';
                    }
                    elsif ( $ord < hex '40' ) 
                    {
                        push @works, (($old + 1) .. ($old + ($ord & hex '1f')));
                        $old = 0;
                    }
                    elsif ( $ord < hex '60' ) 
                    {
                        warn("Ooops while parsing $file at $j\n") if $ord & hex '20';
                        $high = ($ord & hex '01') << 8; 
                        $j++;
                        $ord = ord (substr ($buf, $j, 1));
                        $old = $high + $ord;
                        push @works, $old;
                    }
                    elsif ( $ord == hex '60' ) 
                    {
                        $j++;
                        $ord = ord (substr ($buf, $j, 1));
                        push @works, (($old + 1) .. ($ord + 1));
                    }
                    else 
                    {
                        warn("Oops while parsing $file at $j");
                    }
                    
                    $j++;
                    $ord = ord (substr ($buf, $j, 1));
                }
                push @{ $lists{$type}{$label}{$auth_num} }, 
                map {sprintf '%03d', $_ } @works;
            }
        }
        close BIN;
    }
}

#+end_src

** TODO parse_authtab
Parse the author names in authtab.dir and store the matches as a
reference to a hash keyed by author numbers. Also determines the
fundamental language of each text file.

#+begin_src perl
  sub parse_authtab 
{
    my $self = shift;
    my $prefix = "\U$self->{file_prefix}\E";
    my (%authtab_entry, $file_num, $base_lang);
    
    # Maybe CD-Rom is not mounted yet
    return undef unless -e $self->{cdrom_dir}.$self->{authtab};
    
    open AUTHTAB, $self->{cdrom_dir}.$self->{authtab} or 
        $self->barf("Couldn't open $self->{cdrom_dir}$self->{authtab}");
    binmode AUTHTAB;
    local $/ = "\xff";
    
    my $regexp = qr!$prefix(\w\w\w\d)\s+([\x01-\x7f]*[a-zA-Z][^\x83\xff]*)!;
    
    while (my $entry = <AUTHTAB>)
    {
        # get new base language if this is a new prefix group: e.g. *CIV.
        $base_lang = $1 if $entry =~ m/^\*$prefix[^\x83]*\x83(\w)\xff/;
        # English uses the Latin alphabet, or so I've heard.
        # Don't know what to do with Hebrew yet.
        $base_lang = 'l' if defined $base_lang and ($base_lang eq 'e'
                                                    or $base_lang eq 'h');
        
        # get auth num and name
        my ($file_num, $name) = $entry =~ $regexp;
        next unless defined $file_num;
        $file_num =~ tr/A-Z/a-z/; # doccanx.txt
        # Get rid of non-ascii stuff
        $name =~ s#[\x80-\xff]+# #g;
        #$self->format_output (\$name, 'l'); #no, no here, takes too much time
        
        $authtab_entry{$file_num} = $name; 
        
        # get deviant lang, if any, of this particular entry 
        my ($lang) = $entry =~ m/\x83(\w)/;
        $lang = 'l' if defined $lang and ($lang eq 'e' or $lang eq 'h');
        $lang{$self->{type}}{$file_num} = (defined $lang) ? $lang : $base_lang;
    }
    if (keys %authtab_entry == 0 and $self->{type} ne 'bib')
    {
        warn "No matching files found in authtab.dir: \n",
        "Is $prefix the correct file prefix for this database?\n";
        return undef;
    }
    close AUTHTAB;
#     print STDERR %authtab_entry if $self->{debug};
    #print STDERR Dumper $lang if $self->{debug};
    
    $auths{$self->{type}} = \%authtab_entry;
    return 1;
}
#+end_src

** TODO match_authtab
Extract a given pattern from the authtab info read in above

#+begin_src perl
  sub match_authtab
{
    my $self = shift;
    my $big_pattern = shift;
    utf8_to_beta_encoding(\$big_pattern);
    $big_pattern ||= '.';            # Avoid warnings on null pattern
    my %total = ();
    my %match;
    $self->parse_authtab unless $auths{$self->{type}};
    die "Unable to get author info from the authtab.dir file!\n" unless 
        $auths{$self->{type}};

    for my $pattern (split /[\s,]+/, $big_pattern)
    {
        print STDERR "pattern: $pattern\n" if $self->{debug};

        if ($pattern =~ /\D/)
        {       # Search values (auth names)
            %match = map { $_ => $auths{$self->{type}}{$_} }
            grep $auths{$self->{type}}{$_} =~ /$pattern/i,
            keys %{ $auths{$self->{type}} };
        }
        elsif ($pattern =~ /\d+/)
        {       # Search keys (auth nums)
            $pattern = sprintf '%04d', $pattern; 
            %match = map { $_ => $auths{$self->{type}}{$_} }
            grep /$pattern/, keys %{ $auths{$self->{type}} };
        }
        (%total) = (%total, %match);
    }
    # Strip formatting
    $self->format_output(\$total{$_}, 'l') for keys %total;
    return \%total;
}
#+end_src

** TODO parse_idt
Method to extract the author, work and label info from an idt file 
-- the info goes into globals %author, %work and %level_label,     
keyed by type of search -- may be reused in subsequent searches.   

#+begin_src perl
  sub parse_idt 
{
    my ($self, $au_num) = @_;
    my ($lev, $str, $auth_num, $author_name, $work_num, $work_name, $old_work_num);
    my ($sub_work_abbr, $sub_work_name, $code, $desc_lev, $start_block, $first_byte);
    my ($subsection, $current_block, $block);
    $current_block = 0;
    
    $self->{current_lang} = $lang{$self->{type}}{$au_num};
    $self->{current_lang} = 'l' if $self->{type} eq 'bib';
    $self->{current_lang} = 'g' if $self->{type} eq 'cop';
    
    # Don't read again (except for CIV texts, where $au_num is not a number)
    return $au_num if exists $author{$self->{type}}{$au_num}; 
    
    # This file must be read via unbuffered system I/O if it is to be interwoven
    # between successive reads of .txt files from <ARGV>.  Otherwise this flushes 
    # the .txt files out of the I/O cache and hugely increases search times.
    
    # We therefore do not want to overwrite buf, which may now contain the
    # contents of the corresponding .txt file, so we use idt_buf
    # instead.
    my $file = $self->{file_prefix} . $au_num . $self->{idt_suffix};
    my $i; 
    my $idt_buf = '';
    
    sysopen IDT, $self->{cdrom_dir}.$file, 0 or 
        $self->barf("Could not open $self->{cdrom_dir}$file - $!");
    binmode IDT;
    
    while (my $len = sysread IDT, $idt_buf, 8192, length $idt_buf) 
    {
        if (!defined $len) 
        {
            next if $! =~ /^Interrupted/;
            $self->barf ("System read error on $self->{cdrom_dir}.$file: $!\n");
        }
    }
    my $end = length $idt_buf;
    close IDT or $self->barf("Could not close $file");
    
    undef $old_work_num;
    for ($i = 0; ($i < $end); $i++) 
    {
        $code = ord (substr ($idt_buf, $i, 1));
        
        last if ($code == 0);           # eof
        
        if ($code == 1 or $code == 2) 
        {       # new author or work
            $subsection = 0;
            undef %{ $self->{level} };
            $i += 2;
            $first_byte = ord (substr $idt_buf, ++$i, 1) << 8;
            $start_block = $first_byte + ord (substr $idt_buf, ++$i, 1);
            
            if (ord (substr ($idt_buf, ++$i, 1)) == hex ("ef")) 
            {
                $lev = (ord (substr ($idt_buf, ++$i, 1))) & MASK;
                $str = get_ascii_string( \$idt_buf, \$i );
                if ($lev == 0) 
                {
                    $auth_num = $str;
                    $last_work{$self->{type}}{$auth_num} = 0;
                    # The misc files (CIV000x on the LAT disk) have an
                    # alphabetic string here, rather than the number, so now
                    # be careful not to assume that $auth_num is a number.
                    if ((ord (substr ($idt_buf, ++$i, 1)) == hex ("10")) &&
                        ((ord (substr ($idt_buf, ++$i, 1))) == hex ("00"))) 
                    {
                        $i++;
                        $author_name = get_pascal_string( \$idt_buf, \$i );
                        $author{$self->{type}}{$auth_num} = $author_name;
                    } 
                    else 
                    { 
                        $self->barf("Author number apparently was not followed by".
                                    " author name in idt file $file");
                    }
                }
                elsif ($lev == 1) 
                {
                    $work_num = $str;
                    $last_work{$self->{type}}{$auth_num} = $work_num 
                        if $work_num > $last_work{$self->{type}}{$auth_num};
                    if      ((ord (substr ($idt_buf, ++$i, 1))  == hex ("10")) &&
                             ((ord (substr ($idt_buf, ++$i, 1))) == hex ("01"))) 
                    {
                        $i++;
                        $work_name = get_pascal_string( \$idt_buf, \$i );
                        $work{$self->{type}}{$auth_num}{$work_num} = $work_name; 
                        
                        $work_start_block{$self->{type}}
                        {$auth_num}{$work_num} = $start_block;
                        
                        # Get the level labels
                        if ($self->{type} eq 'misc' and defined $old_work_num)
                        {
                            # For CIV texts, only level labels that change are listed
                            # explicitly, so we must preinitialize them.
                            $level_label{$self->{type}}
                            {$auth_num}{$work_num} =
                            { % {$level_label{$self->{type}}
                                 {$auth_num}{$old_work_num}} };
                        }
                        while (ord (substr ($idt_buf, ++$i, 1)) == hex("11")) 
                        {
                            $desc_lev = ord (substr ($idt_buf, ++$i, 1));
                            $i++;
                            $level_label{$self->{type}}
                            {$auth_num}{$work_num}{$desc_lev} =
                                get_pascal_string( \$idt_buf, \$i ); 
                        }
                        $i--;           # went one byte too far
                        $old_work_num = $work_num;
                    } 
                    else 
                    { 
                        $self->barf("Work number apparently was not followed by work 
                                                name in idt file $file")
                    }
                    
                    if ($self->{documentary})
                    {
                        $level_label{$self->{type}}
                        {$auth_num}{$work_num}{5} =
                            delete $level_label{$self->{type}}
                        {$auth_num}{$work_num}{0};
                    }
                } 
                elsif ($lev == 2) 
                {       # Trap this for now
                    $self->barf ("Hey! I found a sub-work level in idt file $file");
                    
                    # The real code should look something like this:        
                    $sub_work_abbr = $str;
                    if (ord (substr ($idt_buf, ++$i, 2)) == hex '1002') 
                    {
                        $i++;
                        $sub_work_name = get_pascal_string( \$idt_buf, \$i );
                        $sub_works{$self->{type}}{$auth_num}{$work_num}{$sub_work_abbr} = $sub_work_name; 
                    } 
                    else 
                    { 
                        $self->barf(
                            "Sub-work number apparently was not followed by sub-work name in idt file $file")
                    }
                }
                else 
                {
                    $self->barf (
                        "I don't understand level $lev after \0xef in idt file $file.")
                }
            }
            else 
            {
                $self->barf ("I see a new author or a new work in ".
                             "idt file $file, but it is not followed after 5 ".
                             "bytes by \\0xef.");
            }
        } 
        elsif ($code == 3)
        {
            # Get the starting blocks of each top-level subsection    
            $block = (ord (substr $idt_buf, ++$i, 1) << 8) + ord (substr $idt_buf, ++$i, 1);
            warn("Error.  New section not followed by beginning ID")
                unless ord (substr $idt_buf, ++$i, 1) == 8;
            $i++;
            while ((my $sub_code = ord (substr ($idt_buf, $i, 1))) >> 7)
            {
                parse_bookmark($self, \$idt_buf, \$i, $sub_code);
                $i++;
            }
            $i--;           # went one byte too far
            my $top_level = (sort {$b <=> $a} keys %{ $self->{level} })[0];
            $top_levels{$self->{type}}{$auth_num}{$work_num}[$subsection] = 
                [$self->{level}{$top_level}, $block];
            $subsection++;
            
            # NB. This resynchronization is necessary for the TLG, not the PHI
            $current_block = $block;
        }
        elsif ($code == 10)
        {
            $i++;
            while ((my $sub_code = ord (substr ($idt_buf, $i, 1))) >> 7)
            {
                parse_bookmark($self, \$idt_buf, \$i, $sub_code);
                $i++;
            }
            $i--;           # went one byte too far
            $last_citation{$self->{type}}{$auth_num}{$work_num}{$current_block} 
            = {%{ $self->{level} }};
            $current_block++;
        }
        elsif ($code == 11 or $code == 13) 
        {   # "Exceptions" -- which we ignore
            $i += 2;
        }
        
        # do nothing in the other cases
        
    } # end of for loop
    
#       use Data::Dumper;
#       print Dumper $top_levels{$self->{type}}{$auth_num};
#       print Dumper $last_citation{$self->{type}}{$auth_num};
#       print "$auth_num => $current_block \n"
#        if ($current_block +1 << 13) != -s "$self->{cdrom_dir}$self->{file_prefix}$auth_num.txt";
    return $auth_num;
}
#+end_src

** get_ascii_string
Subroutine to get a string from $$buf until a \xff is hit,       
starting at $i.                                                  

#+begin_src perl
  sub get_ascii_string 
{
    my ($buf, $i) = @_;
    my $char;
    my $string = "";
    until ((ord ($char = substr ($$buf, ++$$i, 1))) == hex("ff") or $$i > length $$buf)
    {
        $string .= chr ((ord $char) & MASK);
    }
    return $string
}
#+end_src

** get_pascal_string 
Subroutine to extract pascal-style strings with the         
length byte first (used for list.bin files).             

#+begin_src perl
sub get_pascal_string 
{
    my ($buf, $i) = @_;
    my $str = "";
    my $len = ord (substr ($$buf, $$i, 1));
    for ($$i++; $len > 0; $$i++, $len--) 
    {
        $str .= chr (ord (substr ($$buf, $$i, 1)));
    }
    $$i--;  # went one byte too far
    return $str;
}
#+end_src

** Bibliographien
*** read_tlg_biblio
#+begin_src perl
sub read_tlg_biblio
{
    # Only reads in file, too massive to parse now
    my $self = shift;
    $self->{print_bib_info} = 1;
    return if $bibliography;
    local $/;
    undef $/;
    my $filename = "$self->{cdrom_dir}doccan2.txt";
    my $Filename = "$self->{cdrom_dir}DOCCAN2.TXT";
    open BIB, $filename or open BIB, $Filename or die "Couldn't open $filename: $!";
    binmode BIB;
    $bibliography = <BIB>;
    close BIB, $filename or die "Couldn't close $filename: $!";
}

#+end_src

*** read_phi_biblio

#+begin_src perl
sub read_phi_biblio
{
    # Read and parses file
    my $self = shift;
    my $filename = "$self->{cdrom_dir}$self->{file_prefix}9999.txt";
    if (-e "$filename")
    {
        local undef $/;
        open PHI_BIB, $filename or die "Couldn't open $filename: $!";
        binmode PHI_BIB;
        my $canon = <PHI_BIB>;
        while ($canon =~ m/([^{]+)\{\`?(\d\d\d\d)\.(\d\d\d)\}/g)
        {
            my ($info, $auth, $work) = ($1, $2, $3);
            $info =~ s/[\x80-\xff][\@\s\x80-\xff]*/\n/g;
            $info =~ s/\n+/\n/g;
            $info =~ s/^[\n\s]+//;
            $info .= ' ('.$auth.': '.$work.')';
            $info .="\n" unless $info =~ m/\n$/;
            $self->{phi_biblio}{$auth}{$work} = $info;
        }
        close PHI_BIB, $filename or die "Couldn't close $filename: $!";
        $self->{print_bib_info} = 1;
    }
    else
    {
        print STDERR "PHI Canon ($filename) not found!" if $self->{debug};
    }
}
#+end_src

*** get_biblio_info
#+begin_src perl
sub get_biblio_info
{
    my ($self, $type, $auth, $work) = @_;
    
    return $self->get_tlg_biblio_info($auth, $work) if $type =~ m/tlg/i;
    if (exists $self->{phi_biblio}{$auth}{$work})
    {
	return $self->{phi_biblio}{$auth}{$work} if $type =~ m/phi/i ;
    }
    return ' ('.$auth.': '.$work.')';
}

#+end_src

*** get_tlg_biblio_info
#+begin_src perl
sub get_tlg_biblio_info
{
    # Looks for a single work, memoizes result
    my ($self, $auth, $work) = @_;
    return undef unless $bibliography;
    return $self->{biblio_details}{$auth}{$work}    
    if exists $self->{biblio_details}{$auth}{$work};
    
    my ($info) = $bibliography =~ 
        m/key $auth $work (.+?)[\x90-\xff]*key/;
     return $work{$self->{type}}{$self->{auth_num}}{$self->{work_num}}
         unless $info;
    my %data;
    my @fields = qw(wrk tit edr pla pub pyr ryr ser pag);
    foreach my $field (@fields)
    {
        while 
            ($info =~ 
             m/[\x80-\x8f]?$field ([\x00-\x7f]*(?:[\x80-\x8f]    [\x00-\x7f]+)*)?\s?[\x80-\x8f]?/g)
            
        {
            my $datum = $1 || '';
            $datum =~ s/\s*$//;                     # trailing spaces
            $datum =~ s/[\x80-\x8f]    //g; # long lines
            $data{$field} .= $data{$field} ? ", $datum" : $datum;
        }
    }
    my $chron = ($self->{tlg_chron_info}) ? $self->{tlg_chron_info}{$self->{auth_num}} : '';
    if ($chron eq 'Varia' or $chron eq 'Incertum') {
        $chron = ' (' . $chron . '), ';
    }
    elsif ($chron) {
        $chron = ' (c. ' . $chron . '), '
    }

    $self->{biblio_details}{$auth}{$work} = 
        join '', (
            "$author{$self->{type}}{$self->{auth_num}}",
            $chron,
            ($data{wrk}) ? "$data{wrk}\&" : '' ,
            ' ('.$self->{auth_num}.': '.$self->{work_num}.')',
            ($data{tit}) ? "\n\"$data{tit}\&\"" : '' ,
            ($data{edr}) ? ", Ed. $data{edr}\&" : '' , 
            ($data{pla}) ? "\n$data{pla}\&" : '' ,
            ($data{pub}) ? ": $data{pub}\&" : '' ,
            ($data{pyr}) ? ", $data{pyr}\&" : '' ,
            ($data{ryr}) ? ", Repr. $data{ryr}\&" : '' ,
            ($data{ser}) ? "; $data{ser}\&" : '' ,
#                       ($data{pag}) ? ", $data{pag}\&" : '',
            '.');
    return $self->{biblio_details}{$auth}{$work};
}
#+end_src

** parse_non_ascii 
Method to get the author and work numbers and to update the     
bookmarks in %level while reading from a .txt file block.       

#+begin_src perl
sub parse_non_ascii 
{
    my ($auth_abbr, $work_abbr, $lev, $str);
    my ($new_auth_num, $new_work_num, $code);
    my ($self, $buf, $i) = @_;
    undef $self->{special_note};
    
    # Parse all of the non-ascii data in this block
    while (($code = ord (substr ($$buf, $$i, 1))) >> 7)
    {
#         printf STDERR "Code: %x \n", $code if $self->{debug};
        # Ok. This is legacy code from when I was trying to understand the
        # file formats.  At some stage this sub should be folded in with 
        # parse_bookmarks, so that level `e' ( = 6 ) is handled just like       
        # the rest.  At the moment this code seems to work, so we'll leave it.
        if ($code == hex 'e0')
        {
            $self->{work_num}++ if ord substr ($$buf, ++$$i, 1) == hex '81';
        }
        elsif ($code > hex 'e0' and $code < hex 'e8')
        {
            $self->{work_num} = $code & RMASK if ord substr ($$buf, ++$$i, 1) == hex '81';
        }
        
        # Do we need at some point to handle e8 < $code < ef ??
        
        elsif ($code == hex 'ef') 
        { 
            $lev = (ord substr ($$buf, ++$$i, 1)) & MASK;
            $str = get_ascii_string( $buf, $i );
            if ($str eq '')
            {       # do nothing
            }
            elsif ($lev == 0) 
            {
                $new_auth_num = $str;
                if ($new_auth_num ne $self->{auth_num}) 
                {
                    undef %{ $self->{level} };
                    $self->{auth_num} = $new_auth_num;
                }
            } 
            elsif ($lev == 1) 
            {
                $new_work_num = $str;
                if ($new_work_num ne $self->{work_num}) 
                {
                    undef %{ $self->{level} };
                    $self->{work_num} = $new_work_num;
                }
                
            } 
            elsif ($lev == 2) 
            {
                $work_abbr = $str;      #  Evidently useless info
            }               
            elsif ($lev == 3) 
            {
                $auth_abbr = $str;      #  Ditto
            }
            elsif ($lev == hex '6c')
            {
                # Papyrus provenance
                
                # There are sometimes non-printable chars in here ...
                # and get rid of &'s, since these never switch back to Greek
                $str =~ s/[\x00-\x1f\x7f]//g;
                $str =~ s/\&\d*//g;
                $self->{special_note} = '';
                $self->{special_note} .= "Loc: $str" if $str;
            }
            elsif ($lev == hex '64')
            {
                # Papyrus date
                $str =~ s/[\x00-\x1f\x7f]//g;
                $str =~ s/\&\d*//g;
                $self->{special_note} .= '; ' if $self->{special_note};
                $self->{special_note} .= "Date: $str" if $str;
            }
            elsif ($lev == hex '74')
            {
                # Papyrus what??
                
                $str =~ s/[\x00-\x1f\x7f]//g;
                $str =~ s/\&\d*//g;
                $self->{special_note} .= " $str" if $str;
            }
            elsif ($lev == hex '72')
            {
                # Papyrus reprintings
                
                $str =~ s/[\x00-\x1f\x7f]//g;
                $str =~ s/\&\d*//g;
                $self->{special_note} .= '; ' if $self->{special_note};
                $self->{special_note} .= "Repr: $str" if $str;
            }
            
            # elsif ($lev == 99) {$self->{special_note} = $str}
            # else die("What is level $lev after 0xef? ($i)")
            # Some newer PHI disks encode additional info here, such as the dates
            # of Cicero's letters.
            
            else 
            {
                # For PHI disks, the info is included in the text itself 
                # on newer disks -- we would like to know
                # what distinguishes source references, from, say, the dates of
                # Cicero's letters.  This must be documented somewhere
                $self->{special_note} .= '; ' if $self->{special_note};
                $self->{special_note} .= $str;
            }
        }
        
        # This "junk" is e.g. the citation codes for Plato!  
        ##elsif ($code == hex '9f' or $code == hex '8f') 
        ##{     # What does this mean ?
        ##      my $junk = get_ascii_string( $buf, $i );
        ##}    
        
        elsif ($code == hex 'fe') 
        {
            # End of block: this should only be encountered when
            # browsing past the end of a block -- so we skip over end
            # of block (nulls) Added: then we parse the beginning of
            # the next block, which will give us the info we want
            while (ord (substr ($$buf, ++$$i, 1)) == hex("00"))
            {
                #do nothing, except error check
                if ($$i > length $$buf)
                {
                    warn ("Went beyond end of the buffer!");
                    $self->{end_of_file_flag} = 1;
                    return;
                }
            }
            $self->parse_non_ascii($buf, $i);

        }
        elsif ($code == hex 'f0')
        {
            # End of file
            warn "Hit end of file marker!";
            return;
        }
        else 
        {
            # none of the above, so update bookmark 
            parse_bookmark ($self, $buf, $i, $code);
#             print STDERR ">$$i\n";
        }
        
        $$i++; # peek ahead to next $code
    }
    $$i--; # went one too far -- end on end of block (\xff, usually)
    return;
}
#+end_src

** parse_bookmark 
Subroutine to parse a non-ascii bookmark that sets or increments one of the    
counters that keep track of what line, chapter, book, etc. we are currently at.

#+begin_src perl
sub parse_bookmark 
{       
    # adjust counters
    my ($self, $buf, $i, $code) = @_;
    my ($left, $right, $num, $char, $top_byte, $low_byte, $str);
    my ($letter, $j);
    
    # left nybble: usually gives the level of the counter being modified.
    $left = ($code & LMASK) >> 4;   
    
    # right nybble: dictates the form of the upcoming data (when > 8).
    $right = $code & RMASK; 

    # 7 is EOB, EOF, or end of string, and should not be encountered here.  
    # 6 (apart from 0xef as end of string, which is handled elsewhere) seems
    # to have been used in newer PHI disks ( >v.5.3 -- eg. Ennius).  The 
    # earlier disks don't have this info, and it doesn't add much, so
    # we might consider throwing it away (see below, where is is used).
    # 5 is the top level counter for the DDP disks.
    
    if ($left == 7) 
    {       
        # These bytes are found in some versions of the PHI disk
        # (eg. Phaedrus) God knows what they mean.  phi2ltx says they
        # mark the beginning and end of an "exception".
        return if $code == hex('f8') or $code == hex('f9');
        
        warn("I don't understand what to do with level ".
             "$left (right = $right, code = ". (sprintf "%lx", $code) . 
             "; offset ". (sprintf "%lx", $$i) );
        return;
    }
    
    if ($left == 6) 
    {
        # This is redundant info (?), since earlier versions of the
        # disks apparently omit it and do just fine.  
        # This are the a -- z levels: encoded ascii!!
        
        # Commented out since the DDP encodes something wierd here,
        # and it is not synonymous with the other levels info
        
        #my %letters = (        z => 0, y => 1, x => 2, w => 3, 
        #                               v => 4, u => 5, t => 6, s => 7 );
        # Let's hope that's enough!
        
        #$letter = chr (ord (substr ($$buf, ++$$i, 1)) & MASK); 
        #$left = $letters{$letter} || 0;
        
        # Throw this info away
        $$i++;
        $$i++           if $right == 8 or $right == 10;
        $$i += 2        if $right == 9 or $right == 11 or $right == 13;
        $$i += 3        if $right == 12;
        my $junk = get_ascii_string( $buf, $i ) if $right == 10 
            or $right == 13 or $right == 15;
        warn("I don't understand a right nybble value of 14") if $right == 14;
        return;
    }
    
    # NB. All lower levels go to one when an upper one changes.
    # In some texts (like Catullus on the older PHI disks), 
    # lower level counters are assumed to go to one, rather than
    # to disappear when higher levels change.  
    # This is also true for the DDP disk!
    $left and map $self->{level}{$_} = 1, (0 .. ($left - 1));
    
    # The usual case: increment the counter specified by the left nybble.
    if ($right == 0) 
    {       
        # print STDERR ">$left, $right, $self->{level}{$left}\n";
        # When previous line num is "post 308" for a lacuna, delete
        # post before incrementing
        $self->{level}{$left} =~ s/^post\s+//;
        # Also incr. non-digits: 1e1 goes to 1e2, 1b goes to 1c, etc.
        $self->{level}{$left} = '' unless exists $self->{level}{$left};
        $self->{level}{$left} =~ s/([a-zA-Z]*[0-9]*)$/my $rep = $1 || 0;
        $rep++; $rep/ex;
        ##print "))".$left.": ".$self->{level}{$left}."\n" if $self->{debug};
    }
    # Otherwise, set counter to value whose type is given in right nybble.
    elsif (($right > 0) and ($right < 8)) 
    {
        $self->{level}{$left} = $right;
    }
    # That value can be multi-byte, of several varieties
    
    elsif ($right == 8) 
    {   # next byte, num (7-bit) only
        $self->{level}{$left} = ord (substr ($$buf, ++$$i, 1)) & MASK;
    }
    elsif ($right == 9) 
    {   # num, then char
        $num = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $char = chr (ord (substr ($$buf, ++$$i, 1)) & MASK);
        $self->{level}{$left} = $num.$char;
    }
    elsif ($right == 10) 
    {   # num, then string
        $num = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $str = get_ascii_string( $buf, $i );
        if ($self->{documentary})
        {
            # Nasty hack for when this string contains stuff
            # like 1[3], which could be BETA formatting code,
            # but isn't (see Fouilles de Delphes in the
            # Cornell inscriptions database).
            $str =~ s#([\[\]])#\`$1\`#g; #These are BETA null chars.
        }
        $self->{level}{$left} = $num.$str;
    }
    elsif  ($right == 11) 
    {   # next two bytes hide a 14-bit number
        $top_byte = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $low_byte = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $self->{level}{$left} = ($top_byte << 7) + $low_byte;
    }
    elsif  ($right == 12) 
    {   # 2-byte num, then char
        $top_byte = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $low_byte = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $char = chr (ord (substr ($$buf, ++$$i, 1)) & MASK);
        $num = ($top_byte << 7) + $low_byte;
        $self->{level}{$left} = $num.$char;
    }
    elsif  ($right == 13) 
    {   # 2-byte num, then string
        $top_byte = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $low_byte = ord (substr ($$buf, ++$$i, 1)) & MASK;
        $num = ($top_byte << 7) + $low_byte;
        $str = get_ascii_string( $buf, $i );
        $self->{level}{$left} = $num.$str;
    }
    elsif  ($right == 14) 
    {   # Is this correct? Only append a char to the (unincremented) counter?
        # Apparently confirmed by phi2ltx.
        # die("I don't understand a right nybble value of 14");
        $char = chr (ord (substr ($$buf, ++$$i, 1)) & MASK);
        $self->{level}{$left} .= $char;
    } 
    elsif  ($right == 15) 
    {   # a string comes next 
        $str = get_ascii_string( $buf, $i ); 
        $self->{level}{$left} = $str; 
        ##print ")".$left.": ".$self->{level}{$left}."\n" if $self->{debug};
    } 
    else 
    {   #no other possibilities 
        warn("I've fallen and I can't get up!");
    }
}
#+end_src

** Nachbearbeitung des Output
*** print_output
#+begin_src perl
sub print_output
{
    my ($self, $ref) = @_;

    # Running tally of characters of output
    $self->{current_chunk} += length($$ref);
    
    # Replace runs of non-ascii with newlines and add symbol for the
    # base language of the text at the start of the excerpt and after
    # every run of non-ascii (only for documentary texts such as the
    # DDP, which have lots of unterminated Latin embedded in
    # non-ascii). Actually, we turn out to need this for PHI Latin
    # texts, too, since it assumes reversion to Latin at the start of
    # a line and will not terminate Greek quotes if they end a line
    # (see Gellius, NA pref.)

    # Add null char afterwards, in case line begins with
    # a number

    # \x01 is to protect `
    # \x02 is to protect \n

    my $lang = $self->{current_lang} || 'g';
    my $newline = "\n\x02"; 
    $newline = "\n" . (($lang =~ m/g/) ? '$' : '&') . "\x02" if
        $self->{documentary} or $self->{type} eq 'phi';
    $$ref =~ s/[\x00-\x06\x0e-\x1f]+//g ;
    $$ref =~ s/[\x80-\xff]+/$newline/g ;
    # Don't interrupt a run of Greek with a Latin indicator at the start of the line.
    $$ref =~ s/\&\x02\$/\x02\$/g ;
    $$ref =~ s/\$\x02\&/\x02\&/g ;

#     print STDERR "::$$ref\n";
    if (defined $self->{aux_out})
    {
        my $aux = $$ref;
        $aux =~ s#\x02##g;
        my $success = print { $self->{aux_out} } ($aux);
        print STDERR "Aux print failed! $!\n" unless $success;
    }

    return if $self->{output_format} eq 'none';
    print STDERR "Formatting...\n" if $self->{debug};
    $self->format_output($ref);

    print STDERR "Printing...\n" if $self->{debug};
    if (not defined $self->{interleave_printing})
    {
        $$ref =~ s#\x02##g;
        my $success = print $$ref;
        print STDERR "Print failed! $!\n" unless $success;
    }
    else
      {
        my $success;
        my $first_cit = shift @{ $self->{interleave_printing} };
        $success = print $first_cit if $first_cit;
        print STDERR "Print failed (first_cit)! $!\n" unless $success;
        while ($$ref =~ m#(.*?)(?:\x02|$)#gs)
        {
            $success = print $1;
            print STDERR "Print failed ($1)! $!\n" unless $success;
            my $citation = shift @{ $self->{interleave_printing} };
            $success = print $citation if $citation;
            print STDERR "Print failed (citation)! $!\n" unless $success;
        }
        my $citation = shift @{ $self->{interleave_printing} };
        $success = print $citation if $citation;
        print STDERR "Print failed (last_cit)! $!\n" unless $success;
    }
    print STDERR "Printed.\n" if $self->{debug};
}
#+end_src
*** format_output
#+begin_src perl
  sub format_output
{
    my ($self, $ref, $current_lang, $inhibit_perseus) = @_;
    print STDERR "+".$$ref."\n" if $self->{debug};
    my $lang = $self->{current_lang} || 'g';
    $lang = $current_lang if $current_lang;
    $self->{perseus_morph} = 0 if ($encoding{$self->{encoding}}{remap_ascii});
    $self->{perseus_morph} = 0 if $inhibit_perseus;
    
    # Get rid of null chars.  We can't do this last, as we would like,
    # because this represents a grave accent for many encodings
    # (e.g. displaying Ibycus via HTML).  We have to leave something
    # here as a marker or formatting gets confused.  So all formats
    # must remember to remove this string.
    $$ref =~ s/\`/\x01/g;

    if ($self->{type} eq 'cop' and $lang !~ m/l/)
    {
        $self->coptic_with_latin($ref);
    }
    elsif ($lang eq 'g')
    {
        $self->greek_with_latin($ref);
    }
    else
    {
        $self->latin_with_greek($ref);
    }
    
    
    $self->beta_formatting_to_ascii ($ref) if $self->{output_format} eq 'ascii';
    # use beta_formatting_to_ascii with encoding Ibycus for repaging
    # output PAM 090102
    $self->beta_formatting_to_ascii ($ref) if $self->{output_format} eq 'repaging';
    $self->beta_to_latex ($ref) if $self->{output_format} eq 'latex';
    if ($self->{output_format} eq 'html')
    {
        if ($encoding{$self->{encoding}}{remap_ascii})
        {
            # This is a Greek font that remaps the ascii range, and so
            # it is almost certainly not safe to parse the output as
            # Beta, since the Greek encoding will contain HTML Beta
            # control and formatting chars.  So we just escape the
            # HTML codes, and send it as-is
            $self->html_escape($ref);
            $$ref = "\n<pre>\n$$ref\n</pre>\n";
        }
        else
        {
            $self->beta_to_html ($ref);
        }
    }
    $$ref =~ s/\x01//g;
    print STDERR "Formatted.\n" if $self->{debug};
}
#+end_src
*** greek_with_latin
#+begin_src perl
sub greek_with_latin
{
    my ($self, $ref) = @_;
#     $self->{perseus_morph} = 0;
    $$ref =~ s/([^\&]*)([^\$]*)/
                                        my $gk = $1 || '';
                                        if ($gk)
                                        {
                                                $self->{perseus_morph} ? 
                                                  $self->perseus_handler(\$gk, 'grk') 
                                                : $self->{greek_handler}->(\$gk);
                                        }
                                        my $lt = $2 || '';
                                        if ($lt)
                                        {
                                                $self->{perseus_morph} ? 
                                                  $self->perseus_handler(\$lt, 'lat') 
                                                : $self->{latin_handler}->(\$lt);
                                        }
                                        $gk.$lt;
                                        /gex;
}
#+end_src
*** latin_with_greek
#+begin_src perl
sub latin_with_greek
{
    my ($self, $ref) = @_;
    $$ref =~ s/([^\$]*)([^\&]*)/
                                        my $lt = $1 || '';
                                        if ($lt)
                                        {
                                                $self->{perseus_morph} ? 
                                                  $self->perseus_handler(\$lt, 'lat') 
                                                : $self->{latin_handler}->(\$lt);
                                        }
                                        my $gk = $2 || '';
                                        if ($gk)
                                        {
                                                $self->{perseus_morph} ? 
                                                  $self->perseus_handler(\$gk, 'grk') 
                                                : $self->{greek_handler}->(\$gk);
                                        }
                                        $lt.$gk;
                                        /gex;
}
#+end_src
*** perseus_handler
#+begin_src perl
sub perseus_handler
{
    my ($self, $ref, $lang) = @_;
    my $out = '';
    my ($h_word, $h_space) = ('', '');

    $$ref =~ s/%15/'/g; # Used irregularly in Pindar for a mid-word apostrophe
    # $punct are not part of the word, but should not interfere in morph lookup
    my ($beta, $punct) = $lang eq 'grk' ? ('-A-Za-z/\\\\|+)(=*~\'', '\\[\\]!?.')
        : ('-A-Za-z~\'', '\\[\\]!?.,:+\\\\/=');  
    while ($$ref =~ m/(~~~.+?~~~)|([$beta$punct\d]*)([^$beta]*)/g)
    {
        # This is a context/divider
        $out .= $1, next if $1;
        my $orig_word  = $2 || '';
        my $space = $3 || '';
        my $link = $h_word . $orig_word;
        my $word = $h_word . $h_space . $orig_word;
        # print STDERR "1>>$word\n";
            
        if ($word =~ m/-~?$/)
        {       # Carry over hyphenated parts
            ($h_word, $h_space) = ($word, $space);
        }
        else
        {
            $link =~ s/[$punct\d-]//g;
            # Perseus morph parser takes Beta, but lowercase 
            $link =~ tr/A-Z/a-z/ if $lang eq 'grk'; 
            $link =~ s#\\#/#g if $lang eq 'grk';    # normalize barytone
            
            # print STDERR "2>>$link\n";

            $link =~ s/~[Hh]it~([^~]*)~/$1/g; 
            # Encode word itself
            if ($lang eq 'grk')
            {
                $self->{greek_handler}->(\$word); 
                $self->{greek_handler}->(\$space); 
            }
            elsif ($lang eq 'lat')
            {
                $self->{latin_handler}->(\$word); 
                $self->{latin_handler}->(\$space); 
            }
            else
            {
                warn("What language is $lang?\n");
            }
            $self->html_escape(\$word);
            $self->html_escape(\$space);
            # \x03\x02 gets changed to %, \x03\x01 to " and \x03\x03 to _
            # URL escape (from CGI.pm)
            $link =~ s/([^a-zA-Z0-9_.%;&?\/\\:=-])/"\x03\x02".sprintf("%02X",ord($1))/eg;
            my $html = qq(<a onClick=\x03\x01parse\x03\x03$lang('$link', this)\x03\x01>$word</a>);
            $out .= $html.$space;
            ($h_word, $h_space) = ('', '');
            # print STDERR "3>>$html\n";
            
        }
    }
    $$ref = $out;
}
#+end_src
*** beta_encoding_to_ibycus 
Subroutine to convert a string from raw BETA code to Pierre MacKay's
ibycus format.

#+begin_src perl
    sub beta_encoding_to_ibycus 
{
    # Unlike many other encodings, Ibycus takes care of medial/final
    # sigmas for us, so we only have to worry about explicit S1, etc.
    # \x04 is used to protect dangerous analphabetics
    my ($self, $ref) = @_;
    $$ref =~ tr/A-Z/a-z/;
    $$ref =~ s/s1/s\|/g;
    $$ref =~ s/s2/j/g;
    $$ref =~ s/s3/c+/g;
    $$ref =~ s/'/\x041/g; # Converted to {'} or '' later
    $$ref =~ s/\//'/g;
    $$ref =~ s/\\/`/g;
    $$ref =~ s/\*(\W*)(\w)/$1\u$2/g;
    $$ref =~ s#;#\x042#g; # Must be converted to "?" *after* ?'s for underdots are done
    $$ref =~ s#:#;#g;
    $$ref =~ s#\[1#\x043(\x044#g; # These punctuation marks can cause trouble
    $$ref =~ s#\]1#\x043)\x044#g;
    $$ref =~ s#\[(?!\d)#\x043[\x044#g;
    $$ref =~ s#\](?!\d)#\x043]\x044#g;
    $$ref =~ s#J#{\\nrm{}h}#g;  # Early orthography in epigraphical corpus
}
#+end_src
*** beta_encoding_to_transliteration 
#+begin_src perl
sub beta_encoding_to_transliteration 
{
    # Just like Ibycus above, but a bit cleaner to read as text
    my ($self, $ref) = @_;
    $$ref =~ tr/A-Z/a-z/;
    $$ref =~ s/s1/s\|/g;
    $$ref =~ s/s2/j/g;
    $$ref =~ s/s3/c+/g;
    $$ref =~ s/'/$self->{ibycus4} ? '{\'}' : '\'\''/ge;
    $$ref =~ s/\//'/g;
    $$ref =~ s/\\/`/g;
    $$ref =~ s/\*(\W*)(\w)/$1\u$2/g;
    $$ref =~ s#;#?#g; 
    $$ref =~ s#:#;#g;
    $$ref =~ s#\[1#(#g; 
    $$ref =~ s#\]1#)#g;
    $$ref =~ s#\[(?!\d)#[#g;
    $$ref =~ s#\](?!\d)#]#g;
}
#+end_src
*** beta_encoding_to_latin1
#+begin_src perl
sub beta_encoding_to_latin1
{
    my $ref = shift;
    
    my %acute = (a => "\xe1", e => "\xe9", i => "\xed", o => "\xf3", u => "\xfa", y => "\xfd",
                 A => "\xc1", E => "\xc9", I => "\xcd", O => "\xd3", U => "\xda", Y => "\xdd");
    my %grave = (a => "\xe0", e => "\xe8", i => "\xec", o => "\xf2", u => "\xf9", 
                 A => "\xc0", E => "\xc8", I => "\xcc", O => "\xd2", U => "\xd9"); 
    my %diaer = (a => "\xe4", e => "\xeb", i => "\xef", o => "\xf6", u => "\xfc", y => "\xfd",
                 A => "\xc4", E => "\xcb", I => "\xcf", O => "\xd6", U => "\xdc", Y => "\x178");
    my %circm = (a => "\xe2", e => "\xea", i => "\xee", o => "\xf4", u => "\xfb", 
                 A => "\xc2", E => "\xca", I => "\xce", O => "\xd4", U => "\xdb"); 


    $$ref =~ s/([aeiouyAEIOUY])\//$acute{$1}||'?'/ge;
    $$ref =~ s/([aeiouAEIOU])\\/$grave{$1}||'?'/ge;
    $$ref =~ s/([aeiouyAEIOUY])\+/$diaer{$1}||'?'/ge;
    $$ref =~ s/([aeiouAEIOU])\=/$circm{$1}||'?'/ge;
}
#+end_src
*** utf8_to_beta_encoding
#+begin_src perl
sub utf8_to_beta_encoding
{
    # For input (esp. to browser)
    my $ref = shift;
    
    my %accents = ( 
        '225' => 'a/', '233' => 'e/', '237' => 'i/', '243' => 'o/', '250' =>'u/', 
        '193' => 'A/', '201' => 'E/', '205' => 'I/', '211' => 'O/', '218' => 'U/',
        '224' => 'a\\', '232' => 'e\\', '236' => 'i\\', '242' => 'o\\', '249' => 'u\\', 
        '192' => 'A\\', '200' => 'E\\', '204' => 'I\\', '210' => 'O\\', '217' => 'U\\',
        '228' => 'a+', '235' => 'e+', '239' => 'i+', '246' => 'o+', '252' => 'u+', 
        '196' => 'A+', '203' => 'E+', '207' => 'I+', '214' => 'O+', '220' => 'U+',
        '226' => 'a=', '234' => 'e=', '238' => 'i=', '244' => 'o=', '251' => 'u=', 
        '194' => 'A=', '202' => 'E=', '206' => 'I=', '212' => 'O=', '219' => 'U='
        ); 
    
    $$ref =~ s#([\x80-\xff]+)#      my @chars=unpack'U*',$1; 
                                    my $out = '';
                                    map { $out .= $accents{$_} } @chars;
                                    $out;
              #ge;
}
#+end_src
*** beta_encoding_to_latin_tex
#+begin_src perl
sub beta_encoding_to_latin_tex
{
    my $ref = shift;
    
    $$ref =~ s#([\s\n~])"#$1``#g;
    $$ref =~ s#"#''#g;
    $$ref =~ s#([aeiouAEIOU])\/#\\'{$1}#g;
    $$ref =~ s#([aeiouAEIOU])\\#\\`$1;#g;
    $$ref =~ s#([aeiouAEIOU])\=#\\^{$1}#g;
    $$ref =~ s#([aeiouAEIOU])\+#\\"{$1}#g;
    $$ref =~ s/([\%\$\@\#])/\\$1/g;
}
#+end_src
*** beta_latin_to_utf
#+begin_src perl
sub beta_latin_to_utf
{
    my $ref = shift;

    # First, we translate to iso-8859-1
    beta_encoding_to_latin1($ref);

    # Then to utf-8 (but we don't use the pragma)
    $$ref =~ s#(\x05|[\x80-\xff])#my $c = $1;
                                if ($c =~ m/\x05/)
                                {       
                                        $c;
                                }
                                else
                                {
                                        chr(((ord $c) >> 6) | hex 'c0') . 
                                        chr((ord $c & hex '3f') | hex '80') ;
                                }
                                #ge;
}
#+end_src
*** beta_encoding_to_html
#+begin_src perl
sub beta_encoding_to_html
{
    my ($self, $ref) = @_;
    
    # these are really part of the encoding
    $$ref =~ s#([aeiouAEIOU])\/#&$1acute;#g;
    $$ref =~ s#([aeiouAEIOU])\\#&$1grave;#g;
    $$ref =~ s#([aeiouAEIOU])\=#&$1circ;#g;
    $$ref =~ s#([aeiouAEIOU])\+#&$1uml;#g;
    
    if ($encoding{$self->{encoding}}{remap_ascii})
    {
        # This is going to the browser directly without re-formatting in HTML,
        # so we might as well strip the junk out here
        $self->beta_formatting_to_ascii($ref);
    }
}
#+end_src
*** beta_formatting_to_ascii 
#+begin_src perl
sub beta_formatting_to_ascii 
{
    my ($self, $ref) = @_;
    
    # Turn off warnings when we access phantom elements of the following
    # arrays.
    local $^W = 0;
    
    my @punct = (qw# ? * / ! | = + % & : . * #);  
    my @bra   = ('', '(', qw/< { [[ [ [ [ [ [ [ ( -> [ [ [ [[ [[/, '', '', qw/{ { { {/);
    my @ket   = ('', ')', qw/> } ]] ] ] ] ] ] ] ) <- ] ] ] ]] ]]/, '', '', qw/} } } }/);
    
    $$ref =~ s#_#-#g if $self->{documentary};
    $$ref =~ s#_# -- #g;
    
    #       $$ref =~ s#\?#\(?\)#g   unless $self->{current_lang} eq 'l';
    $$ref =~ s#\!#.#g               unless $self->{current_lang} eq 'l';
    $$ref =~ s#[\&\$]\d*##g;
    $$ref =~ s#%(\d+)#$punct[$1]#g;
    $$ref =~ s#\"\d*#\"#g;
    
    $$ref =~ s#@\d+#\ \ #g;
    $$ref =~ s#@#\ \ #g;
    $$ref =~ s#\^\d+#\ \ \ \ #g;
    
    # Get rid of numbers after brackets, etc
    $$ref =~ s#([\<\>\{\}])\d+#$1#g;
    # Get rid of # except for &#0000; etc.
    $$ref =~ s/#\d+/#/g unless $self->{encoding} =~ m/Unicode_Entities/;

    $$ref =~ s#\[(\d+)#$bra[$1]#g; 
    $$ref =~ s#\](\d+)#$ket[$1]#g;
    
    $$ref =~ s#\x042#?#g;
    $$ref =~ s#s\x041#$self->{ibycus4} ? 's\'' : 's\'\''#ge; # stop spurious final sigmas
    $$ref =~ s#\x041#$self->{ibycus4} ? '{\'}' : '\'\''#ge;
    $$ref =~ s#\x043#{#g;
    $$ref =~ s#\x044#}#g;

    # Capitalization of vowels with diacrits won't work with many 
    # of the wierder encodings
    if ($self->{current_lang} eq 'g' 
        and $self->{encoding} !~ m/Ibycus/i
        and $self->{encoding} !~ m/Transliteration/i
        and $self->{encoding} !~ m/Beta/i       )
    {
        $$ref =~ s#~[Hh]it~([^~]+)~#->$1<-#g;
    }
    else
    {
        $$ref =~ s#~[Hh]it~([^~]+)~#\U$1\Q#g;
    }
}
#+end_src
*** HTML und LaTeX
**** html_escape
#+begin_src perl
sub html_escape
{
    my ($self, $ref) = @_;
#   $$ref =~ s/&/&amp;/g;
    $$ref =~ s/&(?!#|[aeiouAEIOU](?:acute|grave|circ|uml);)/&amp;/g;
    $$ref =~ s/>/&gt;/g;
    $$ref =~ s/</&lt;/g;

}
#+end_src
**** beta_to_html
Subroutine to convert the formatting codes in the search result to html    
markup.  Feed me one entry at a time, please.                              
#+begin_src perl
sub beta_to_html 
{
    my ($self, $ref) = @_;


    # more could be done with < and >, but mark them with braces for now
    # escape all < and > so as not to confuse html
    # escape & when not followed by # (html numerical entity)
    # Text including Perseus links will already be html-escaped
    
    unless ($self->{perseus_morph})
    {       
        $$ref =~ s/&(?!#|[aeiouAEIOU](?:acute|grave|circ|uml);)/&amp;/g;
        $$ref =~ s#\<#&lt;#g;
        $$ref =~ s#\>#&gt;#g;
    }
    $$ref =~ s#&lt;1(?!\d)((?:(?!\>|$).)+)(?:&gt;1(?!\d))#<u>$1</u>#gs;
    
    # undo the business with ~hit~...~
#     $$ref =~ s#~[Hh]it~([^~]*)~#<u>$1</u>#g;

    # " (quotes)
    $$ref =~ s/([\$\&\d\s\n~])\"3\"3/$1&#147;/g;
    $$ref =~ s/([\$\&\d\d\s\n~])\"3/$1&#145;/g;
    $$ref =~ s/\"3\"3/&#148;/g;
    $$ref =~ s/\"3/&#146;/g;

    $$ref =~ s/([\$\&\d\s\n~])\"[67]/$1&laquo;/g;
    $$ref =~ s/\"[67]/&raquo;/g;

    $$ref =~ s/([\x01-\x1f@\$\&\d\s\n~])\"\d?/$1&#147;/g;
    $$ref =~ s/\"\d?/&#148;/g;
    $$ref =~ s/\"\d+/&quot;/g;
    
    $$ref =~ s#\x03\x01#"#g;

    $$ref =~ s#~[Hh]it~([^~]*)~#$self->{hit_html_start}$1$self->{hit_html_end}#g;
    
    $$ref =~ s#&lt;\d*#&lt;#g;
    $$ref =~ s#&gt;\d*#&gt;#g;

    # Note that $ must be escaped in these regexen, or the $] is parsed as a var.
    $$ref =~ s#(?:\$|&amp;)10((?:(?!\$|&amp;).)+)#<font size=-1>$1</font>#gs;
    $$ref =~ s#(?:\$|&amp;)11((?:(?!\$|&amp;).)+)#<font size=-1><b>$1</b></font>#gs;
    $$ref =~ s#(?:\$|&amp;)13((?:(?!\$|&amp;).)+)#<font size=-1><i>$1</i></font>#gs;
    $$ref =~ s#(?:\$|&amp;)14((?:(?!\$|&amp;).)+)#<font size=-1><sup>$1</sup></font>#gs;
    $$ref =~ s#(?:\$|&amp;)15((?:(?!\$|&amp;).)+)#<font size=-1><sub>$1</sub></font>#gs;
    $$ref =~ s#&amp;16((?:(?!\$|&amp;).)+)#<sup><i>$1</i></sup>#gs;
    $$ref =~ s#(?:\$|&amp;)20((?:(?!\$|&amp;).)+)#<font size=+1>$1</font>#gs;
    $$ref =~ s#(?:\$|&amp;)21((?:(?!\$|&amp;).)+)#<font size=+1><b>$1</b></font>#gs;
    $$ref =~ s#(?:\$|&amp;)23((?:(?!\$|&amp;).)+)#<font size=+1><i>$1</i></font>#gs;
    $$ref =~ s#(?:\$|&amp;)24((?:(?!\$|&amp;).)+)#<font size=+1><sup>$1</sup></font>#gs;
    $$ref =~ s#(?:\$|&amp;)25((?:(?!\$|&amp;).)+)#<font size=+1><sub>$1</sub></font>#gs;
    $$ref =~ s#(?:\$|&amp;)30((?:(?!\$|&amp;).)+)#<font size=-2>$1</font>#gs;
    $$ref =~ s#(?:\$|&amp;)40((?:(?!\$|&amp;).)+)#<font size=+2>$1</font>#gs;
    
    $$ref =~ s#(?:\$|&amp;)1((?:(?!\$|&amp;).)+)#<b>$1</b>#gs;
    $$ref =~ s#(?:\$|&amp;)3((?:(?!\$|&amp;).)+)#<i>$1</i>#gs;
    $$ref =~ s#(?:\$|&amp;)4((?:(?!\$|&amp;).)+)#<sup>$1</sup>#gs;
    $$ref =~ s#(?:\$|&amp;)5((?:(?!\$|&amp;).)+)#<sub>$1</sub>#gs;
    $$ref =~ s#\&amp;[678]((?:(?!\$|&amp;).)+)#<font size=-1>\U$1\E</font>#gs;
    $$ref =~ s#\$\d6((?:(?!\$|&amp;).)+)#<b><sup>$1</sup></b>#gs;

    $$ref =~ s#\&amp\;##g;
    $$ref =~ s#\$##g;
    
    # BETA { and } -- title, marginalia, etc.
    # what to do about half-cut off bits? must stop at a blank line.
    #
    $$ref =~ s#\{1((?:[^\}]|\}[^1]|\})*?)(?:\}1|$)#<p><b>$1</b></p>#g;
    $$ref =~ s#((?:[^\}]|\}[^1]|\})*?)\}1#<p><b>$1</b></p>#g;
    # Servius
    $$ref =~ s#\{43((?:[^\}]|\}[^4]|\}4[^3])*?)(?:\}43|$)#<i>$1</i>#g;
    $$ref =~ s#((?:[^\}]|\}[^4]|\}4[^3])*?)\}43#<i>$1</i>#g;
#     $$ref =~ s#\{\d+([^\}]+)(?:\}\d+|$)#<h5>$1</h5>#g;
    $$ref =~ s#\{\d+([^\}]+)(?:\}\d+|$)#$1#g;

    
    
    # record separators
    if ($Diogenes::Base::cgi_flag and $self->{cgi_buttons})
    {
        $$ref =~ s#~~~(.+?)~~~#<p class="gotocontext"><a href="/Diogenes.cgi?JumpTo=$1">$self->{cgi_buttons}</a></p><hr>#g;
        
    }
    else
    {
        $$ref =~ s#~~~~~+#<hr>\n#g;
        $$ref =~ s#~~~.+?~~~#<hr>\n#g;
        $$ref =~ s#^\$\-?$#\$<p> #g;
    }
    
    # eliminate `#' except as part of &#nnn;
    #$$ref =~ s/(?<!&)#\d*([^;])/$1/g;  

    # # and *#
    $$ref =~ s/\*#(\d+)/$Diogenes::BetaHtml::starhash{$1}/g;
    $$ref =~ s/(?<!&)#(\d+)/$Diogenes::BetaHtml::hash{$1}||'??'/ge;
    $$ref =~ s/(?<!&)#/&#x0374/g;
    
    # some punctuation
    $$ref =~ s/_/\ &#150;\ /g;


    # Perseus links use % for URL-escaped data in the href, so these are 
    # written as \x03\x02 until now 
    # % (more punctuation)
    # s/([])%24/&$1tilde;/g;
    $$ref =~ s#%(\d+)(?:\x01)?#$Diogenes::BetaHtml::percent{$1}#g;
    $$ref =~ s/%/\&\#134\;/g;
    $$ref =~ s/\x03\x02/%/g;
    $$ref =~ s/\x03\x03/_/g;
    
    $$ref =~ s#s\x041#$self->{ibycus4} ? 's\'' : 's\'\''#ge; # stop spurious final sigmas
    $$ref =~ s#\x041#$self->{ibycus4} ? '{\'}' : '\'\''#ge;
    $$ref =~ s#\x042#?#g;
    $$ref =~ s#\x043#{#g;
    $$ref =~ s#\x044#}#g;
    
    # @ (whitespace)
    $$ref =~ s#@(\d+)#'&nbsp;' x $1#ge;
    $$ref =~ s#(\ \ +)#'&nbsp;' x (length $1)#ge;
    $$ref =~ s#@#&nbsp;#g;
    
    # ^
    $$ref =~ s#\^(\d+)#my $w = 5 * $1;qq{<spacer type="horizontal" size=$w>}#ge;
    
    # [] (brackets of all sorts)
    $$ref =~ s#\[(\d+)#$Diogenes::BetaHtml::bra{$1}#g; 
    $$ref =~ s#\](\d+)#$Diogenes::BetaHtml::ket{$1}#g;

    
#     $$ref =~ s#\n\s*\n#\n#g; 

    # Try not to have citation info appear next to blank lines
#     $$ref =~ s#\x02\n#\n\x02#g;
    $$ref =~ s#\n+#<br/>\n#g;
    $$ref =~ s#(</[Hh]\d>)\s*<br/>#$1#g;
    $$ref =~ s#<[Hh]\d></[Hh]\d>##g; # void marginal comments

#   These have to stay, since babel, Ibycus uses ` as the grave accent
    if ($self->{encoding} =~ m/Ibycus/i or $self->{encoding} =~ m/Babel/i) {
        $$ref =~ s/\x01/\`/g;
    }
#      print STDERR ">>$$ref\n";
    

}
#+end_src
**** beta_to_latex 
Method to convert the formatting codes in the search result to latex 
markup.   For Greek mostly.                                          
                                                                      
#+begin_src perl
sub beta_to_latex 
{
    my ($self, $ref) = @_;

    # \x061 protects \ \x062 protects { and \x063 protects } \x064 protects :
    
    # We may get many chunks now
    $$ref = "xxbeginsamepage\n" . $$ref . "\x061endsamepage\n" 
        unless $$ref =~ m/^\&\nIncidence of all words as reported by word list:/;
    
    # record separators
    $$ref =~ s#~~~~~*\n#\x061forcepagebreak#g;
    $$ref =~ s#~~~.+?~~~\n#\x061forcepagebreak#g;
    $$ref =~ s#\n\&\&\n+#\x061forcepagebreak\n\n\&#g;
    

    # \familydefault to ibycus means that marginal notes and such are always set
    # in greek
    my ($small, $large);
    if ($self->{printer}) 
    {
        $small = '{8}{10}';
        $large = '{14}{17}';
    }
    else 
    {
        $small = '{14}{21}';
        $large = '{21}{25}';
    }

    # Here is some data used for turning BETA formatting codes into a twisted
    # form of LaTeX.
    
    local $^W = 0;

    my @punct = (
        '', qw#\textsterling $*$ / ! \ensuremath{|} $=$ $+$ \% \&#, "\x064", qw# . $*$#, 
        '{\ddag}', '{\P}', '\ensuremath{|}','\ensuremath{|}', '\ensuremath{|}', 
        '\'', '-', '', '', '', '', '', '', '', '', '', '', '{})', '{}(', '{}\'', 
        '{}`', '{}\~{}', '{})\'', '{}(\'', '{}(`', '{}(=', '{}\"{~}');  
    my @bra   = ('', '\ensuremath{(}', '\ensuremath{<}', 
                 qw/\{ [[ [ [ [ [ [ [ ( -> [ [ [ [[ [[/, '', '', qw/\{ \{ \{ \{/);
    my @ket   = ('', '\ensuremath{)}', '\ensuremath{>}', 
                 qw/\} ]] ] ] ] ] ] ] ) <- ] ] ] ]] ]]/, '', '', qw/\} \} \} \}/);
    if ($self->{ibycus4})
    {   #iby4extr
        $bra[5] = "{\\bracketleftbt}";
        $ket[5] = "{\\bracketrightbt}";
    }
    my @gk_font = (
        '', '\fontseries{b}', '', '\fontshape{sl}','','','','','', '', 
        "\\fontsize$small", "\\fontsize$small\\fontseries{b}", '', 
        "\\fontsize$small\\fontshape{sl}",'','','','','','',"\\fontsize$large",
        "\\fontsize$large\\fontseries{b}", '', "\\fontsize$small\\fontshape{sl}");
    my @rm_font = ('', '\fontseries{bx}', '', '\fontshape{it}','','',
                   '\fontshape{sc}','\fontshape{sc}','\fontshape{sc}','',
                   "\\fontsize$small", "\\fontsize$small\\fontseries{bx}",
                   '',"\\fontsize$small\\fontshape{it}",'','','','','','',
                   "\\fontsize$large", "\\fontsize$large\\fontseries{bx}", 
                   '', "\\fontsize$small\\fontshape{it}");
    my @sym = (
        '', '{\greek{k+}}', '\ensuremath{\cdot}', '{\greek{k+}}', '', '{\greek{s+}}',
        '\makebox[0pt][l]{\hspace{-2mm}\rule[-3.5mm]{5mm}{.2mm}\rule[-5mm]{0mm}{9mm}}', 
        '.', 
        '\makebox[0pt][l]{\hspace{-2mm}\rule[-3.5mm]{5mm}{.2mm}\rule[-5mm]{0mm}{9mm}}', 
        '', '\ensuremath{\supset}', '', '--',
        '\ensuremath{\divideontimes}', '\dipleperi{}',
        '\ensuremath{>}');

    # If we are generating postscript or PDF for portability, we don't
    # want any bitmapped fonts
    my @oddquotes = $self->{psibycus} ?
        ('{,,}',
         '{,}',
         '{\\greek{<<}}',
         '{\\greek{<<}}',
         '{\\greek{>>}}',
         '{\\greek{>>}}' 
        )  :
        ('{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\quotedblbase}',
         '{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\quotesinglbase}',
         '{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\guillemotleft}',
         '{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\guilsinglleft}',
         '{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\guillemotright}',
         '{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\guilsinglright}'  ) ;
    
    # BETA { and } -- title, marginalia, etc.
    
    #$$ref =~ s#\{1(?!\d)(([\$\&]\d*)?(?:[^\}]|\}[^1]|\})*?)(?:\}1(?!\d)|\x06)#\x061titlebox\x062$1\x063\x062$2\x063#g;
    $$ref =~ s#\{1(?!\d)([\$\&]\d*)?((?:(?!\}1(?!\d)|\x06).)+)(?:\}1(?!\d))?#\x061titlebox\x062$1\x063\x062$2\x063#gs;
    #$$ref =~ s#\{2(?!\d)((?:[^\}]|\}[^2]|\})*?)([\&\$]?)(?:\}2(?!\d)|\x06)#\\marginlabel\x062$1\x063$2#g;
    $$ref =~ s#\{2(?!\d)((?:(?!\}2(?!\d)|\x06).)+)(?:\}2(?!\d))?#\\marginlabel\x062$1\x063#gs;
    #$$ref =~ s#\{(\D[^\}]*?)([\$\&]?)\}(?:\s*\n)?#\\marginlabel\x062$1\x063$2#g;
    $$ref =~ s#\{(\D[^\}]*?)([\$\&]?)\}(?:\s*\n)?#\\marginlabel\x062$1$2\x063#g;
    ##$$ref =~ s#\{\d*([^\}]*)(?:\}\d*|\x06)#\x061ital\x062$1\x063#g;
    #$$ref =~ s#\{43((?:[^\}]|\}[^4]|\}4[^3])*?)(?:\}43|\x06)#\x061ital\x062$1\x063#g;
    #$$ref =~ s#((?:[^\}]|\}[^4]|\}4[^3])*?)\}43#\x061ital\x062$1\x063#g;
    $$ref =~ s#\{43((?:(?!\}43|\x06).)+)(?:\}43)?#\x061ital\x062$1\x063#g;
    $$ref =~ s#(?:\{43)?((?:(?!\}43|\x06).)+)(?:\}43)#\x061ital\x062$1\x063#g;
    # These {} signs are too multifarious in the papyri to do much with them -- and
    # if we make them italicized, then they often catch and localize wrongly font
    # shifts from rm to gk.
    $$ref =~ s#\{\d*([^\}]*)(?:\}\d*|\x06)#{$1}#g;
    
    # escape all other { and } so as not to confuse latex
    $$ref =~ s#\{\d*#\\\{#g;
    $$ref =~ s#\}\d*#\\\}#g;
    
    # now we can safely use { and } -- undo the business with \x06
    # the eval block is for cases where the ~hit~...~ spans two lines.
    # and to make it spit out the record delimiter when it eats that.
    $$ref =~ s#\x061titlebox\x062([^\x06]*)\x063\x062([^\x06]*)\x063#
                        my $rep = "\\titlebox{$1}{$2}";
                        $rep =~ s/~hit~([^~\n]*)\n([^~]*)~/~hit~$1~\n~hit~$2~/g;
                        $rep =~ s/(\n+\~+\n+)\}(\{[^\}]*\})$/\}$2$1/g;
                        $rep#gex; 

    # The font command to switch back is usually *inside* the marginal note!
    $$ref =~ s#\\marginlabel\x062([^\x06]*)\x063#my $label = $1;
                                my $font = $1 if $label =~ m/([\&\$]\d*)$/;
                                "\\marginlabel{$label}$font"#gex;
    $$ref =~ s#\x061ital\x062([^\x06]*)\x063#\\emph{$1}#gi;
    
    # Pseudo-letterspacing with \,:
    # Real letterspacing separates accents from their letters.
    # This method screws up medial sigma, so we have to force it.
    
    $$ref =~ s#\<20((?:(?!\>20|\x06).)+)(?:\>20)?#my $rep = $1; 
    $rep =~ s/(['`=)(]*[A-Z ][+?]*)(?=[a-zA-Z])/$1\\,/g; 
                        $rep =~ s/([a-z]['`|+=)(?]*)(?=[a-zA-Z])/$1\\,/g; 
                        $rep =~ s/s\\,/s\|\\,/g; 
                        $rep =~ s/$/\\,/; 
                        $rep =~ s/~h\\,i\\,t~/~hit~/; 
                        $rep#gsex;

    $$ref =~ s#\<(\D(?:[^\>\n]|\>\d)*?)(?:\>|\n)#\\ensuremath\{\\overline\{\\mbox\{$1\}\}\}#g;
    $$ref =~ s#\<1(\D(?:[^\>]|\>[^1])*)(?:\>1|\x06)#\\uline\{$1\}#g;
    $$ref =~ s#\<3(\D(?:[^\>\n]|\>[^3])*?)(?:\>3|\n)#\\ensuremath\{\\widehat\{\\mbox\{$1\}\}\}#g;
    $$ref =~ s#\<4(\D(?:[^\>\n]|\>[^4])*?)(?:\>4|\n)#\\ensuremath\{\\underbrace\{\\mbox\{$1\}\}\}#g;
    $$ref =~ s#\<5(\D(?:[^\>\n]|\>[^5])*?)(?:\>5|\n)#\\ensuremath\{\\overbrace\{\\mbox\{$1\}\}\}#g;

    # undo the business with ~hit~...~
    $$ref =~ s#~[Hh]it~([^~]*)~#\\hit{$1}#g;

    # more could be done with < and >, but mark them with braces for now
    $$ref =~ s#\<\d*#\\\{#g;
    $$ref =~ s#\>\d*#\\\}#g;
    
    # Record separator
    $$ref =~ s#^\$\-?$#\$\\rule{0mm}{8mm}\n #g;
    
    # some punctuation
    $$ref =~ s#_#-#g if $self->{documentary};
    $$ref =~ s#_#\ --\ #g;

    # ibycus4 extras
    if ($self->{prosody})
    {
        $$ref =~ s#\%40#\\prosody{u}#g;
        $$ref =~ s#\%41#\\prosody{-}#g;
        $$ref =~ s#\%42#\\prosody{bu}#g;
        $$ref =~ s#\%43#\\prosody{a}#g;
        $$ref =~ s#\%44#\\prosody{a}#g;
        $$ref =~ s#\%45#\\prosody{au}#g;
        $$ref =~ s#\%46#\\prosody{b-}#g;
        $$ref =~ s#\%49#\\prosody{uuu}#g;
    }
    
    # protect ?'s and !'s in latin mode
    $$ref =~ s/([^\&]*)([^\$]*)/
                                        my $gk = (defined $1) ? $1 : '';
                                        my $lt = (defined $2) ? $2 : '';
                                        $lt =~ s#;#\x065#g;         # protect ; : in latin mode
                                        $lt =~ s#:#\x064#g;                 
                                        $lt =~ s#([?!])#$1\{\}$2#g;
                                        $gk.$lt;
                                        /gex;
    $$ref =~ s#s\?(?![\s])#\\d{s|}#g; # medial / final sigma doesn't much matter in frag. pap.
    $$ref =~ s#\!#\.#g;
        
    $$ref =~ s#[\&\$](?:4|14|24)([^\&\$\n]+)(?=[\&\$\n])#\\textrm\{\\ensuremath\{\^\{$1\}\}\}#g;
    $$ref =~ s#[\$\&](?:5|15|25)([^\&\$\n]+)(?=[\&\$\n])#\\textrm\{\\ensuremath\{\_\{$1\}\}\}#g;
        
    # $ (greek fonts)
    $$ref =~ s#\$(\d+)#\\fontfamily{ibycus}$gk_font[$1]\\selectfont{}#g;
    $$ref =~ s#\$\n#\\ngk{} #g;
    $$ref =~ s#\$#\\ngk{}#g;
        
    # & (roman fonts)
    $$ref =~ s#\&(\d+)#\\fontfamily{cmr}$rm_font[$1]\\selectfont{}#g;
    $$ref =~ s#\&\n#\\nrm{} #g;
    $$ref =~ s#\&#\\nrm{}#g;

    # % (more punctuation)
    $$ref =~ s#([a-zA-Z]['`|+)(=]*)%24#\\~\{$1\}#g;
    $$ref =~ s#([a-zA-Z]['`|+)(=]*)%25#\\c\{$1\}#g;
    $$ref =~ s#([a-zA-Z]['`|+)(=]*)%26#\\=\{$1\}#g;
    $$ref =~ s#([a-zA-Z]['`|+)(=]*)%27#\\u\{$1\}#g;
    $$ref =~ s#%80#{\\nrm\\itshape{v}}#g; #Diogenes of Oenoanda 
    $$ref =~ s#%(\d+)#$punct[$1]#g;
    # ? Underdot
    $$ref =~ s#([a-zA-Z]['`|+)(=]*)\?#\\d{$1}#g;
    $$ref =~ s#(['`|+)(=]+)\?#\\d{$1}#g;
    # Sigmas preceeding a \d for underdot wrongly become final
    $$ref =~ s#s\\d\{#s\|\\d\{#g;
    
    $$ref =~ s#%#\\dag{}#g;
    
    # @ (whitespace)
    $$ref =~ s#^([^a-zA-Z]*)@\d*#$1#g; # not when it's at the beginning
    $$ref =~ s#@\d+#\n#g; 
    $$ref =~ s#@#~~#g;
    $$ref =~ s#\ (?=\ )#~#g; # All spaces followed by another
    $$ref =~ s#\.\ #.~#g; # For abbrs.
    
    # ^
    $$ref =~ s#\^\d+#~~~~#g;
    
    # [] (brackets of all sorts)
    $$ref =~ s#\[(\d+)#$bra[$1]#g; 
    $$ref =~ s#\](\d+)#$ket[$1]#g;
    # [ and ] must be like this: {[} for latex
    $$ref =~ s#(\[+)#{$1}#g;
    $$ref =~ s#(\]+)#{$1}#g;
    
    # # (numerical symbols) this is obviously wrong
    $$ref =~ s/#508/\ --\ /g;
    # get rid of those troublesome brackets around paragraphoi
    $$ref =~ s/\{\[\}\#6\{\]\}/\#6/g;
    $$ref =~ s/#(\d+)/$sym[$1]/g;  
    $$ref =~ s/#/\$\'\$/g;  
    
    # " (quotes)
    
    # Were the \textquotedblleft etc. forms necessary pre-ibycus4 ?
    #$$ref =~ s#([\s\n~])\"3\"3#$1\\textquotedblleft{}#g;
    $$ref =~ s#([\s\n~])\"3(\"3)?#$1`#g;
    #$$ref =~ s#\"3\"3#\\textquotedblright{}#g;
    $$ref =~ s#\"3(\"3)?#'#g;
    
    $$ref =~ s#\"1#$oddquotes[0]#g;
    $$ref =~ s#\"2#\\textrm{\\textquotedblleft}#g;
    $$ref =~ s#\"4#$oddquotes[1]#g;
    $$ref =~ s#\"5(?!\d)#\\textquoteleft{}#g;
    
    #$$ref =~ s#([\s\n~])\"6#$1<<#g; # Bug in ibycus? -- this used to work
    $$ref =~ s/([\s\n~])\"6/$1 $oddquotes[2]/g;
    $$ref =~ s/([\s\n~])\"7/$1 $oddquotes[3]/g;
    #$$ref =~ s#\"6#>>#g;
    $$ref =~ s#\"6#$oddquotes[4]#g;
    $$ref =~ s#\"7#$oddquotes[5]#g;
    
    $$ref =~ s#\"\d\d*#\\texttt{"}#g;
    #$$ref =~ s#([\s\n~])\"\d?#$1\\textquotedblleft{}#g;
    $$ref =~ s#([\s\n~])\"\d?#$1``#g;
    $$ref =~ s#\"\d?#''#g;
    $$ref =~ s#([\s\n~])\'#$1\`#g;
    
    # record separators
    if ($self->{latex_counter})
    {
        $$ref =~ s#xxbeginsamepage(?:\n\\nrm\{} \n)?#\\begin{samepage}\x06counter#g;
    }
    else
    {
        $$ref =~ s#xxbeginsamepage\n?#\\begin{samepage}#g;
    }
    $$ref =~ s#(?:\x06)?\x061endsamepage\n+#\\end{samepage}\\nopagebreak[1]#g;
    $$ref =~ s#(?:\x06)?\x061forcepagebreak\n*#\\pagebreak[3]~\\\\#g;
    $$ref =~ s#\x065#;#g;       # these were escaped above in Latin text
    $$ref =~ s#\x064#:#g;       
    $$ref =~ s#\x042#?#g;
    $$ref =~ s#s\x041#$self->{ibycus4} ? 's\'' : 's\'\''#ge; # stop spurious final sigmas
    $$ref =~ s#\x041#$self->{ibycus4} ? '{\'}' : '\'\''#ge;
    $$ref =~ s#\x043#{#g;
    $$ref =~ s#\x044#}#g;
    $$ref =~ s#\x064#\\textrm{:}#g;
    #   You can eliminate some excess whitespace by commenting this next line out
    $$ref =~ s#\n\n+#~\\nopagebreak[4]\\\\~\\nopagebreak[4]\\\\#g; # consecutive newlines
    $$ref =~ s#\n\n#~\\nopagebreak[4]\\\\#g; # eol
    $$ref =~ s#\n#~\\nopagebreak[4]\\\\\n#g; # eol
    $$ref =~ s#\x04counter#\\showcounter{}#g;
    # for early epigraphical orthography
    $$ref =~ s#([eo][)(]?)\=#\\~{$1}#g;
    $$ref =~ s#([)(]?[EO])\=#\\~{$1}#g;

}
#+end_src
**** begin_boilerplate 
Here is the stuff for the beginning and ending of latex & html files
#+begin_src perl
sub begin_boilerplate 
{
    my $self = shift;
    my ($size, $skip) = $self->{printer} ? (10, 12) : (17, 21);
    $size = $self->{latex_pointsize} if $self->{latex_pointsize};
    $skip = $self->{latex_baseskip} if $self->{latex_baseskip};
    
    my $begin_latex_boilerplate = "\\documentclass{article}";

    $begin_latex_boilerplate .= $self->{psibycus} ?
        "
\\usepackage{psibycus}" : $self->{ibycus4} ?  "
\\usepackage{ibycus4}"  : "
\\usepackage{ibygreek}" ; 
    
    $begin_latex_boilerplate .= $self->{ibycus4} ?
        "
\\DeclareFontShape{OT1}{ibycus}{bx}{n}{%
   <5> <6> <7> <8> fibb848
   <9> fibb849
  <10> <10.95> <12> <14.40> <17.28> <20.74> <24.88> fibb84}{}" 
  : "
\\DeclareFontShape{OT1}{ibycus}{bx}{n}{%
   <5> <6> <7> <8> gribyb8
   <9> gribyb9
  <10> <10.95> <12> <14.40> <17.28> <20.74> <24.88> gribyb10}{}";

    $begin_latex_boilerplate .= $self->{psibycus} ? "
\\newcommand{\\hit}[1]{\\uline{#1}}\n"            : "
\\newcommand{\\hit}[1]{\\textbf{#1}}\n";

    $begin_latex_boilerplate .= "
\\renewcommand{\\familydefault}{ibycus}
\\newcommand{\\ngk}{\\normalfont\\fontfamily{ibycus}\\fontsize{$size}{$skip pt}\\selectfont}
\\newcommand{\\nrm}{\\normalfont\\fontfamily{cmr}\\fontsize{$size}{$skip pt}\\selectfont}
\\newcommand{\\dipleperi}{\\raisebox{-.8mm}{\\makebox[0pt][l]{\\hspace{1.3mm}.}}\\raisebox{2.5mm}{\\makebox[0pt][l]{\\hspace{1.3mm}.}}\\ensuremath{>}}
\\newcommand{\\marginlabel}[1]{\\mbox{}\\marginpar{\\raggedright\\hspace{0pt}{#1}}}
\\newcommand{\\titlebox}[2]{\\fbox{#1\\begin{minipage}{\\textwidth}\\begin{tabbing}#2\\end{tabbing}\\end{minipage}}\\rule[-8mm]{0mm}{8mm}}
\\usepackage{amssymb}
\\usepackage[latin1]{inputenc}
\\usepackage{ulem}\n";
    
    $begin_latex_boilerplate .= ($self->{printer}) ?  
        '\\usepackage[nohead=true,twoside=false,top=20mm,left=10mm,bottom=5mm,right=10mm,marginpar=40mm,reversemp=true]{geometry}' 
        : 
        '\\usepackage[paperheight=80cm,paperwidth=30cm,nohead=true,twoside=false,top=10mm,left=10mm,bottom=10mm,right=10mm,marginpar=40mm,reversemp=true]{geometry}';
    
    $begin_latex_boilerplate .= ($self->{prosody}) ?  
        '\\DeclareFontFamily{OT1}{hpros}{\hyphenchar\font=-1}
\\DeclareFontShape{OT1}{hpros}{m}{n}{<-> hpros10}{}
\\newcommand{\prosody}[1]{{\fontfamily{hpros}\selectfont #1}}'
    : '';
    
    $begin_latex_boilerplate .=
        "\n\\pagestyle{empty}
\\begin{document}
\\newcounter{resultno}\\setcounter{resultno}{1}
\\newcommand{\\showcounter}{\\marginlabel{{\\hfill\\bf {[}\\arabic{resultno}{]}}}\\addtocounter{resultno}{1}}
\\frenchspacing
\\reversemarginpar
\\normalem
\\begin{flushleft}
\\nrm{}\n";

    # HTML stuff -- but not used by CGI script, which generates its own headers

    my $charset = 'iso-8859-1';
    if ($self->{encoding} =~ m/UTF-?8|Unicode/i)
    {
        $charset = 'UTF-8';
    }
    elsif ($self->{encoding} =~ m/8859.?7/i)
    {
        $charset = 'ISO-8859-7';
    } 

    my $begin_html_boilerplate = << "END_HTML";
    <HTML>
        <head>
        <meta http-equiv="charset" content="$charset">
        <title>Diogenes Result</title>
        </head>
        <body>

END_HTML

    print $begin_latex_boilerplate if $self->{output_format} =~ m/latex/;
    print $begin_html_boilerplate if $self->{output_format} =~ m/html/ 
	and not $Diogenes::Base::cgi_flag;
}
#+end_src
**** end_boilerplate
#+begin_src perl
sub end_boilerplate
{
    my $self = shift;
    my $end_latex_boilerplate = "\\end{flushleft}\n\\end{document}\n";
    my $end_html_boilerplate =  '</body></HTML>';
    
    print $end_latex_boilerplate if $self->{output_format} eq 'latex';
    print $end_html_boilerplate if $self->{output_format} eq 'html'
        and not $Diogenes::Base::cgi_flag;
    
}
#+end_src
**** simple_latex_boilerplate
#+begin_src perl
  sub simple_latex_boilerplate
  {
      # Used eg. for generating gif of individual words in word list
      my $self = shift;
      my $bp = "\n\\documentclass[12pt]{article}";
      $bp .= $self->{ibycus4} ?
	  "\\usepackage{ibycus4}" : 
	  "\\usepackage{ibygreek}";
      $bp .="\\pagestyle{empty}
  \\begin{document}
  \\fontfamily{ibycus}\\fontsize{17}{21pt}\\selectfont\n";
      return $bp;
  }
#+end_src
*** COMMENT strip_beta_formatting
#+begin_src perl
#sub strip_beta_formatting
#{#
#       my ($self, $ref) = @_;
#   warn "$$ref\n";
#       $$ref =~ s/[\x01-\x06\x0e-\x1f\x80-\xff]+/\n/g ;
#       $$ref =~ s/\$//g;
#
#}
#+end_src
*** beta_encoding_to_external
#+begin_src perl
sub beta_encoding_to_external
{
    my ($self, $ref) = @_;
    my $encoding = $self->{encoding};
    # Beta code definitions
    my %alphabet = (
	A => 'alpha', B => 'beta', G => 'gamma', D => 'delta', 
	E => 'epsilon', Z => 'zeta', H => 'eta', Q => 'theta', I => 'iota', 
	K => 'kappa', L => 'lambda', M => 'mu', N => 'nu', C => 'xi', 
	O => 'omicron', P => 'pi', R => 'rho', S => 'sigma', T => 'tau', 
	U => 'upsilon', F => 'phi', X => 'chi', 
	Y => 'psi', W => 'omega', V => 'digamma', J => 'special' );
    # Note that rho can take breathings
    my %vowel = (A => 1, E => 1, I => 1, O => 1, U => 1, H => 1, W => 1, R => 1);
    my %other = (
	' ' => 'space', '-' => 'hyphen', ',' => 'comma',
	'.' => 'period', ':' => 'raised_dot', ';' => 'semicolon',
#         '_' => 'dash',
         '_' => 'underscore', # Perseus LSJ uses _ for long vowels, so pass it thru.
	'!' => 'period', '\'' => 'apostrophe');
    # Chars (to search for) in encoding
    my $char = '[A-Z \'\-,.:;_!]';
    my $diacrits = '[)(|/\\\\=+123]*';
    
    if ($encoding{$encoding}{remap_ascii})
    {
        # These fonts cannot reliably be parsed as BETA code once the encoding
        # is done, so we might as well strip the junk out here
        $self->beta_formatting_to_ascii($ref);
    }

    # Lunate sigmas are ``obsolete'' according to the TLG BETA spec.
    $$ref =~ s#S3#S#g;
    # Force final sigmas. (watch out for things like mes<s>on, which shouldn't
    # become final -- I'm not sure that there's much one can do there)
    $$ref =~ s#(?<!\*)S(?![123A-Z)(|/\\=+\'?])#S2#g; 
    $$ref =~ s#(?<!\*)S~(?![123A-Z)(|/\\=+\'?])#S2~#g; 
    
    if (ref $encoding{$encoding}{pre_match} eq 'CODE')
    {   # Code to execute before the match
	$encoding{$encoding}{pre_match}->($ref);
    }
    
    # For encodings close to BETA, we can do translation directly, by
    # giving a code ref, rather than a char map
    if (ref $encoding{$encoding}{sub} eq 'CODE')
    {       
	$encoding{$encoding}{sub}->($ref);
    }
    else
    {
	# This code uses the info in the Diogenes.map file to translate BETA
	# into an arbitrary Greek encoding.  All of this code is eval'ed at each
        # match of the regex, for each char with its diacrits:
	$$ref =~ s!(\*$diacrits)?($char)($diacrits)!
                                my ($a, $b, $c) = ($1, $2, $3);
                                if ($a and $c)
                                {       # Caps and trailing diacrits
                                        if        ($b eq 'S' and $c eq '2') { $c = ''; } # Oops. final sigma
                                        elsif ($c eq '|' ) { $a .= '|'; } # Iota "subscript" after a cap
                                        elsif ($a =~ m/^\*/) {$a .= $c} # In all caps titles, sometimes accents are put after the letter
                                        else  { warn "Unknown BETA code: $a$b$c"; }
                                }
                                my $code = $alphabet{$b} || '';
                                my $pre = '';
                                my $post = '';
                                if ($a and not $encoding{$encoding}{caps_with_diacrits})
                                {   # Magiscule (with leading diacrits for vowels as separate
                                        # glyphs in this encoding)
                                        $code =~ s/^(.)/\u$1/;
                                        if ($vowel{$b})
                                        {
                                                my @codes = ();
                                                $a =~ /\+/ and push @codes, 'diaer';
                                                ($a =~ /\)/ and push @codes, 'lenis') or
                                                ($a =~ /\(/ and push @codes, 'asper');
                                                ($a =~ /\// and push @codes, 'oxy') or
                                                ($a =~ /\\/ and push @codes, 'bary') or
                                                ($a =~ /\=/ and push @codes, 'peri');
                                                my $loner = join '_', @codes; 
                                                $pre = $encoding{$encoding}{$loner} || '';
                                                warn 'No mapping exists for BETA code (pre) '.
                                                        ($a||'').($b||'').($c||'')." in encoding $encoding.\n" 
                                                        if (not $pre) and (length $a > 1);
                                        }
                                }
                                elsif ($a)
                                {   # Magiscule (vowels combined with leading diacrits as 
                                        # fully-fledged, composite glyphs in this encoding)
                                        $code =~ s/^(.)/\u$1/;
                                        if ($vowel{$b})
                                        {
                                                $a =~ /\+/ and $code .= '_diaer';
                                                ($a =~ /\)/ and $code .= '_lenis') or
                                                ($a =~ /\(/ and $code .= '_asper');
                                                ($a =~ /\// and $code .= '_oxy')  or
                                                ($a =~ /\\/ and $code .= '_bary') or
                                                ($a =~ /\=/ and $code .= '_peri');
                                                $a =~ /\|/ and $code .= '_isub';
                                        }
                                }
                                elsif ($c and $vowel{$b})
                                {       # Miniscule vowels with (trailing) diacrits
                                        $c =~ /\+/ and $code .= '_diaer';
                                        ($c =~ /\)/ and $code .= '_lenis') or
                                        ($c =~ /\(/ and $code .= '_asper');
                                        ($c =~ /\// and $code .= '_oxy')  or
                                        ($c =~ /\\/ and $code .= '_bary') or
                                        ($c =~ /\=/ and $code .= '_peri');
                                        $c =~ /\|/ and $code .= '_isub';
                                }
                                elsif ($b eq 'S' and $c)
                                {
                                        ($c eq '2' and $code .= '_final') or
                                        ($c eq '3' and $code .= '_lunate');
                                } 
                                elsif ($c =~ m/^\d+$/)
                                {       # We've picked up some numbers spuriously (123, no S)
                                        $post = $b.$c;
                                }
                                $code = $other{$b} if $b and $other{$b}; 

                                $post = $encoding{$encoding}{$code} unless $post;
                                warn 'No mapping exists for BETA code (post) '.
                                        ($a||'').($b||'').($c||'')." in encoding $encoding.\n" unless $post;
                                $post ? $pre.$post : $a.$b.$c;
                                !gex;
    }
        
    if (ref $encoding{$encoding}{post_match} eq 'CODE')
    {   # Code to execute after the match
        $encoding{$encoding}{post_match}->($ref);
    }

}
#+end_src
*** Koptisch
**** coptic_with_latin
#+begin_src perl
sub coptic_with_latin
{
    my ($self, $ref) = @_;
    $$ref =~ s/([^\&]*)([^\$]*)/
        my $cp = $1 || '';
    if ($cp)
    {
        $self->coptic_handler(\$cp);
    }
    my $lt = $2 || '';
    if ($lt)
    {
        $lt =~ s!\&(\d+)!\& $1!g; # horribleness
                                                $self->{latin_handler}->(\$lt);
                                        }
                                        $cp.$lt;
                                        /gex;
}
#+end_src
**** coptic_handler
#+begin_src perl
sub coptic_handler
{
    my ($self, $ref) = @_;
    my $encoding = $self->{coptic_encoding};
    
    return if $self->{coptic_encoding} eq 'beta';
    
    my %alphabet = ( A => 'alpha', B => 'beta', G => 'gamma', D => 'delta', 
                     E => 'epsilon', Z => 'zeta', H => 'eta', Q => 'theta', I => 'iota', 
                     K => 'kappa', L => 'lambda', M => 'mu', N => 'nu', C => 'xi', 
                     O => 'omicron', P => 'pi', R => 'rho', S => 'sigma', T => 'tau', 
                     U => 'upsilon', F => 'phi', X => 'chi', Y => 'psi', W => 'omega', V => 'digamma',
                     s => 'shei', f => 'fei', h => 'hori', t => 'dei', j => 'gangia', g => 'shima');
    # Note that rho can take breathings
    my %other = (' ' => 'space', '-' => 'hyphen', ',' => 'comma',
                 '.' => 'period', ':' => 'raised_dot', ';' => 'semicolon', '_' => 'dash',
                 '!' => 'period', '\'' => 'apostrophe', '/' => 'forward_slash');
    # Chars (to search for) in encoding
    my $char = '[A-Z \'\-,.:;_!sfhtjg/]';
    my $diacrits = '[=+?]*';
    
    if ($coptic_encoding{$encoding}{remap_ascii})
{
    # These fonts cannot reliably be parsed as BETA code once the encoding
    # is done, so we might as well strip the junk out here
    $self->beta_formatting_to_ascii($ref);
}
# Code designed for Greek captures \ within hit,
# but here it really belongs to the following letter
$$ref =~ s/~hit~([^~]+)\\~/~hit~$1~\\/g;
$$ref =~ s/\\~hit~([^~]+)~/~hit~\\$1~\\/g;
# For greek, the lowercase protects "hit" from conversion, but not for coptic.
$$ref =~ s/~hit~/\x08\x08/g;
if (ref $coptic_encoding{$encoding}{pre_match} eq 'CODE')
{       # Code to execute before the match
    $coptic_encoding{$encoding}{pre_match}->($ref);
}

# For encodings close to BETA, we can do translation directly, by
# giving a code ref, rather than a char map
if (ref $coptic_encoding{$encoding}{sub} eq 'CODE')
{       
    $coptic_encoding{$encoding}{sub}->($ref);
}
else
{
    $$ref =~ s!(\\?)($char)($diacrits)!
                            my ($a, $b, $c) = ($1, $2, $3);
                            my $post = '';
                            my $code = $alphabet{$b} || '';
                            $code = $other{$b} if $b and $other{$b}; 
                            if ($b and $c)
                            {       # Miniscule vowels with (trailing) diacrits
                                    $c =~ /\+/ and $code .= '_diaer';
                                    $c =~ /\=/ and $code .= '_peri';
                            }
                            $post .= $coptic_encoding{$encoding}{overline}
                                         if $a and $encoding =~ m/utf/i; # combining overline
                            $post .= $encoding =~ m/utf/i ? '̣' : '?' if $c =~ m/\?/;
                            my $char = $coptic_encoding{$encoding}{$code} || '';
                            warn 'No mapping exists for BETA (Coptic) code '.
                                    ($a||'').($b||'').($c||'')." in encoding $encoding.\n" unless $char;
#                             print STDERR ">>$char.$post\n";
                            $char.$post;
                            !gex;
    }
    
    if (ref $coptic_encoding{$encoding}{post_match} eq 'CODE')
    {   # Code to execute after the match
        $coptic_encoding{$encoding}{post_match}->($ref);
    }
$$ref =~ s/\x08\x08/~hit~/g;

}
#+end_src
** Bits and pieces
*** numerically
#+begin_src perl
  sub numerically { $a <=> $b; }
#+end_src
*** barf
#+begin_src perl
sub barf 
{
    my $self = shift;
    if ($self and $self->{dump_file})
    {
        use Data::Dumper;
        open DUMP, ">$self->{dump_file}" or die ("Can't open dump file");
        #print DUMP Data::Dumper->Dump ([$self], ['Diogenes']);
        print DUMP "\n\n#####################################################\n\n";
        print DUMP ${ $self->{buf} } if defined $self->{buf}; 
        close DUMP or die ("Can't close dump file");
    }
    # We die here, and hope that the server will spawn another child.
    confess shift;
}
#+end_src
** END
#+begin_src perl
1;
#+end_src

* Diogenes::Search
** NOTITZEN
*** do_search ruft prep auf.
*** 

** Präambel
#+begin_src perl
package Diogenes::Search;
use Diogenes::Base qw(%work %author %work_start_block %level_label %context);
@Diogenes::Search::ISA = ('Diogenes::Base');
#+end_src
** do_search
#+begin_src perl
sub do_search 
{
    my $self = shift;
    $self->{current_chunk} = 0;
    # Do the search (brute force).
    $self->begin_boilerplate;
    my $retval = $self->pgrep;
    $self->print_totals($retval);
    $self->end_boilerplate;
    return $retval;
}
#+end_src
** pgrep
Pgrep führt die Suche durch und legt die Ergebnisse als Offsets
(Zeichenweise) von $buf in $self->{seen}{$ARGV} und
$self->{match_start}{$ARGV} (bzw. $author statt $ARGV für Teilsuchen)
ab. Die Weiterverarbeitung der Ergebnisse erfolgt durch extract_hits.
*** CODE                                                 
#+begin_src perl
# Method that actually does the brute-force searches.         
# For an explanation of the approach using @ARGV, see p. 226  
# of /Programming Perl/, 2nd edition.                         
#                                                             
# It takes a pattern and returns a hash of filenames, each    
# pointing to an array containing the offsets of the matches. 

sub pgrep 
{
    my $self = shift;
    chdir "$self->{cdrom_dir}" or 
        $self->barf ("cannot chdir to $self->{cdrom_dir} ($!)");
    print STDERR "\nCurrent dir: ",`pwd`, 
    "Prefix: $self->{file_prefix}\n\n" if $self->{debug};
    
    unless ($self->{filtered}) 
    {
        if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
            @ARGV = @{ $self->{tlg_ordered_filenames} };
        }
        else {
            # In theory, the following code is platform independent for
            # achitectures (ie. Mac) that don't like unix-shell style globbing.
            opendir (INP_DIR, "$self->{cdrom_dir}") or
                $self->barf ("Cannot open $self->{cdrom_dir} ($!)");
            @ARGV = sort grep {/$self->{file_prefix}.+$self->{txt_suffix}/i} readdir INP_DIR;
            closedir INP_DIR;
        }
    }
    
    $self->barf ("I can't find any data files!") 
        unless @ARGV or $self->{req_auth_wk};
    local $/;
    undef $/;
    
    my $final_pass;
    if ($self->{repeat_matches}) {
        # min_matches is irrelevant for passes in this case
        $final_pass = @{ $self->{pattern_list} } - 1
    }
    else {
        $final_pass = $self->{numeric_context} ?
            @{ $self->{pattern_list} } - 1
            : @{ $self->{pattern_list} } - $self->{min_matches_int};
    }
    print STDERR "FP: $final_pass\n" if $self->{debug};
    my ($buf, $i);
    $self->{buf} = \$buf;
    $self->read_blacklist if $self->{blacklist_file};
    $self->read_works_blacklist if $self->{blacklisted_works_file};
    my %already_seen = map { $_ => 1 } @{ $self->{seen_author_list} };

    if (@ARGV)
    {
        # Do the (full-file) search.  
        #print Data::Dumper->Dump(\@ARGV);
        while ($buf = <>) 
        {
            my $auth_num = $ARGV;
            $auth_num =~ tr/0-9//cds;
            next if $already_seen{$auth_num};

            # Search for the minimum necessary number of patterns
            for (   my $pass = 0; $pass <= $final_pass; $pass++  )
            {
                # Before each pass, make sure that the browser is still listening;
                # SIGPIPE does not work under MS Windows
                my $success = print ("\0");
                if (not $success) {
                    print STDERR "Test print failed! $!\n";
                    # die does not exit server, but halts eval of cgi script
                    die if $Diogenes_Daemon::flag;
                } else {
                    # print STDERR "OK!\n" if $self->{debug};
                }
                my $pattern = @{ $self->{pattern_list} }[$pass];
                # clear the last search
                undef $self->{seen}{$ARGV};
                undef $self->{match_start}{$ARGV};
                while ($buf =~ m#$pattern#g) {
                    push @{ $self->{seen}{$ARGV} }, pos $buf;
                    push @{ $self->{match_start}{$ARGV} }, $-[0];
                }
                if ($self->{seen}{$ARGV})
                {
                    $self->parse_idt($auth_num);
                    $self->extract_hits($ARGV);
                }
            }
            push @{$self->{seen_author_list}}, $auth_num;
            return $self->{seen_author_list} if $self->{current_chunk} > $self->{chunk_size};
        } 
    }
    
    # Now search in any files that are to be read only in part.
    
    my @ordered_authors = ();
    if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
        # Do chronological sort of authors for TLG
        foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
            my $short_num = $num;
            $short_num =~ s/^0+//g;
            if (exists $self->{req_auth_wk}{$num}) {
                push @ordered_authors, $num;
            }
            elsif (exists $self->{req_auth_wk}{$short_num}) {
                push @ordered_authors, $short_num;
            }
        }
    }
    else {
        # Just do ordinary sort
        @ordered_authors = sort numerically (keys %{ $self->{req_auth_wk} });
    }

    # Read in only the desired blocks from files for which only certain works 
    # were requested.

    my ($filename, $offset, $start_block, $end_block, $auth_num);
    foreach my $author (@ordered_authors)
    {
        # pad with leading zeroes 
        $auth_num = sprintf '%04d', $author;
        next if $already_seen{$auth_num};
        
        # parse .idt file
        my $real_num = $self->parse_idt($auth_num);
        
        $filename = $self->{file_prefix} . $auth_num;
                
        # open the .txt file 
        $filename .= $self->{txt_suffix};
        open INP, "$self->{cdrom_dir}$filename" or $self->barf("Couln't open $filename!");
        binmode INP;
                
        # loop through each requested work
        foreach my $work (sort keys %{ $self->{req_auth_wk}{$author} }) 
        {
            # get only those blocks of the file containing the work in question
            $start_block = $work_start_block{$self->{type}}{$real_num}{$work};
            $offset = $start_block << 13;
            seek INP, $offset, 0;
            my $next = $work;
            $next++;
            if (defined ($work_start_block{$self->{type}}{$author}{$next})) 
            {
                $end_block = $work_start_block{$self->{type}}{$author}{$next};
                read INP, $buf, (($end_block - $start_block + 1) << 13) or
                    $self->barf ("Couln't read from $filename");
            }
            else 
            {
                $buf = <INP>;
                $self->barf ("Couln't read the rest of $filename!") unless
                    defined $buf;
            }
            $self->{current_work} = $work;  
            
            # This does the search, storing the locations in %seen
            # Search for the minimum necessary number of patterns
            for (   my $pass = 0; $pass <= $final_pass; $pass++  )
              {
                my $success = print ("\0");
                if (not $success) {
                    print STDERR "Test print failed! $!\n";
                    die if $Diogenes_Daemon::flag;
                }
                my $pattern = @{ $self->{pattern_list} }[$pass];
                # clear the last search
                undef $self->{seen}{$author};
                undef $self->{match_start}{$author};
                while ($buf =~ m#$pattern#g) {
                    push @{ $self->{seen}{$author} }, (pos $buf);
                    push @{ $self->{match_start}{$author} }, $-[0];
                }
                $self->extract_hits($author);

            }
        }
        close INP or $self->barf("Couln't close $filename!");
        push @{$self->{seen_authors}}, $auth_num;
        return $self->{seen_authors} if $self->{current_chunk} > $self->{chunk_size};
    }
    
    return 'done';
}
#+end_src
*** Analyse
**** Wechsel ins TLG-Verzeichnis
#+begin_src perl
    my $self = shift;
    chdir "$self->{cdrom_dir}" or 
        $self->barf ("cannot chdir to $self->{cdrom_dir} ($!)");
    print STDERR "\nCurrent dir: ",`pwd`, 
    "Prefix: $self->{file_prefix}\n\n" if $self->{debug};
#+end_src
**** @ARGV befüllt wenn !$self->{filtered} 
#+begin_src perl
    unless ($self->{filtered}) 
    {
        if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
            @ARGV = @{ $self->{tlg_ordered_filenames} };
        }
        else {
            # In theory, the following code is platform independent for
            # achitectures (ie. Mac) that don't like unix-shell style globbing.
            opendir (INP_DIR, "$self->{cdrom_dir}") or
                $self->barf ("Cannot open $self->{cdrom_dir} ($!)");
            @ARGV = sort grep {/$self->{file_prefix}.+$self->{txt_suffix}/i} readdir INP_DIR;
            closedir INP_DIR;
        }
    }
#+end_src
**** Fehlerbehandlung
Eine Suche kann auf zwei Weisen beschränkt werden: Dateien, die zu
ihrer Gänze durchsucht werden sollen, werden in @ARGV abgelegt;
Dateien, die nur teilweise durchsucht werden können, befinden sich in
req_auth_wk.

#+begin_src perl
    $self->barf ("I can't find any data files!") 
        unless @ARGV or $self->{req_auth_wk};
#+end_src

**** $/
#+begin_src perl
    local $/;
    undef $/;
#+end_src

**** final_pass
Indexnummer des letzten Durchlaufs: Bei einem einfachen Muster ist
dies 0, da insgesamt nur ein Durchlauf benötigt wird.
#+begin_src perl
    my $final_pass;
    if ($self->{repeat_matches}) {
        # min_matches is irrelevant for passes in this case
        $final_pass = @{ $self->{pattern_list} } - 1
    }
    else {
        $final_pass = $self->{numeric_context} ?
            @{ $self->{pattern_list} } - 1
            : @{ $self->{pattern_list} } - $self->{min_matches_int};
    }
    print STDERR "FP: $final_pass\n" if $self->{debug};
#+end_src

**** $buf & $i
$buf enthält die aktuelle Datei als String in ihrer Gänze. Indem diese
in $self->{buf} referenziert wird, bleibt sie für die
Weiterbearbeitung durch &extract_hits und dann &print_output erhalten.
#+begin_src perl
    my ($buf, $i);
    $self->{buf} = \$buf;
#+end_src

**** blacklist
#+begin_src perl
    $self->read_blacklist if $self->{blacklist_file};
    $self->read_works_blacklist if $self->{blacklisted_works_file};
#+end_src

**** %already_seen
#+begin_src perl
    my %already_seen = map { $_ => 1 } @{ $self->{seen_author_list} };
#+end_src

**** Suche in ganzen Dateien
#+begin_src perl
    if (@ARGV)
    {
        # Do the (full-file) search.  
        #print Data::Dumper->Dump(\@ARGV);
        while ($buf = <>) 
        {
#+end_src
***** $auth_num
#+begin_src perl
            my $auth_num = $ARGV;
            $auth_num =~ tr/0-9//cds;
            next if $already_seen{$auth_num};
#+end_src
***** Suchdurchlaufschleife
#+begin_src perl
            # Search for the minimum necessary number of patterns
            for (   my $pass = 0; $pass <= $final_pass; $pass++  )
            {
#+end_src
****** Nullbyte, um den Browser bei Laune zu halten
#+begin_src perl
                # Before each pass, make sure that the browser is still listening;
                # SIGPIPE does not work under MS Windows
                my $success = print ("\0");
                if (not $success) {
                    print STDERR "Test print failed! $!\n";
                    # die does not exit server, but halts eval of cgi script
                    die if $Diogenes_Daemon::flag;
                } else {
                    # print STDERR "OK!\n" if $self->{debug};
                }
#+end_src
****** Suche
@- enthält den Beginn des Matches und der Submaches,
@+ das Ende. $+[0] == pos.

N.B.: parse_idt macht seine Arbeit nur einmal. Wenn die Datei bereits
ausgelesen ist und die Daten in %author{tlg}{nummer} abgelegt wurden,
gibt parse_idt einfach nur die übergebene Autornummer zurück.
#+begin_src perl
                my $pattern = @{ $self->{pattern_list} }[$pass];
                # clear the last search
                undef $self->{seen}{$ARGV};
                undef $self->{match_start}{$ARGV};
                while ($buf =~ m#$pattern#g) {
                    push @{ $self->{seen}{$ARGV} }, pos $buf;
                    push @{ $self->{match_start}{$ARGV} }, $-[0];
                }
                if ($self->{seen}{$ARGV})
                {
                    $self->parse_idt($auth_num);
                    $self->extract_hits($ARGV);
                }
#+end_src
***** Erledigte Autoren werden in $self->{seen_author_list} abgelegt
chunk_size ist 1000000. current_chunk wird in do_search mit 0 initiiert und bei print_output um length($$ref) erweitert.
#+begin_src perl
            push @{$self->{seen_author_list}}, $auth_num;
            return $self->{seen_author_list} if $self->{current_chunk} > $self->{chunk_size};
        } 
    }
#+end_src
**** Teilsuche
***** Sortierung der Autoren (@ordered_authors)
#+begin_src perl
    # Now search in any files that are to be read only in part.
    my @ordered_authors = ();
    if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
        # Do chronological sort of authors for TLG
        foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
            my $short_num = $num;
            $short_num =~ s/^0+//g;
            if (exists $self->{req_auth_wk}{$num}) {
                push @ordered_authors, $num;
            }
            elsif (exists $self->{req_auth_wk}{$short_num}) {
                push @ordered_authors, $short_num;
            }
        }
    }
    else {
        # Just do ordinary sort
        @ordered_authors = sort numerically (keys %{ $self->{req_auth_wk} });
    }
#+end_src
    
***** Hauptschleife
#+begin_src perl
    # Read in only the desired blocks from files for which only certain works 
    # were requested.

    my ($filename, $offset, $start_block, $end_block, $auth_num);
    foreach my $author (@ordered_authors)
    {
        # pad with leading zeroes 
        $auth_num = sprintf '%04d', $author;
        next if $already_seen{$auth_num};
#+end_src
        
****** Einlesen von .idt
#+begin_src perl
        # parse .idt file
        my $real_num = $self->parse_idt($auth_num);
#+end_src
     
****** Einlesen von .txt   
#+begin_src perl
        $filename = $self->{file_prefix} . $auth_num;
                
        # open the .txt file 
        $filename .= $self->{txt_suffix};
        open INP, "$self->{cdrom_dir}$filename" or $self->barf("Couln't open $filename!");
        binmode INP;
#+end_src
      
****** Abarbeiten der angefragten Werke         
#+begin_src 
        # loop through each requested work
        foreach my $work (sort keys %{ $self->{req_auth_wk}{$author} }) 
        {
#+end_src
	
******* start_block und end_block
#+begin_src perl
            # get only those blocks of the file containing the work in question
            $start_block = $work_start_block{$self->{type}}{$real_num}{$work};
            $offset = $start_block << 13;
            seek INP, $offset, 0;
            my $next = $work;
            $next++;
            if (defined ($work_start_block{$self->{type}}{$author}{$next})) 
            {
                $end_block = $work_start_block{$self->{type}}{$author}{$next};
                read INP, $buf, (($end_block - $start_block + 1) << 13) or
                    $self->barf ("Couln't read from $filename");
            }
            else 
            {
                $buf = <INP>;
                $self->barf ("Couln't read the rest of $filename!") unless
                    defined $buf;
            }
            $self->{current_work} = $work;  
#+end_src
            
******* Suche
#+begin_src perl
            # This does the search, storing the locations in %seen
            # Search for the minimum necessary number of patterns
            for (   my $pass = 0; $pass <= $final_pass; $pass++  )
              {
                my $success = print ("\0");
                if (not $success) {
                    print STDERR "Test print failed! $!\n";
                    die if $Diogenes_Daemon::flag;
                }
                my $pattern = @{ $self->{pattern_list} }[$pass];
                # clear the last search
                undef $self->{seen}{$author};
                undef $self->{match_start}{$author};
                while ($buf =~ m#$pattern#g) {
                    push @{ $self->{seen}{$author} }, (pos $buf);
                    push @{ $self->{match_start}{$author} }, $-[0];
                }
                $self->extract_hits($author);

            }
        }
#+end_src

****** Nachbearbeitung und Ende
#+begin_src perl
        close INP or $self->barf("Couln't close $filename!");
        push @{$self->{seen_authors}}, $auth_num;
        return $self->{seen_authors} if $self->{current_chunk} > $self->{chunk_size};
    }
    
    return 'done';
}
#+end_src

** print_totals
Method to print the total hits in a brute force search. 
                                                        
#+begin_src perl
sub print_totals 
{
    my $self = shift;
    my $message = shift;
    $chunk_message = '' if $message ne 'done';
    my $out = '';
    $out .= '\nrm{}' if $self->{output_format} eq 'latex';
    if ($message eq 'done') {
        $out .= "\n\&Passages found: " . ($self->{hits} || 0) ."\n";
    }
    else {
        $out .= "\n\&Cumulative total of passages found so far: " . ($self->{hits} || 0) ."\n";
    }
    $out .= '(' . $self->{blacklisted_hits} .
        " passages suppressed from blacklisted works)\n" 
        if $self->{blacklisted_hits};
    $out .= '(' . $self->{blacklisted_files} .
        " blacklisted authors were not searched at all)\n" 
        if $self->{blacklisted_files};
    $out .= "\n";
    $self->print_output(\$out);
}
#+end_src

** Non-unicode, various Latin transliterations
*** make_greek_patterns_translit
#+begin_src perl
sub make_greek_patterns_translit {
    my $self = shift;
    $self->{reject_pattern} =
        $self->make_greek_pattern_from_translit($self->{reject_pattern});
    foreach my $pat (@{ $self->{pattern_list} }) {
        $pat = $self->make_greek_pattern_from_translit($pat);
    }
}
#+end_src
*** make_greek_pattern_from_translit
#+begin_src perl
sub make_greek_pattern_from_translit { 
    my ($self, $pat) = @_;
    if ($self->{input_pure}) {
        return $pat;
    }
    elsif ($self->{input_raw}) {
        return quotemeta $pat;
    }
    elsif ($self->{input_beta}) {
        return $self->make_strict_greek_pattern ($pat);
    }
    else {
        # Fall back to Perseus transliteration
        return $self->perseus_to_beta($pat);
    }
}
#+end_src
*** make_strict_greek_pattern
Construct a regexp to search for Greek, with accents and breathings
significant.  Input is Beta code with diacritics.  Uses the code for
word-list searches.

#+begin_src perl
sub make_strict_greek_pattern
{
    my ($self, $pat) = @_;
    $pat =~ tr/a-z/A-Z/;                    # upcap all letters
    $pat =~ s#\\#/#g;                       # normalize barytone accents
    $pat =~ s#\s+# #g;                      # normalize spacing

    my @pats;
    my $pattern;
    if ($pat =~ m/\s/) {
        my @parts = split /\s+/, $pat;
        foreach my $part (@parts) {
            my ($part_pat, undef) =
                Diogenes::Indexed::make_tlg_regexp($self, $part, (not $begin), (not $end));
            push @pats, $part_pat;
        }
        $pattern = join '\s+[^A-Z]*', @pats;
    }
    else {
        ($pattern, undef) =
            Diogenes::Indexed::make_tlg_regexp($self, $pat, (not $begin), (not $end));
    }

    s/\x073(?!\?)/(?:/g; # turn ( into (?: for speed
    s/\x074/)/g;
    return $pattern;
}
#+end_src
*** make_latin_pattern
#+begin_src perl
sub make_latin_pattern
{
    my $self = shift;
        
    $self->{reject_pattern} = $self->latin_pattern($self->{reject_pattern});
    foreach my $pat (@{ $self->{pattern_list} })
    {
        if ($self->{input_pure}) 
        { 
            $pat = $pat;
        }
        elsif ($self->{input_raw}) 
        { 
            $pat = quotemeta $pat;
            $pat = $pat;
        }
        else 
        {
            $pat = $self->latin_pattern($pat);
        }
    }
}
#+end_src
*** latin_pattern
#+begin_src perl
sub latin_pattern
{
    my $self = shift;
    my $pat = shift;
    return $pat unless $pat;
    
    # We get (in Cicero) both auctio- @1 .nem and auctio- @1.nem
    my $non_alpha = '\\x00-\\x1f\\x21-\\x40\\x5b-\\x60\\x7b-\\xff';
    my $non_alpha_with_space = '\\x00-\\x40\\x5b-\\x60\\x7b-\\xff';
    # This code has been designed so that it will not disturb certain
    # Perl regexp constructs, such as char classes, and parens and | 
    # (alternation).  But many other types of input it may well mangle.
    
    # Turn every letter and every char class into a case insensitive
    # char class.
    $pat =~ s#([a-zA-Z]|\[[^\]]*\])#
                my $rep = $1;
                $rep =~ tr/\[\]//d;
                $rep =~ s/[ij]/ij/;
                $rep =~ s/[IJ]/IJ/;
                $rep =~ s/[uv]/uv/;
                $rep =~ s/[UV]/UV/;
                '['."\L$rep\E\U$rep\E".']'#gex; 
    
    print STDERR "Char classes: $pat\n" if $self->{debug};
                                
    # Add non-alphabetics
    # We have to allow spaces after hyphens and where there's a space
    # in the input pattern, because of e.g. page-breaks that intervene
    # like so: auctio- @1 .nem 
    $pat =~ 
        s/(\[[^\]]*\][*+?]?)(?!$)/$1(?:-\[$non_alpha_with_space\]\*|\[$non_alpha\]\*)/g;
    # spaces at the start + some lookbehind
    $pat =~ s/^\s+/(?<![A-Za-z])(?<!\-[\\x80-\\xff])(?<!\-[\\x80-\\xff][\\x80-\\xff])/g; 
    $pat =~ s/\s+$/(?![A-Za-z])/g;                     # spaces at the end
    $pat =~ s/(?<!^)(?<!-)\s+/\\s+\[$non_alpha_with_space\]\*/g;  # other spaces (not at start or end)
    $pat =~ s/\((?!\?)/(?:/g;                          # turn ( into (?: for speed
    return $pat;
}
#+end_src
*** perseus_to_beta                                                                    
Subroutine to convert latinized greek to a useful search pattern. 
Input is in Perseus format, output is TLG BETA code regexp.       

#+begin_src perl
sub perseus_to_beta 
{
    my $self = shift;
    $_ = shift;
    return $_ unless $_;

    s#\(#\x073#g;                                                       # protect parens
    s#\)#\x074#g;

    die "Invalid letter $1 used in Perseus-style transliteration\n" if m/([wyjqv])/;
    die "Invalid letter c used in Perseus-style transliteration\n" if m/c(?!h)/;
    # This is now entirely case-insensitive (and ignorant of accent).
    # The business of having accents and breathings before caps
    # made it nearly impossible to do case- sensitive searches reliably, and
    # the best candidate regeps were an order of magnitude slower.
        
    s/\b([aeêioôu\xea\xf4])/\x071$1/gi;         # mark where non-rough breathing goes
    s/(?<!\w)h/\x072/gi;                        # mark where rough breathing goes

#       #s#\b([aeêioôu^]+)(?!\+)#(?:\\\)[\\/|+=]*$1|$1\\\))#gi;         # initial vowel(s), smooth
#
#       s#^h# h#; # If there's a rough breathing at the start of the pattern, then we assume it's the start of a word
#   s#(\s)([aeêioôu^]+)(?!\+)#$1(?:(?<!\\\([\\/|+=][\\/|+=])(?<!\\\([\\/|+=])(?<!\\\()$2(?!\\\())#gi;           # initial vowel(s), smooth
#       s#(\s)h([aeiou^]+)(?!\+)#$1(?:\\\([\\/|+=]*$2|$2\\\()#gi;             # initial vowel(s), rough breathing
#   s#\bh##; # Ignore breathings
    
    s/[eE]\^/H/g;                                           # eta
    s/[êÊ\xea\xca]/H/g;                                             # ditto
    s/[tT]h/Q/g;                                            # theta
    s/x/C/g;                                                # xi
    s/[pP]h/F/g;                                            # phi
    s/[cC]h/X/g;                                            # chi
    s/[pP]s/Y/g;                                            # psi
    s/[oO]\^/W/g;                                           # omega
    s/[ôÔ\xf4\xd4]/W/g;                                             # ditto
        
    return $self->make_loose_greek_pattern($_);              
}
#+end_src
*** my $rough_breathing & my $smooth_breathing
# Make a regexp for searching greek, not sensitive to accents and
# case.  Input is beta-code, with diacrits removed.  Smooth and rough
# breathing should be marked with \x071 and \x072 respectively at the
# start of the word, and parens by \x073 and \x074.

# h looks ahead for a rough breathing somewhere in the following group
# of vowels, or before it as capitalized words or in the word (EA`N.
# In lookbehind, allow for other diacrits to intervene

#+begin_src perl
my $rough_breathing =  q{(?:(?<=\()|(?<=\([^A-Z])|(?<=\([^A-Z][^A-Z])|(?=[AEHIOWU/\\\\)=+?!|']+\())};    
my $smooth_breathing =  q{(?:(?<=\))|(?<=\)[^A-Z])|(?<=\)[^A-Z][^A-Z])|(?=[AEHIOWU/\\\\)=+?!|']+\)))};    
# smooth is lack of rough
# my $smooth_breathing = q{(?:(?<!\()(?<!\([^A-Z])(?<!\([^A-Z][^A-Z])(?![AEHIOWU/\\\\)=+?!|']+\())}; 
#+end_src
*** make_loose_greek_pattern

#+begin_src perl
sub make_loose_greek_pattern {
    my $self = shift;
    $_ = shift;
    tr/a-z/A-Z/;                                            # upcap all 

    my $non_alpha = '\\x00-\\x1f\\x21-\\x40\\x5b-\\x5e\\x60\\x7b-\\xff';
    my $non_alpha_and_space = '\\x00-\\x40\\x5b-\\x5e\\x60\\x7b-\\xff';
    my $non_alpha_nor_asterisk = '\\x00-\\x1f\\x21-\\x29\\x2b-\\x40\\x5b-\\x5e\\x60\\x7b-\\xff';
    # The following allows trailing accents, hyphens, markup, etc. after letters, char classes and rough breathing
#s/(\[[^\]]*\][*+?]?|\(\?:(?:[^\\)]|\\\)|\\)*\)|[A-Z])/$1\[\\x00-\\x1f\\x21-\\x40\\x5b-\\x60\\x7b-\\xff\]\*/g;
#s/([^A-Z ]*[A-Z ][^A-Z ]*)/$1\[\\x00-\\x1f\\x21-\\x40\\x5b-\\x60\\x7b-\\xff\]\*/g;

# Put non-alpha after all chars.  Allow spaces where there is a hyphenation (page-break markup)

#     s/([^A-Z ]*[A-Z][^A-Z ]*)/$1\[$non_alpha\]\*/g;
      s/([^A-Z ]*[A-Z][^A-Z ]*)/$1(?:-\[$non_alpha_and_space\]\*|\[$non_alpha\]\*)/g;

# A space in the middle can gobble extra spaces for things like " @1 "
s/([^A-Z ]*[ ][^A-Z ]*)(?!$)/$1\[$non_alpha_and_space\]\*/g;
s/([^A-Z ]*[ ][^A-Z ]*)(?=$)/$1\[$non_alpha_nor_asterisk\]\*/g;
#s/(?<!^)\s+(?!$)/\[^A-Z\]/g;           # other spaces (not at start or end)
    # spaces at the start (the lookbehind tries to reject hyphenation fragments and
    # mid-word matches after accents, but we can't just reject on preceding accents,
    # since capitalized words do have accents preceding, and *must* not be rejected).
        s#^\s+#(?<![A-Z])(?<!\-[\\x80-\\xff])(?<![A-Z][)(\\/|+=])(?<![A-Z][)(\\/|+=][)(\\/|+=])(?<!\-[\\x80-\\xff][\\x80-\\xff])#g; 
#       s/\s+$/(?=[^A-Z])/g;            # spaces at the end -- this doesn't work -- previous glob backtracks off
#        s/\s+$/[ \\]}&\$\%"#\@>]/g;     # spaces at the end -- doesn't match
   
    #my $diacrits = '\/\\\\\=\+\?\!\)\(\|\'';
    
    s#\x072#$rough_breathing#g;    
    s#\x071#$smooth_breathing#g;

    s/\x073(?!\?)/(?:/g;                                # turn ( into (?: for speed
    s/\x074/)/g;                

    return $_;
}
#+end_src
*** simple_latin_to_beta 
Latin transliteration input, except without turning the greek into a
regexp (Used on input destined for the word list.)

#+begin_src perl
sub simple_latin_to_beta 
{
    my $self = shift;
    $_ = shift;
    return quotemeta $_ if $self->{input_raw} or $self->{input_pure};
    if ($self->{input_beta})
    {
        tr/a-z/A-Z/;                                            # upcap all letters
        s#\\#/#g;
        $_ = quotemeta $_;
        s#\\\s+# #g;
        return $_;
    }

    # Fall back to Perseus-style transliteration
    
    tr/A-Z/a-z/;
    my $start;
    $start++ if s#^\s+##;
    
    s/\b([aeêioôu\xea\xf4])/\x071$1/g;     # mark where non-rough breathing goes
    s#^h#\x072#i;                  # protect h for rough breathing later
    
    s/[eE]\^/H/g;                                           # eta
    s/[êÊ\xea\xca]/H/g;
    s/[tT]h/Q/g;                                            # theta
    s/x/C/g;                                                # xi
    s/[pP]h/F/g;                                            # phi
    s/[cC]h/X/g;                                            # chi
    s/[pP]s/Y/g;                                            # psi
    s/[oO]\^/W/g;                                           # omega
    s/[ôÔ\xf4\xd4]/W/g;
#   if (/h/) { $self->barf("I found an \`h\' I didn't understand in $_")};
    tr/a-z/A-Z/;                                            # upcap all other letters

    s#\x072#$rough_breathing#g;    
    s#\x071#$smooth_breathing#g;
    
    s#^# # if $start; # put the space back in front
    return $_;              
}
#+end_src
** blacklist
*** read_blacklist
Method to remove from @ARGV any files that match the blacklist 
of files that we never want to search through.                 
                                                                
#+begin_src perl
sub read_blacklist
{
    my $self = shift;
    my $bl;
    open BL, "<$self->{blacklist_file}" or 
        die "Couldn't open blacklist file: $self->{blacklist_file}: $!\n";
    {
        local $/;
        undef $/;
        $bl = <BL>;
    }
    print STDERR "Files originally in ARGV: ".scalar @ARGV."\n" if $self->{debug};
    my @files;
    $self->{blacklisted_files} = 0;
    foreach my $file (@ARGV)
    {
        $file =~ m/($self->{file_prefix}\d\d\d\d)/;
        my $pat  = $1;
        if ($bl =~ m/$pat/i)
        {
            print STDERR "Removing blacklisted file: $file\n" if $self->{debug};
            $self->{blacklisted_files}++;
        }
        else
        {
            push @files, $file;
        }
    }
    @ARGV = ();
    @ARGV = @files;
    print STDERR "Files remaining in ARGV: ".scalar @ARGV."\n" if $self->{debug};
}
#+end_src
*** read_works_blacklist
#+begin_src perl
sub read_works_blacklist
{
    my $self = shift;
    open BL, "<$self->{blacklisted_works_file}" or 
        die "Couldn't open blacklisted works file: $self->{blacklisted_works_file}: $!\n";
    {
        local $/;
        $/="\n";
        
	while (my $entry = <BL>)
	{
            chomp $entry;
            next if $entry =~ m/^\s*$/;
            next if $entry =~ m/^#/;
            my ($auth, @works) = split ' ', $entry;
            die "Bad blacklisted works auth ($self->{blacklisted_works_file}): $auth\n" 
                unless $auth =~ m/^\D\D\D\d+$/;
            my ($type, $auth_num) = $auth =~ m/^(\D\D\D)(\d+)$/;
            $type = lc $type;             
            $auth_num = sprintf '%04d', $auth_num;
            
            for (@works)
            {
                die "Bad blacklisted work ($self->{blacklisted_works_file}): $_\n" 
                    unless $_ =~ m/^\d+$/;
                $_ = sprintf '%03d', $_;
                warn "Blacklisting $type$auth_num: $_\n" if $self->{debug};
                $self->{blacklisted_works}{$type}{$auth_num}{$_} = 1;
            }
        }
    }
    $self->{blacklisted_hits} = 0;
    close BL or 
        die "Couldn't close blacklisted works file: $self->{blacklist_file}: $!\n";
}
#+end_src
** extract_hits 

Subroutine to seek to the position of each hit in a search and for
each one to extract the location info and surrounding context.
*** Code                                                                                
#+begin_src perl
sub extract_hits 
{
    my ($self, $auth) = @_;
    my ($match, $block_start, $location);
    my ($code, $start, $end, $lines, $result, $this_work, $pos);
    my $current_block_start = -1;
    my $buf = $self->{buf};
    
    # load up the author, work and label info for that file (from the
    # corresponding .idt file, but only for full-file searches -- word 
    # list searches and partial files will have parsed the idt file aleady, 
    # in order to see what blocks the work in question lies in.
    
    # Get context regexps for the current language
    my $numeric = $1 if $self->{context} =~ m/(\d+)/;
    my $context;
    $context = $context{$self->{current_lang}}{$self->{context}} 
        || $numeric;
    $context = $self->{context} unless $context;
    my $overflow  = $self->{overflow}->{$self->{context}} || $self->{max_context};

    # This is used to reject candidates for sentence, etc. ending; matches against: (..X..)
    my $reject = ($self->{current_lang} eq 'g') ?
        qr /^\.\ |^.\.\.|^[ &][A-Za-z]|^[a-z][a-z]\.|^.\$|^..@\d|^...[&\$]|^..._|^..\.[ \]]\d/ :
        qr /^\.\ |^.\.\.|^\ [A-Za-z]|^fr\.|^cf\.|^eg\.|^.\$|^..@\d|^...[&\$]|^..._|^..\.[ \]]\d|^[A-Z]|^.[A-Z]/;
        
    my ($offset, $last_offset, $parsed_block) = (-1, -1, 0);
    my $matching_sets;
    HIT: foreach $match ( 0 .. $#{ $self->{seen}{$auth} } ) 
    {
        # The blocks containing the work in
        # question have been read into memory, so all we need to do
        # is to start at the beginning of the correct block
        $last_offset = $offset;
        $offset = $self->{seen}{$auth}[$match];
        print STDERR "Match num: $match; offset: $offset\n" if $self->{debug};
        my $buf_start  = (($offset >> 13) << 13);
        
        # Optimize case where one hit comes close after the previous,
        # so as not to go back to parse once again unneccessarily from
        # the beginning of the same block.  But watch out for cases
        # where a failed multiple match (next HIT) has skipped that
        # parsing
        if ($parsed_block and $last_offset != -1 and 
            ($offset - $last_offset < $offset - $buf_start))
        {
            $buf_start = $last_offset;
        }
        $parsed_block = 0; # set flag false
        
        if ($self->{check_word_stats})
        {
            # We have to scan for the location of this hit in the case of
            # indexed searches, even when it will not be displayed, in order 
            # to maintain proper statistics for the number of hits per work. 
            for (my $i = $buf_start; $i < $offset; $i++ ) 
            {
                # parse all of the data in this block from its beginning to our match
                $code = ord (substr ($$buf, $i, 1));
                next unless ($code >> 7); # high bit set
                $self->parse_non_ascii ($buf, \$i);             
            }
            $parsed_block = 1;
            
            print STDERR "$self->{work_num} ... $self->{current_work}\n" if
                $self->{debug};
            # for word-list searches, discard any hits that are not in the right
            # work (i.e. there might be other hits in this set of blocks too)
            next HIT if ($self->{current_work} and 
                         ($self->{work_num}) != $self->{current_work});  
            
        }
        $start = $self->{match_start}{$auth}[$match] - 2;
                
        # Get context block
        if ($self->{numeric_context}) 
        {
            $start++;
            # Get a number of lines of context before the match -- the concept of
            # `line' here is very unsophisticated.
            for ($lines = 0; $lines <= $context and 
                 ($start > 0); $start--) 
            {
                $lines++ if (((ord (substr ($$buf, $start, 1))) >> 7) and not
                             (ord (substr ($$buf, $start - 1, 1)) >> 7) and not
                             (substr ($$buf, $start - 1, 1) eq "\x00"));
            }
            $start+=2;
        }
        elsif ($context eq 'level') {
            # Do nothing: $start stays the same
            $start+=2;
        }
        else
        {       
            # Find the start of the word pattern -- our pattern might have 
            # punctuation inside, or may simply have picked some up along the way.
            for ($start--; $start > 0; $start--)
            {
                last if substr ($$buf, $start, 2) =~ /[a-zA-Z)(=\\\/+][\s.,;:]/;
            }
            
            $start++; # This is to compensate for the $start-- on the first pass below
            # Get a regexp-delimited context
            for ($lines = 0; $start > 0; $start--)
            {
                # Lookahead so as to avoid ?_, @1, $., .&, Q. Horatius usw.
                last if substr ($$buf, $start, 1) =~ /$context/
                    and not substr ($$buf, $start - 2, 5) =~ $reject;
                # Failsafe
                $lines++ if (((ord (substr ($$buf, $start, 1))) >> 7) and not
                             (ord (substr ($$buf, $start - 1, 1)) >> 7) and not
                             (substr ($$buf, $start - 1, 1) eq "\x00"));
                last if $lines >= $overflow; 
            }
            # Try to eliminate stray chars and wasteful whitespace
            #while (substr ($$buf, ++$start, 1) =~ /[\s\d'"@}\])&\$\x80-\xff]/) {};
            while (substr ($$buf, ++$start, 1) =~ /[\s\d'"@}\])\x80-\xff]/) {};
        }
        
        next HIT if $self->{already_reported}{$auth}{$start} and 
            not $self->{check_word_stats};
        
        if ($self->{numeric_context}) 
        {
            # Get lines of context after the match.
            for ($end = $offset, $lines = 0; ($lines <= $context) and 
                 ($end < length $$buf ) ; $end++) 
            {
                $lines++ if (((ord (substr ($$buf, $end, 1))) >> 7) and not 
                             (ord (substr ($$buf, $end + 1, 1)) >> 7) and not
                             (substr ($$buf, $end + 1, 1) eq "\x00"));
            }
            $end-=2;
        }
        elsif ($context eq 'level') {
            # Grab to the end of the current section (e.g. lexicon
            # entry).  Crude solution, but Photius lex entries are not
            # separated by level.
            for ($end = $offset, $lines = 0; $end < length $$buf; $end++) {
                last if substr ($$buf, $end, 2) =~ m/[\x80-\xff]</;
                # Failsafe
                $lines++ if (((ord (substr ($$buf, $end, 1))) >> 7) and not
                             (ord (substr ($$buf, $end + 1, 1)) >> 7) and not
                             (substr ($$buf, $end + 1, 1) eq "\x00"));
                last if $lines >= 100;
            }
        }
        else
        {
            # Get a regexp-delimited context
            for ($end = $offset, $lines = 0; $end < length $$buf; $end++)
            {
                # Lookahead so as to avoid ?_, @1, $. usw.
                last if substr ($$buf, $end, 1) =~ /$context/
                    and not substr ($$buf, $end - 2, 5) =~ $reject;
                # Failsafe
                $lines++ if (((ord (substr ($$buf, $end, 1))) >> 7) and not
                             (ord (substr ($$buf, $end + 1, 1)) >> 7) and not
                             (substr ($$buf, $end + 1, 1) eq "\x00"));
                last if $lines >= $overflow; 
            }
            $end++; # Take one more
        }
        
        $result = substr ($$buf, $start, ($end - $start));
        
        # We want to highlight all matching patterns, and yet accept only those
        # passages where there are matches across a mimimum number of distinct
        # patterns from the list
        my %matches = ();
        if ($self->{output_format} eq 'beta' or not $self->{highlight})
        {
            my $n = 0;
            map {$matches{$n}++ if $result =~ /$_/; $n++;}(@{ $self->{pattern_list} });
            $matching_sets = 0;
            if ($self->{repeat_matches}) {
                # Count total number of matches for all patterns
                $matching_sets += $_ for values %matches;
            }
            else {
                # Count number of individual patterns that match
                $matching_sets = values %matches;
            }
            print STDERR "+ $result\n" if $self->{debug};
            print STDERR "+ $matching_sets: $auth, $offset\n" if $self->{debug};
            warn "ERROR: Disappearing Match!\n" unless $matching_sets;
            next HIT unless $matching_sets >= $self->{min_matches_int};
            next HIT if $self->{reject_pattern} and $result =~ m/$self->{reject_pattern}/;
        }
        else
        {
            my $n = 0;
            map     {$result =~ s#(~hit~[^~]*~)|((?:\*[)(/\\\\=+|']*)?$_[)(/\\\\=+|']*)#
                                                                        if ($2) {$matches{$n}++; '~hit~'.$2.'~'}
                                                                        else    {$1}
                                                                        #ge;
                     $n++;}
                (@{ $self->{pattern_list} });


            if ($self->{repeat_matches}) {
                # Count total number of matches for all patterns
                $matching_sets = 0;
                $matching_sets += $_ for values %matches;
            }
            else {
                # Count number of individual patterns that match
                $matching_sets = scalar keys %matches;
            }
            print STDERR "+ $result\n" if $self->{debug};
            # print STDERR "+ ".$self->{pattern_list}[0]."\n" if $self->{debug};
            print STDERR "+ $matching_sets: $auth, $offset\n" if $self->{debug};
#            my $seens = join ':', @{ $self->{seen}{$auth} };
#            print STDERR  "$seens\n";

            warn "ERROR: Disappearing Match!!\n" unless $matching_sets;
            next HIT unless $matching_sets >= $self->{min_matches_int};
            next HIT if $self->{reject_pattern} and $result =~ m/$self->{reject_pattern}/;
        }
                
        if ($self->{check_word_stats})
        {
            # keep a running total of hits
            $self->{hits_hash}{$self->{auth_num}}
            {$self->{work_num}}{$self->{word_key}}++;
            print STDERR $self->{auth_num}, "; ", 
            $self->{work_num}, "; ", 
            $self->{word_key},   "; ", 
            $self->{hits_hash}{$self->{auth_num}}{$self->{work_num}}
            {$self->{word_key}}, 
            "\n" if $self->{debug};
            next HIT if $self->{already_reported}{$auth}{$start};
        }
        else
        {
            # Only now do we belatedly find the location for searches that
            # ignore statistics (ie. all but indexed searches of the TLG), since
            # we are sure we want to output this block.
            for (my $i = $buf_start; $i < $offset; $i++ ) 
            {
                # parse all of the data in this block from its beginning to our match
                $code = ord (substr ($$buf, $i, 1));
                next unless ($code >> 7); # high bit set
                $self->parse_non_ascii ($buf, \$i);             
            }
        }
        # Set flag to true, since we have passed by all of the next
        # HIT statements, and we have definitely parsed the location
        # info for this hit, meaning we can use it as the basis for
        # the location info for the next hit in this block
        $parsed_block = 1;
        
        $self->{hits}++;
            
        if (exists $self->{blacklisted_works} 
            and $self->{blacklisted_works}{$self->{file_prefix}}{$self->{auth_num}}{$self->{work_num}})
        {
            warn "Warning: supressing hit in blacklisted work ($self->{auth_num}: $self->{work_num})\n";
            $self->{blacklisted_hits}++;
            next HIT;
        }

        # Add spaces to start of line for proper indent
        my $spaces = -1;
        for (my $pre_start = $start; not (ord (substr ($$buf, $pre_start--, 1)) >> 7); 
             $spaces++)     {}
        $result = ' ' x $spaces . $result;
        
        $location = "\n\&";
        # extract and print the author, work and location of the match
        #print STDERR ">>".$self->{type}.$self->{auth_num}."||\n";

        $this_work = "$author{$self->{type}}{$self->{auth_num}}, ";
        $this_work .= 
            "$work{$self->{type}}{$self->{auth_num}}{$self->{work_num}} ";
        $location .= ($self->{print_bib_info} and not  $self->{bib_info_printed}{$self->{auth_num}}{$self->{work_num}})
            ? $self->get_biblio_info($self->{type}, $self->{auth_num}, $self->{work_num})
            : $this_work;
        $self->{bib_info_printed}{$self->{auth_num}}{$self->{work_num}} = 'yes' if $self->{print_bib_info};

        $location .="\&\n";

        my $jumpto = $self->{type}.','.$self->{auth_num}.','.$self->{work_num};
            
        foreach (reverse sort keys %{ $self->{level} }) 
        {
            if 
                ($level_label{$self->{type}}{$self->{auth_num}}{$self->{work_num}}{$_})
            {
                $location .=
                    "$level_label{$self->{type}}{$self->{auth_num}}{$self->{work_num}}{$_}".
                    " $self->{level}{$_}, ";
                $jumpto .= ':'.$self->{level}{$_};
            }
            elsif ($self->{level}{$_} ne '1') 
            {       # The Theognis exception & ddp
                $location .= "$self->{level}{$_}, ";
                $jumpto .= ':'.$self->{level}{$_};
            }
        }
        chop ($location); chop ($location);
        if ($self->{special_note}) 
        {
            $location .= "\nNB. $self->{special_note}";
            undef $self->{special_note};
        }

        $location .= "\n\n";
        if ($Diogenes::Base::cgi_flag and $self->{cgi_buttons})
        {
            # Leading space keeps it out of the perseus links
            $result .= " \n~~~$jumpto~~~\n";
        }
        else
        {
            $result .= "\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
        }
        my $base = ($self->{current_lang} eq 'g')
            ? '$'
            : '&';
        my $output = '& ' . $location . $base . $result;
        
        $self->print_output(\$output);
        
        $self->{already_reported}{$auth}{$start}++;
        
    } # end of foreach.
} # end of sub extract_hits.
#+end_src
*** Analyse
**** Variablen
Übergeben werden nur $self und $auth ($auth ist $ARGV [d.h.
tlg0001.txt] bei der Suche in ganzen Dateien, keys %req_auth_wk
(select_authors: 0001 oder 1) für die Teilsuche.

Eine Referenz auf den aktuellen Buffer befindet sich in $self->{buf};
diese Referenz wird hier nach $buf kopiert.

#+begin_src perl
    my ($self, $auth) = @_;
    my ($match, $block_start, $location);
    my ($code, $start, $end, $lines, $result, $this_work, $pos);
    my $current_block_start = -1;
    my $buf = $self->{buf};
#+end_src

**** COMMENT Parsen der .idt für die Suche in ganzen Dateien 
Dies ist inzwischen auch für diese Suchart nach pgrep ausgelagert
    # load up the author, work and label info for that file (from the
    # corresponding .idt file, but only for full-file searches -- word 
    # list searches and partial files will have parsed the idt file aleady, 
    # in order to see what blocks the work in question lies in.
    
**** Festlegung der REs für context
#+begin_src perl
    # Get context regexps for the current language
    my $numeric = $1 if $self->{context} =~ m/(\d+)/;
    my $context;
    $context = $context{$self->{current_lang}}{$self->{context}} 
        || $numeric;
    $context = $self->{context} unless $context;
    my $overflow  = $self->{overflow}->{$self->{context}} || $self->{max_context};

    # This is used to reject candidates for sentence, etc. ending; matches against: (..X..)
    my $reject = ($self->{current_lang} eq 'g') ?
        qr /^\.\ |^.\.\.|^[ &][A-Za-z]|^[a-z][a-z]\.|^.\$|^..@\d|^...[&\$]|^..._|^..\.[ \]]\d/ :
        qr /^\.\ |^.\.\.|^\ [A-Za-z]|^fr\.|^cf\.|^eg\.|^.\$|^..@\d|^...[&\$]|^..._|^..\.[ \]]\d|^[A-Z]|^.[A-Z]/;
#+end_src
       
**** HIT
$match ist Nummer des jewiligen Treffers

#+begin_src perl
    my ($offset, $last_offset, $parsed_block) = (-1, -1, 0);
    my $matching_sets;
    HIT: foreach $match ( 0 .. $#{ $self->{seen}{$auth} } ) 
    {
#+end_src

***** Aufsuchen der Stelle über offset    
$offset ist die Position in $buf, an der der jewilige Treffer beginnt,
$last_offset die Position des vorangegangenen Treffers. $buf_start
streicht die letzten 13 Stellen in der binären Representation von
offset und ersetzt sie durch 0. Daher ist diese Zahl 0 oder ein
Vielfaches von 8192 (= 2**13).
#+begin_src perl
        # The blocks containing the work in
        # question have been read into memory, so all we need to do
        # is to start at the beginning of the correct block
        $last_offset = $offset;
        $offset = $self->{seen}{$auth}[$match];
        print STDERR "Match num: $match; offset: $offset\n" if $self->{debug};
        my $buf_start  = (($offset >> 13) << 13);
#+end_src

***** REST

        # Optimize case where one hit comes close after the previous,
        # so as not to go back to parse once again unneccessarily from
        # the beginning of the same block.  But watch out for cases
        # where a failed multiple match (next HIT) has skipped that
        # parsing
        if ($parsed_block and $last_offset != -1 and 
            ($offset - $last_offset < $offset - $buf_start))
        {
            $buf_start = $last_offset;
        }
        $parsed_block = 0; # set flag false
        
        if ($self->{check_word_stats})
        {
            # We have to scan for the location of this hit in the case of
            # indexed searches, even when it will not be displayed, in order 
            # to maintain proper statistics for the number of hits per work. 
            for (my $i = $buf_start; $i < $offset; $i++ ) 
            {
                # parse all of the data in this block from its beginning to our match
                $code = ord (substr ($$buf, $i, 1));
                next unless ($code >> 7); # high bit set
                $self->parse_non_ascii ($buf, \$i);             
            }
            $parsed_block = 1;
            
            print STDERR "$self->{work_num} ... $self->{current_work}\n" if
                $self->{debug};
            # for word-list searches, discard any hits that are not in the right
            # work (i.e. there might be other hits in this set of blocks too)
            next HIT if ($self->{current_work} and 
                         ($self->{work_num}) != $self->{current_work});  
            
        }
        $start = $self->{match_start}{$auth}[$match] - 2;
                
        # Get context block
        if ($self->{numeric_context}) 
        {
            $start++;
            # Get a number of lines of context before the match -- the concept of
            # `line' here is very unsophisticated.
            for ($lines = 0; $lines <= $context and 
                 ($start > 0); $start--) 
            {
                $lines++ if (((ord (substr ($$buf, $start, 1))) >> 7) and not
                             (ord (substr ($$buf, $start - 1, 1)) >> 7) and not
                             (substr ($$buf, $start - 1, 1) eq "\x00"));
            }
            $start+=2;
        }
        elsif ($context eq 'level') {
            # Do nothing: $start stays the same
            $start+=2;
        }
        else
        {       
            # Find the start of the word pattern -- our pattern might have 
            # punctuation inside, or may simply have picked some up along the way.
            for ($start--; $start > 0; $start--)
            {
                last if substr ($$buf, $start, 2) =~ /[a-zA-Z)(=\\\/+][\s.,;:]/;
            }
            
            $start++; # This is to compensate for the $start-- on the first pass below
            # Get a regexp-delimited context
            for ($lines = 0; $start > 0; $start--)
            {
                # Lookahead so as to avoid ?_, @1, $., .&, Q. Horatius usw.
                last if substr ($$buf, $start, 1) =~ /$context/
                    and not substr ($$buf, $start - 2, 5) =~ $reject;
                # Failsafe
                $lines++ if (((ord (substr ($$buf, $start, 1))) >> 7) and not
                             (ord (substr ($$buf, $start - 1, 1)) >> 7) and not
                             (substr ($$buf, $start - 1, 1) eq "\x00"));
                last if $lines >= $overflow; 
            }
            # Try to eliminate stray chars and wasteful whitespace
            #while (substr ($$buf, ++$start, 1) =~ /[\s\d'"@}\])&\$\x80-\xff]/) {};
            while (substr ($$buf, ++$start, 1) =~ /[\s\d'"@}\])\x80-\xff]/) {};
        }
        
        next HIT if $self->{already_reported}{$auth}{$start} and 
            not $self->{check_word_stats};
        
        if ($self->{numeric_context}) 
        {
            # Get lines of context after the match.
            for ($end = $offset, $lines = 0; ($lines <= $context) and 
                 ($end < length $$buf ) ; $end++) 
            {
                $lines++ if (((ord (substr ($$buf, $end, 1))) >> 7) and not 
                             (ord (substr ($$buf, $end + 1, 1)) >> 7) and not
                             (substr ($$buf, $end + 1, 1) eq "\x00"));
            }
            $end-=2;
        }
        elsif ($context eq 'level') {
            # Grab to the end of the current section (e.g. lexicon
            # entry).  Crude solution, but Photius lex entries are not
            # separated by level.
            for ($end = $offset, $lines = 0; $end < length $$buf; $end++) {
                last if substr ($$buf, $end, 2) =~ m/[\x80-\xff]</;
                # Failsafe
                $lines++ if (((ord (substr ($$buf, $end, 1))) >> 7) and not
                             (ord (substr ($$buf, $end + 1, 1)) >> 7) and not
                             (substr ($$buf, $end + 1, 1) eq "\x00"));
                last if $lines >= 100;
            }
        }
        else
        {
            # Get a regexp-delimited context
            for ($end = $offset, $lines = 0; $end < length $$buf; $end++)
            {
                # Lookahead so as to avoid ?_, @1, $. usw.
                last if substr ($$buf, $end, 1) =~ /$context/
                    and not substr ($$buf, $end - 2, 5) =~ $reject;
                # Failsafe
                $lines++ if (((ord (substr ($$buf, $end, 1))) >> 7) and not
                             (ord (substr ($$buf, $end + 1, 1)) >> 7) and not
                             (substr ($$buf, $end + 1, 1) eq "\x00"));
                last if $lines >= $overflow; 
            }
            $end++; # Take one more
        }
        
        $result = substr ($$buf, $start, ($end - $start));
        
        # We want to highlight all matching patterns, and yet accept only those
        # passages where there are matches across a mimimum number of distinct
        # patterns from the list
        my %matches = ();
        if ($self->{output_format} eq 'beta' or not $self->{highlight})
        {
            my $n = 0;
            map {$matches{$n}++ if $result =~ /$_/; $n++;}(@{ $self->{pattern_list} });
            $matching_sets = 0;
            if ($self->{repeat_matches}) {
                # Count total number of matches for all patterns
                $matching_sets += $_ for values %matches;
            }
            else {
                # Count number of individual patterns that match
                $matching_sets = values %matches;
            }
            print STDERR "+ $result\n" if $self->{debug};
            print STDERR "+ $matching_sets: $auth, $offset\n" if $self->{debug};
            warn "ERROR: Disappearing Match!\n" unless $matching_sets;
            next HIT unless $matching_sets >= $self->{min_matches_int};
            next HIT if $self->{reject_pattern} and $result =~ m/$self->{reject_pattern}/;
        }
        else
        {
            my $n = 0;
            map     {$result =~ s#(~hit~[^~]*~)|((?:\*[)(/\\\\=+|']*)?$_[)(/\\\\=+|']*)#
                                                                        if ($2) {$matches{$n}++; '~hit~'.$2.'~'}
                                                                        else    {$1}
                                                                        #ge;
                     $n++;}
                (@{ $self->{pattern_list} });


            if ($self->{repeat_matches}) {
                # Count total number of matches for all patterns
                $matching_sets = 0;
                $matching_sets += $_ for values %matches;
            }
            else {
                # Count number of individual patterns that match
                $matching_sets = scalar keys %matches;
            }
            print STDERR "+ $result\n" if $self->{debug};
            # print STDERR "+ ".$self->{pattern_list}[0]."\n" if $self->{debug};
            print STDERR "+ $matching_sets: $auth, $offset\n" if $self->{debug};
#            my $seens = join ':', @{ $self->{seen}{$auth} };
#            print STDERR  "$seens\n";

            warn "ERROR: Disappearing Match!!\n" unless $matching_sets;
            next HIT unless $matching_sets >= $self->{min_matches_int};
            next HIT if $self->{reject_pattern} and $result =~ m/$self->{reject_pattern}/;
        }
                
        if ($self->{check_word_stats})
        {
            # keep a running total of hits
            $self->{hits_hash}{$self->{auth_num}}
            {$self->{work_num}}{$self->{word_key}}++;
            print STDERR $self->{auth_num}, "; ", 
            $self->{work_num}, "; ", 
            $self->{word_key},   "; ", 
            $self->{hits_hash}{$self->{auth_num}}{$self->{work_num}}
            {$self->{word_key}}, 
            "\n" if $self->{debug};
            next HIT if $self->{already_reported}{$auth}{$start};
        }
        else
        {
            # Only now do we belatedly find the location for searches that
            # ignore statistics (ie. all but indexed searches of the TLG), since
            # we are sure we want to output this block.
            for (my $i = $buf_start; $i < $offset; $i++ ) 
            {
                # parse all of the data in this block from its beginning to our match
                $code = ord (substr ($$buf, $i, 1));
                next unless ($code >> 7); # high bit set
                $self->parse_non_ascii ($buf, \$i);             
            }
        }
        # Set flag to true, since we have passed by all of the next
        # HIT statements, and we have definitely parsed the location
        # info for this hit, meaning we can use it as the basis for
        # the location info for the next hit in this block
        $parsed_block = 1;
        
        $self->{hits}++;
            
        if (exists $self->{blacklisted_works} 
            and $self->{blacklisted_works}{$self->{file_prefix}}{$self->{auth_num}}{$self->{work_num}})
        {
            warn "Warning: supressing hit in blacklisted work ($self->{auth_num}: $self->{work_num})\n";
            $self->{blacklisted_hits}++;
            next HIT;
        }

        # Add spaces to start of line for proper indent
        my $spaces = -1;
        for (my $pre_start = $start; not (ord (substr ($$buf, $pre_start--, 1)) >> 7); 
             $spaces++)     {}
        $result = ' ' x $spaces . $result;
        
        $location = "\n\&";
        # extract and print the author, work and location of the match
        #print STDERR ">>".$self->{type}.$self->{auth_num}."||\n";

        $this_work = "$author{$self->{type}}{$self->{auth_num}}, ";
        $this_work .= 
            "$work{$self->{type}}{$self->{auth_num}}{$self->{work_num}} ";
        $location .= ($self->{print_bib_info} and not  $self->{bib_info_printed}{$self->{auth_num}}{$self->{work_num}})
            ? $self->get_biblio_info($self->{type}, $self->{auth_num}, $self->{work_num})
            : $this_work;
        $self->{bib_info_printed}{$self->{auth_num}}{$self->{work_num}} = 'yes' if $self->{print_bib_info};

        $location .="\&\n";

        my $jumpto = $self->{type}.','.$self->{auth_num}.','.$self->{work_num};
            
        foreach (reverse sort keys %{ $self->{level} }) 
        {
            if 
                ($level_label{$self->{type}}{$self->{auth_num}}{$self->{work_num}}{$_})
            {
                $location .=
                    "$level_label{$self->{type}}{$self->{auth_num}}{$self->{work_num}}{$_}".
                    " $self->{level}{$_}, ";
                $jumpto .= ':'.$self->{level}{$_};
            }
            elsif ($self->{level}{$_} ne '1') 
            {       # The Theognis exception & ddp
                $location .= "$self->{level}{$_}, ";
                $jumpto .= ':'.$self->{level}{$_};
            }
        }
        chop ($location); chop ($location);
        if ($self->{special_note}) 
        {
            $location .= "\nNB. $self->{special_note}";
            undef $self->{special_note};
        }

        $location .= "\n\n";
        if ($Diogenes::Base::cgi_flag and $self->{cgi_buttons})
        {
            # Leading space keeps it out of the perseus links
            $result .= " \n~~~$jumpto~~~\n";
        }
        else
        {
            $result .= "\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
        }
        my $base = ($self->{current_lang} eq 'g')
            ? '$'
            : '&';
        my $output = '& ' . $location . $base . $result;
        
        $self->print_output(\$output);
        
        $self->{already_reported}{$auth}{$start}++;
        
    } # end of foreach.
} # end of sub extract_hits.




** numerically & END
#+begin_src perl
sub numerically { $a <=> $b; }

1;
#+end_src

* Diogenes::Browser

** TEST boilerplate
#+begin_src perl
  my $query = Diogenes::Browser->new
  (
   -type => 'tlg',
  );
#+end_src

** browse_authors
*** Code
#+begin_src perl
    sub browse_authors 
    {
      my ($self, $pattern) = @_;
      $self->{latex_counter} = 0;
      return (1 => 'doccan1', 2 => 'doccan2') if $self->{type} eq 'bib';
      # For authors without numbers
  #     return %{ $self->match_authtab($pattern) };
      my $rv = $self->match_authtab($pattern);
      # Add numbers (because some author names are identical)
      foreach (keys %{ $rv }) {
	  $rv->{$_} .= " ($_)";
      }
      return %{ $rv };
  }
#+end_src
*** Test
#+begin_src perl
  my %results = $query->browse_authors('Aristot');
  map { say "$_ \t $results{$_}" } sort keys %results;
#+end_src

#+begin_example
0086 	 Aristoteles Phil. et Corpus Aristotelicum Aristotle (0086)
2695 	 Vitae Aristotelis (2695)
4026 	 Anonymi In Aristotelis Artem Rhetoricam Rhet. (4026)
4027 	 Anonymi In Aristotelis Categorias Phil. (4027)
4032 	 Anonymi In Aristotelis Librum Primum Analyticorum Posteriorum Commentarium (4032)
4033 	 Anonymi In Aristotelis Ethica Nicomachea Phil. (4033)
4165 	 Anonymi In Aristotelis Librum De Interpretatione Phil. (4165)
4193 	 Anonymi In Aristotelis Sophisticos Elenchos Phil. (4193)
5015 	 Scholia In Aristotelem (5015)
9004 	 Anonymi In Aristotelis Librum Alterum Analyticorum Posteriorum Commentarium (9004)
#+end_example

*** Abhängigkeiten
Benutzt &match_authtab($pattern).
*** Beschreibung
Methode, die alle Autornamen ausgibt, die zu einen gegebenen regulären
Ausdruck stimmen. Die Hauptarbeit mach &math_authtab($pattern)

** browse_works
*** Code
#+begin_src perl
  sub browse_works
{
    my $self = shift;
    my $auth_num = shift;
    my $work_num;
    # The real auth num is actually not a number for civ texts, so
    # we get it here (conversely, tlg bibliography files have a real author
    # number, such as 9999, that is not reflected in the file name)
    my $real_num = $self->parse_idt ($auth_num);
    #return %{ $work{$self->{type}}{$real_num} };
    my %ret =  %{ $work{$self->{type}}{$real_num} };
    $self->format_output(\$_, 'l') for values %ret;
    return %ret;
}
#+end_src

*** Test
#+begin_src perl
    my %results = $query->browse_works('0086');
    map { say "$_ \t $results{$_}" } sort keys %results;
#+end_src

#+begin_example
001 	 Analytica priora et posteriora
002 	 De anima
003 	 Ἀθηναίων πολιτεία
004 	 De audibilibus
005 	 De caelo
006 	 Categoriae
007 	 De coloribus
008 	 De divinatione per somnum
009 	 Ethica Eudemia
010 	 Ethica Nicomachea
011 	 Epistulae
012 	 De generatione animalium
013 	 De generatione et corruptione
014 	 Historia animalium
015 	 De incessu animalium
016 	 De insomniis
017 	 De interpretatione
018 	 De juventute et senectute % De vita et morte
019 	 De lineis insecabilibus
020 	 De longitudine et brevitate vitae
021 	 De motu animalium
022 	 Magna moralia
023 	 Mechanica
024 	 De memoria et reminiscentia
025 	 Metaphysica
026 	 Meteorologica
027 	 Mirabilium auscultationes
028 	 De mundo
029 	 Oeconomica
030 	 De partibus animalium
031 	 Physica
032 	 Physiognomonica
033 	 Protrepticus
034 	 Poetica
035 	 Politica
036 	 Problemata
037 	 De respiratione
038 	 Rhetorica
040 	 Sophistici elenchi
041 	 De sensu et sensibilibus
042 	 De somno et vigilia
043 	 De spiritu
044 	 Topica
045 	 De virtutibus et vitiis
046 	 De ventorum situ et nominibus
047 	 De Xenophane, de Zenone, de Gorgia
048 	 Divisiones Aristoteleae
049 	 Fragmenta
050 	 Fragmentum
051 	 Fragmenta varia
052 	 De anima (codicis E fragmenta recensionis a vulgata diversae)
053 	 De anima (codicis P lectiones quae valde a lectionibus ceterorum codicum distant)
054 	 Physicorum libri octavi textus alter (post 267b26)
055 	 Testimonia
056 	 Fragmenta
#+end_example
*** Beschreibung
Nimmt eine Autornimmer als Argument und gibt eine Werkliste als Hash zurück

*** Abhängigkeiten
- parse_idt ($auth_num)
- %{ $work{$self->{type}}{$real_num} }
- format_output(\$_, 'l') for values %ret

** browse_location
*** Code

#+begin_src perl
  sub browse_works {
    my $self = shift;
    my $auth_num = shift;
    my $work_num;
    # The real auth num is actually not a number for civ texts, so
    # we get it here (conversely, tlg bibliography files have a real author
    # number, such as 9999, that is not reflected in the file name)
    my $real_num = $self->parse_idt ($auth_num);
    #return %{ $work{$self->{type}}{$real_num} };
    my %ret =  %{ $work{$self->{type}}{$real_num} };
    $self->format_output(\$_, 'l') for values %ret;
    return %ret;
  }
#+end_src

*** Test

*** Beschreibung
Nimmt Autor und Werk (als Nummer) als Argumente an und gibt die
entsprechenden Label (Book, Bekker page, line, usw.) zurück
*** Abhängigkeiten
- parse_idt ($auth)
- format_output
*** Globale Variablen

** seek_passage
*** Code
#+begin_src perl
    sub seek_passage 
  {
      my $self = shift;
      my ($auth, $work, @array_target) = @_;
      my ($start_block, $end_block, $code, $lev, $top_level, $look_ahead);
      my ($top_num, $target_num, $level_num, $i);

      # We turn the passed array into a hash, to match the data gleaned
      # from the .idt file.
      my $index = $#array_target;
      my %target = map {$index-- => $_} @array_target;
      die "Ooops! $index" if $index != -1; 
      $self->{target_levels} = scalar @array_target;
      # If we aim for Book 0, Line 90, we really want Book 1, Line 90.
      my @modified_target = @array_target;
      for (my $j = 0; $j < $self->{target_levels}; $j++) {
	  if ($modified_target[$j] eq "0") {
	      $modified_target[$j] = 1;
	  }
      }
      $self->{target_citation} = join '.', @modified_target;

      my $orig_auth_num = $auth;
      my $real_num = $self->parse_idt ($auth);
      $work = sprintf '%03d', $work;

      # Hack for ddp etc. disk -- .idt files only list `document', which
      # is really the label for level 5, not level 0.
      if ($self->{documentary})
      {
	  $target{5} = delete $target{0};
	  $target{5} =~ s#([\[\]])#\`$1\`#g; #These are BETA null chars (see above).
      }

      $self->{current_lang} = 'g' unless $self->{type} =~ m/phi|civ/;

      my $filename = "$self->{cdrom_dir}$self->{file_prefix}$auth$self->{txt_suffix}";
      $auth = $real_num if defined $real_num;

      # open the file and seek to the beginning of the first block containing
      # our work
      open INP, $filename or $self->barf("Couldn't open $filename");
      binmode INP;

      $start_block = $work_start_block{$self->{type}}{$auth}{$work};
      my $next = $work;
      $next++;
      $end_block = $work_start_block{$self->{type}}{$auth}{$next};

      print STDERR "Start: $start_block" if $self->{debug}; 
      print STDERR ", End: $end_block\n" if $self->{debug} and $end_block; 

      my $offset = $start_block << 13;
      seek INP, $offset, 0;

      # read the several 8k blocks containing our work
      # Should one have the option to read in only a subsection?
      my $buf;
      $self->{buf} = \$buf;
      if (defined $end_block) 
      {
	  read INP, $buf, (($end_block - $start_block + 1) << 13) or
	      $self->barf ("Couln't read from $filename!");
      }
      else 
      {
	  local $/;
	  undef $/;
	  $buf = <INP>;
	  $self->barf ("Couln't read the rest of $filename!") unless
	      defined $buf;
	  $end_block = (length $buf) >> 13;
      }
      close INP or $self->barf("Couldn't close $filename");

      $self->{work_num} = 0;
      $self->{auth_num} = 0;
      $self->{browse_auth} = $orig_auth_num;
      $self->{browse_work} = $work;
      $self->{current_work} = $work;

      # First, we look in the table of contents for starting point
      $top_level = (keys %{ $level_label{$self->{type}}{$auth}{$work} }) - 1;
      my ($block, $old_block);

      my $typeauth = $self->{type}.$auth;

      # There are very many short texts (esp fragmentary) where using
      # the ToC causes us to miss the work entirely.  Not sure if this
      # is a bug in the code below or in the idt files.  But computers
      # are so fast now, even searching through the entirety of a long
      # work is fast, so let's try defaulting to switching it off.

      # if ($typeauth =~ m/^(tlg5034|phi1348|phi0588|phi2349|tlg0031|phi0474|phi1002|tlg0096|phi0631|tlg5035)$/)
      if ($self->{use_idt_browsing})
      {
	  print STDERR "Skipping ToC for this wierd author.\n" if $self->{debug};
      }
      else
      {
	  # We have to iterate through these levels, since for alphabetic entries, they
	  # may not be in any order.
	SECTION:
	  for (@{ $top_levels{$self->{type}}{$auth}{$work} })
	  {
	      $block = @{ $_ }[1];
	      my $comp = compare(@{ $_ }[0], $target{$top_level});
	      if ($comp >= 0)
	      {
		  # We've gone too far, so use previous chunk
		  print STDERR 
		      ">>>@{ $_ }[0] => $target{$top_level} (using block $old_block)\n" if 
		      $self->{debug} and $old_block;
		  $block = $old_block;
		  last SECTION;
	      }
	      $old_block = $block;
	  }
	  # No match, so we try another trick
	  print STDERR "No match in table of contents.\n" if 
	      $self->{debug} and not defined $block;

	  # We now look in the table of last citations per block
	  my $cite_block = $block || 0;
	CITE_BLOCK:
	  while ($cite_block <= $end_block)
	  {
	      my $level = $last_citation{$self->{type}}{$auth}{$work}{$cite_block};

	      unless (defined $level)
	      {
		  # In case we are in an earlier work
		  $cite_block++;
		  next CITE_BLOCK;
	      }
	    LEVEL:
	      foreach $lev
		(
		 reverse sort numerically keys 
		 %{ $level_label{$self->{type}}{$auth}{$work} }
		) 
	      {
		  # See below
		  next LEVEL if 
		      $level_label{$self->{type}}{$auth}{$work}{$lev} =~ m#^\*#;
		  next LEVEL unless $target{$lev};
		  my $result = compare($level->{$lev}, $target{$lev});
		  print STDERR 
		      ">>>$level->{$lev} <=> $target{$lev}: res = $result ($lev, $cite_block)\n"
		      if $self->{debug};
		  if ($result == 0)
		  {
		      next LEVEL;
		  }
		  elsif ($result == -1)
		  {
		      $cite_block++;
		      next CITE_BLOCK;
		  }
		  else
		  {
		      $block = $cite_block;
		      last CITE_BLOCK;
		  }
	      }
	      $block = $cite_block;
	      last CITE_BLOCK;
	  }

	  my $next_work = sprintf '%03d', $work + 1;
	  $cite_block--; # went one too far
	  print STDERR "nw: $next_work, cb: $cite_block\n" if $self->{debug};
	  # Next block contains the end of our work but ends in the next work.
	  $block = $cite_block if exists 
	      $last_citation{$self->{type}}{$auth}{$next_work} and exists
	      $last_citation{$self->{type}}{$auth}{$next_work}{$cite_block};

	  print STDERR "Searching entire work!\n" if $self->{debug} and not defined $block;
      }
      $block ||= 0;
      my $starting_point = ($block - $start_block) << 13 if $block;
      $i = $starting_point || 0;
      $i--;

      # seek through first block to the beginning of the work we want
      while ( 0 + $self->{work_num} < 0 + $work) 
      {
	  $code = ord (substr ($buf, ++$i, 1));
	  next unless ($code >> 7);
	  $self->parse_non_ascii (\$buf, \$i);
      }
      if (0 + $self->{work_num} > 0 + $work)
      {
	  warn "Error in searching for start of work: trying again from the beginning\n"
	      if $self->{debug};
	  $i = 0;
	  while ( 0 + $self->{work_num} != 0 + $work) 
	  {
	      $code = ord (substr ($buf, ++$i, 1));
	      next unless ($code >> 7);
	      $self->parse_non_ascii (\$buf, \$i);
	      print "::" . $self->{work_num} . "\n" if $self->{debug};
	  }
      }
      if (0 + $self->{work_num} != 0 + $work)
      {
	  die "Error: cannot find the start of the work\n";
      }
      print STDERR "Search begins: $i \n" if $self->{debug};

      # For authors where we have to do a strict match rather than
      # matching when the citation is higher than the target.  For
      # Sextus Empiricus AM, books 1-6 come after 7-11.
      my $weird_auth;
      $weird_auth = 1 if $typeauth eq 'tlg0544';

      # read first bookmark
      $code = ord (substr ($buf, ++$i, 1));
      $self->parse_non_ascii (\$buf, \$i) if ($code >> 7);

      # Loop in reverse order through the levels, matching eg. first the book, then
      # the chapter, then the line. 

    LEV: foreach $lev
	(
	 reverse sort numerically 
	 keys %{ $level_label{$self->{type}}{$auth}{$work} }
	) 
    {
	print STDERR "==> $self->{level}{$lev} :: $target{$lev} \n" if $self->{debug};
	# labels that begin with a `*' are not hierarchical wrt the others
	next LEV if $level_label{$self->{type}}{$auth}{$work}{$lev} =~ m#^\*#;

	# loop until the count at this level reaches the desired number
	next LEV unless $target{$lev};
	if ($weird_auth) {
	    next LEV if (compare($self->{level}{$lev}, $target{$lev}) == 0);
	} else {
	    next LEV if (compare($self->{level}{$lev}, $target{$lev}) >= 0);
	}

	# Scan the text
      SCAN:   while ($i <= length $buf) 
      { 
	  $code = ord (substr ($buf, ++$i, 1));
	  next SCAN unless ($code >> 7);
	  $self->parse_non_ascii (\$buf, \$i);
	  redo SCAN unless defined $self->{level}{$lev};

	  if (0 + $self->{work_num} != 0 + $self->{browse_work} ) {
	      if (ref $self eq 'Diogenes::Browser::Stateless') {
		  print qq{<h1 style="text-align:center">Error: End of work reached without finding target citation!</h1>};
	      }
	      else {
		  print "End of work reached without finding target citation!\n"
	      }
	      # TODO: Return from failure more elegantly than this.
	      die "Bad browser request.\n";
	  }

	  # String equivalence
	  print STDERR "=> $self->{level}{$lev} :: $target{$lev} \n" if $self->{debug};
	  if ($weird_auth) {
	      last SCAN if (compare($self->{level}{$lev}, $target{$lev}) == 0);
	  } else {
	      last SCAN if (compare($self->{level}{$lev}, $target{$lev}) >= 0);
	  }
      } 
	print STDERR "Target found: $target{$lev}, level: $self->{level}{$lev}\n" 
	    if $self->{debug};
    }
      # Seek to end of current non-ascii block
      while (ord (substr ($buf, $i, 1)) >> 7) { $i++ };

      print STDERR "Offset: ", ($i + $offset), "\n" if $self->{debug};

      # store a reference to the string holding the text and the start point of the 
      # portion selected.
      $self->{browse_buf_ref} = \$buf;
      $self->{browse_begin} = $i;
      $self->{browse_end} = -1;

      return ($offset + $i, -1);  # $abs_begin and $abs_end 
  }
#+end_src
*** Test
#+begin_src perl
    $query->seek_passage
    (
     $query->parse_idt('0004'),
     '1',
     (6, 41, 0)
    );
    $query->browse_forward;

    print "\n";
#+end_src

#+begin_example
Diogenes Laertius Biogr. (c. A.D. 3), Vitae philosophorum (0004: 001)
"Diogenis Laertii vitae philosophorum, 2 vols.", Ed. Long, H.S.
Oxford: Clarendon Press, 1964, Repr. 1966.
Book 6, section 41, line 1

6.41.1          Ἐν Μεγάροις ἰδὼν τὰ μὲν πρόβατα τοῖς δέρμασιν ἐσκεπασμένα, 
              τοὺς δὲ παῖδας αὐτῶν γυμνούς, ἔφη, "λυσιτελέστερόν ἐστι 
              Μεγαρέως εἶναι κριὸν ἢ υἱόν." πρὸς τὸν ἐντινάξαντα αὐτῷ 
              δοκόν, εἶτα εἰπόντα, "φύλαξαι," "πάλιν γάρ με," ἔφη, "παίειν 
6.41.5        μέλλεις;" ἔλεγε τοὺς μὲν δημαγωγοὺς ὄχλου διακόνους, τοὺς δὲ 
              στεφάνους δόξης ἐξανθήματα. λύχνον μεθ' ἡμέραν ἅψας, "ἄνθρω-
              πον," φησί, "ζητῶ." εἱστήκει ποτὲ κατακρουνιζόμενος· τῶν δὲ 
              περιεστώτων ἐλεούντων, παρὼν Πλάτων ἔφη, "εἰ βούλεσθ' αὐτὸν 
              ἐλεῆσαι, ἀπόστητε," ἐνδεικνύμενος φιλοδοξίαν αὐτοῦ. ἐντρίψαντος 
6.41.10       αὐτῷ κόνδυλόν τινος, "Ἡράκλεις," ἔφη, "οἷον με χρῆμ' ἐλάνθανε    
6.42.1        τὸ μετὰ περικεφαλαίας περιπατεῖν." ἀλλὰ καὶ Μειδίου κονδυλί-
              σαντος αὐτὸν καὶ εἰπόντος, "τρισχίλιαί σοι κεῖνται ἐπὶ τῇ 
              τραπέζῃ," τῇ ἑξῆς πυκτικοὺς λαβὼν ἱμάντας καὶ καταλοήσας 
              αὐτὸν ἔφη, "τρισχίλιαί σοι κεῖνται ἐπὶ τῇ τραπέζῃ." Λυσίου 
6.42.5        τοῦ φαρμακοπώλου πυθομένου εἰ θεοὺς νομίζει, "πῶς δέ," 
              εἶπεν, "οὐ νομίζω, ὅπου καὶ σὲ θεοῖς ἐχθρὸν ὑπολαμβάνω;" οἱ δὲ 
              Θεόδωρον εἰπεῖν τοῦτο. ἰδών τινα περιρραινόμενον ἐπεῖπεν, "ὦ 
              κακόδαιμον, οὐκ ἐπίστασαι ὅτι ὥσπερ τῶν ἐν γραμματικῇ ἁμαρ-
              τημάτων περιρραινόμενος οὐκ ἂν ἀπαλλαγείης, οὕτως οὐδὲ τῶν ἐν 
6.42.10       τῷ βίῳ;" ἐνεκάλει τοῖς ἀνθρώποις περὶ τῆς τύχης, αἰτεῖσθαι 
              λέγων αὐτοὺς ἀγαθὰ τὰ αὐτοῖς δοκοῦντα καὶ οὐ τὰ κατ' ἀλήθειαν. 
6.43.1        πρὸς δὲ τοὺς περὶ τὰ ὀνείρατα ἐπτοημένους ἔλεγεν ὡς ὑπὲρ ὧν μὲν 
              πράττουσιν ὕπαρ, οὐκ ἐπιστρέφονται, ὑπὲρ ὧν δὲ καθεύδοντες 
              φαντασιοῦνται, πολυπραγμονοῦσιν. Ὀλυμπίασι τοῦ κήρυκος ἀνει-
              πόντος, "νικᾷ Διώξιππος ἄνδρας," "οὗτος μὲν δὴ ἀνδράποδα, 
6.43.5        ἄνδρας δ' ἐγώ." 
                Ἠγαπᾶτο δὲ καὶ πρὸς Ἀθηναίων· μειρακίου γοῦν τὸν πίθον 
              αὐτοῦ συντρίψαντος, τῷ μὲν πληγὰς ἔδοσαν, ἐκείνῳ δὲ ἄλλον 
              παρέσχον. φησὶ δὲ Διονύσιος ὁ στωικὸς ὡς μετὰ Χαιρώνειαν 
              συλληφθεὶς ἀπήχθη πρὸς Φίλιππον· καὶ ἐρωτηθεὶς τίς εἴη, ἀπ-
#+end_example


#+begin_src perl
  my @result = $query->seek_passage
  (
   $query->parse_idt('0004'),
   '1',
   (6, 41, 0)
  );
map say, @result;
#+end_src

#+begin_example
439188
-1
#+end_example

*** Beschreibung
Sucht eine Passage aus und speichert den Wert ab. Browse_forward gibt dann diese Passage aus. (???)
*** Abhängigkeiten
...

** TODO compare
*** Code
#+begin_src perl
sub compare
{
    # As defined by the PHI spec
    # Returns 0 for =, -1 for < and 1 for >
    my ($current, $target) = @_;
    $current ||= 0;

    # Match if we have no target or is zero
    return 1 unless $target;
    $target  ||= 0;

    my ($current_bin, $current_ascii) = $current =~ m/^(\d+)?(.*)$/;
    my ($target_bin,  $target_ascii ) = $target  =~ m/^(\d+)?(.*)$/;
    
    #print STDERR "|$current_bin|$current_ascii|$target_bin|$target_ascii|\n";
    
    # Match if leading binary part greater than or less than target
    return -1 if defined $current_bin and defined $target_bin and 
        $current_bin < $target_bin;
    return  1 if defined $current_bin and defined $target_bin and 
        $current_bin > $target_bin;
    return -1 if not defined $current_bin and defined $target_bin;
    # This is wrong.  If we are looking for a target of "fr" and the
    # fragments are at the end of the file, we don't want to match on
    # a bare book number.
    # return  1 if defined $current_bin and not defined $target_bin;
    
    # If both are not defined or both are defined and equal, we
    # examine the ascii part
    $current_ascii = lc $current_ascii;
    $target_ascii  = lc $target_ascii;
    return 0 if $current_ascii eq $target_ascii;
    if ((index $target_ascii, ':') == 0)
    {
        # The INS database sometimes has document 1:300[2], etc. where
        # the second half is really ordered numerically
        my ($current_extra_num) = $current_ascii =~ m/^:(\d+)/;
        my ($target_extra_num)  = $target_ascii  =~ m/^:(\d+)/;
        return -1 if defined $current_extra_num and defined $target_extra_num and 
            $current_extra_num < $target_extra_num;
        return  1 if defined $current_extra_num and defined $target_extra_num and 
            $current_extra_num > $target_extra_num;
    }
    # If both are single letters, match alphabetically (important for Plato)
    if ($current_ascii =~ m/^[a-zA-Z]$/ and $target_ascii =~ m/^[a-zA-Z]$/)
    {
        return ord lc $current_ascii <=> ord lc $target_ascii;
    }
    
    # Match if one is a substring of the other, and don't match
    # otherwise, if we are dealing with strings (my addition) --
    # comment it out, since it breaks the Suda (searching for "iota",
    # we hit "t" and then "alpha iota".  return 1 if (index
    # $current_ascii, $target_ascii) >= 0; return 1 if (index
    # $target_ascii, $current_ascii) >= 0;
    return -1 unless defined $current_bin or defined $target_bin;

    # If we are looking for a text suffix, e.g. Val Max section
    # 1(ext), don't match if the suffix is not there.
    return -1 if $target_ascii ne '' and $current_ascii eq '';
    
    # Is this really necessary?
    my @current = ($current_ascii =~ m/(\d+|\D)/g);
    my @target  = ($target_ascii  =~ m/(\d+|\D)/g);
    
    for my $n (0 .. $#current)
    {
        return  1 unless defined $target[$n];
        return  1 if $current[$n] =~ m/^\d+$/ and $target[$n] =~ m/^\d+$/ 
            and $current[$n] > $target[$n];
        return -1 if $current[$n] =~ m/^\d+$/ and $target[$n] =~ m/^\d+$/
            and $current[$n] < $target[$n];
        return  0 if $current[$n] =~ m/^\d+$/ and $target[$n] =~ m/^\d+$/;
        
        # We can't match on alphabetic sorting, because most texts don't work that way
        return -1 if $current[$n] =~ m/^\D$/ and $target[$n] =~ m/^\D$/;
        # The PHI spec is unclear and seems contradictory to me on what to do when
        # comparing strings character by character and you have a number on the one
        # hand and a string on the other.
    }
    return 0;
}
#+end_src
*** Test

*** Beschreibung

*** Abhängigkeiten

** print_location 
  
Private method that prints the location for the following two     
methods.  This code is lightly adapted from extract_hits.         
  
#+begin_src perl
  sub print_location 
  {
      my $self = shift;
      # args: offset in buffer, reference to buffer
      my ($offset, $ref) = @_;
      my $i;
      my $cgi = (ref $self eq 'Diogenes::Browser::Stateless') ? 1 : 0;
      my ($location, $code);

      my $block_start = $cgi ? 0 :(($offset >> 13) << 13);

      $self->{work_num} = 0;
      $self->{auth_num} = 0;

      # Handle out of bounds conditions
      $offset = 0 if $offset < 0;
      $offset = length $$ref if $offset > length $$ref;

      for ($i = $block_start; $i <= $offset; $i++ ) 
      {
	  $code = ord (substr ($$ref, $i, 1));
	  next unless ($code >> 7); # high bit set
	  $self->parse_non_ascii ($ref, \$i);             
      }
      # In case we try to read beyond the work currently in memory 
      return 0 
	  if (not $cgi and $self->{work_num} != $self->{current_work});

      my $this_work = 
	  "$author{$self->{type}}{$self->{auth_num}}, " .
	  "$work{$self->{type}}{$self->{auth_num}}{$self->{work_num}} ";
      $location = '&';
      $location .= ($self->{print_bib_info} and not 
		    $self->{bib_info_printed}{$self->{auth_num}}{$self->{work_num}})
	  ? $self->get_biblio_info($self->{type}, $self->{auth_num}, $self->{work_num})
	  : '';
      $self->{bib_info_printed}{$self->{auth_num}}{$self->{work_num}} = 'yes'
	  if $self->{print_bib_info}; 
      $location .="\&\n";

      $location .= $self->get_citation('full');

      $location .= "\n\n";
      $self->print_output(\$location);

      if ($self->{output_format} eq 'html') {
	  my $picture_dir = 'images/';
	  print qq{<input type="image" name="browser_back" class="prev" src="${picture_dir}go-previous.png" srcset="${picture_dir}go-previous.hidpi.png 2x" alt="Previous Text" /> };
	  print qq{<input type="image" name="browser_forward" class="next" src="${picture_dir}go-next.png" srcset="${picture_dir}go-next.hidpi.png 2x" alt="Subsequent Text" />};
	  print '<p style="clear: left;"></p>';
      }

      return 1;   
  }
#+end_src

** get_citation
#+begin_src perl
sub get_citation
{
    # Full means "Book 1, Line 2", else means "1.2".
    my $self = shift;
    my $full = shift;
    my $cit = '';

    foreach (reverse sort keys %{ $self->{level} }) 
    {
	  if ($self->{level}{$_} and 
	      $level_label{$self->{type}}{$self->{auth_num}}{$self->{work_num}}{$_})
	  # normal case
	  {
	      if ($full)
	      {
		  $cit .=
		      "$level_label{$self->{type}}{$self->{auth_num}}{$self->{work_num}}{$_}".
		      " $self->{level}{$_}, "
	      }
	      else
	      {
		  $cit .= "$self->{level}{$_}.";
	      }
	  }
	  elsif ($self->{level}{$_} ne '1') 
	  {   # The Theognis exception 
	      # and what unused levels in the ddp and ins default to
	      if ($full)
	      {
		  $cit .= "$self->{level}{$_}, ";
	      }
	      else
	      {
		  $cit .= "$self->{level}{$_}.";
	      }
	  }
    }
    if ($full)
    {
	  $cit =~ s/, $//;
    }
    else
    {
	  $cit =~ s/\.$//;
    }
    return $cit;
}
#+end_src

** numerically
#+begin_src perl
sub numerically { $a <=> $b; }
#+end_src

** browse_forward
Method to print out the lines following the currently selected point in   
the file.      Select the default number of lines via `browse_lines'.     

#+begin_src perl
sub browse_forward 
{
    my $self = shift;
    my ($abs_begin, $abs_end, $auth, $work);
    my ($ref, $begin, $end, $line, $result, $buf, $offset);

    if (ref $self eq 'Diogenes::Browser')
    {   # Get persistent browser info from object
	  $ref = $self->{browse_buf_ref};
	  $self->{browse_begin} = $self->{browse_end} unless $self->{browse_end} == -1;
	  $begin = $self->{browse_begin};
	  $offset = 0;
    }
    elsif (ref $self eq 'Diogenes::Browser::Stateless')
    {       # Browser info is passed as arguments
	  ($abs_begin, $abs_end, $auth, $work) = @_;
	  $auth = 1 if  $self->{type} eq 'bib' and $auth =~ m/9999/;

	  $begin = ($abs_end == -1) ? $abs_begin : $abs_end;
	  $self->{current_work} = $work;
	  $self->parse_idt ($auth);

	  # open the file and seek to the beginning of the first block containing
	  # our start-point
	  open INP, "$self->{cdrom_dir}$self->{file_prefix}$auth$self->{txt_suffix}" or
	      $self->barf("Couldn't open $self->{file_prefix}$auth$self->{txt_suffix}");
	  binmode INP;

	  my $start_block = $begin >> 13;
	  $offset = $start_block  << 13;
	  seek INP, $offset, 0;

	  # read three 8k blocks -- should be enough!
	  my $amount = 8192 * 3;
	  read INP, $buf, $amount or 
	      die "Could not read from file $self->{file_prefix}$auth.txt!\n" .
	      "End of file?";

	  close INP or $self->barf("Couldn't close $self->{file_prefix}$auth.txt");
	  $ref = \$buf;
	  $self->{browse_begin} = $begin;
	  $begin = $begin - $offset;
    }
    else
    { 
	  die "What is ".ref $self."?\n"
    }
    print STDERR "Beginning: $begin\n" if $self->{debug}; 

    # find the right length of chunk
  CHUNK:
    for ($end = $begin, $line = 0; 
	   ($line <= $self->{browse_lines}) and ($end < length $$ref) ; 
	   $end++) 
    {
	  $line++ if ((ord (substr ($$ref, $end, 1)) >> 7) and not
		      (ord (substr ($$ref, $end + 1, 1)) >> 7)) ; 
	  # for papyri, etc. get only one document at a time
	  if ($self->{documentary} and ord (substr ($$ref, $end, 1)) >= hex 'd0'
	      and ord (substr ($$ref, $end, 1)) <= hex 'df'
	      and not ord (substr ($$ref, $end - 1, 1)) >> 7)
	  {       # Seek to end of non-ascii block beginning with \xd0 -- \xdf
	      while (ord (substr ($$ref, $end, 1)) >> 7)      { $end++ };
	      last CHUNK;
	  }
	  if (substr ($$ref, $end, 2) eq "\xfe\x00") # EoB
	  {
	      $end++;
	      while (substr ($$ref, $end, 1) eq "\x00")  { $end++; };

	  }
    }
#    while (ord (substr ($$ref, --$end, 1)) >> 7)  { };

    $result = substr ($$ref, $begin, ($end - $begin));
    my $base = ($self->{current_lang} eq 'g')
	  ? '$'
	  : '&';
    $result = $base . $result  ;

    if ($self->print_location ($begin, $ref))
    {
#             print STDERR join "\n>>", @{ $self->interleave_citations(\$result) };
	  $self->{interleave_printing} = $self->interleave_citations(\$result);
	  $self->print_output (\$result);
    }
    else
    {
	  print "Sorry.  That's beyond the scope of the requested work.\n" unless 
	      $self->{quiet};
	  last PASS;
    }
    $begin = $end;
    # Store and pass back the start and end points of the whole session
    $self->{browse_end} = $end + $offset;
    return ($self->{browse_begin}, $end + $offset);  # $abs_begin and $abs_end
}
#+end_src

** my $fill_spaces
#+begin_src perl
my $fill_spaces = 14;
#+end_src

** %cite_info
#+begin_src perl
%cite_info = ( html =>
		 { before_cit => '<div class="citation">',
		   after_cit => '</div>',
		   before_text => '<div class="text">',
		   before_text_with_cit => '<div class="text-noindent">',
		   after_text => '</div>',
		   before_cit_hit => '<div class="citation" id="hit">',
		   after_cit_hit => '</div>',
		   before_text_hit => '<div class="text-noindent" id="hit">',
		   before_note => '<div class="special-note">',
		   after_note => '</div>',
		 },
		 ascii =>
		 { before_cit => '',
		   after_cit => "FILL",
		   before_text => ' ' x $fill_spaces,
		   before_text_with_cit => "",
		   after_text => '',
		   before_cit_hit => '',
		   after_cit_hit => 'FILL',
		   before_text_hit => "",
		   before_note => ' (',
		   after_note => ') ',
		 } );
#+end_src

** interleave_citations
#+begin_src interleave_citations
sub interleave_citations
{
    my $self = shift;
    my $buf = shift;
    $$buf =~ s/\n$//;
#     print STDERR $$buf;
    my @cites;
    push @cites, $self->build_citation('first');
    for ($i = 0; $i <= length $$buf; $i++ ) 
    {
	  $code = ord (substr ($$buf, $i, 1));
	  next unless ($code >> 7); # high bit set
	  $self->parse_non_ascii ($buf, \$i);
	  my $cit = $self->build_citation;
	  # print STDERR "]]$cit\n";
	  # print STDERR "]]".substr ($$buf, $i, 10)."\n";
	  push @cites, $cit;
    }
    # Just eliminate the last citation, as it tends to cause problems
    my $last = pop @cites;
    push @cites, $self->build_citation('last');
    push @cites, $cite_info{$self->{output_format}}{after_text};

    return \@cites;
}
#+end_src

** build_citation
#+begin_src perl
sub build_citation
{
    my $self = shift;
    my $pos = shift || '';
    my $format = $self->{output_format};
    my $cit = $self->maybe_use_cit;
    my $note = $self->{special_note};
    if ($note) {
	  $self->format_output(\$note, 'l');
	  $note = $cite_info{$format}{before_note} . $note . $cite_info{$format}{after_note};
    }
    else {
	  $note = '';
    }
    if ($pos eq 'last')
    {
	  return $cite_info{$format}{after_text} . $cite_info{$format}{before_text}; 
    }
    my $output = '';
    unless ($pos eq 'first')
    {
	  $output .=
	      $cite_info{$format}{after_text} 
    }

    $output .= $note;
    if ($cit and $self->{target_citation} and $cit eq $self->{target_citation})
    {
	  if ($cite_info{$format}{after_cit_hit} eq 'FILL') {
	      $output .=
		  $cite_info{$format}{before_cit_hit} .
		  $cit .
		  ' ' x ($fill_spaces - length $cit).
		  $cite_info{$format}{before_text_hit};
	  } else {
	      $output .=
		  $cite_info{$format}{before_cit_hit} .
		  $cit .
		  $cite_info{$format}{after_cit_hit}.
		  $cite_info{$format}{before_text_hit};
	  }
    }
    elsif ($cit)
    {
	  if ($cite_info{$format}{after_cit} eq 'FILL') {
	      $output .=
		  $cite_info{$format}{before_cit} .
		  $cit .
		  ' ' x ($fill_spaces - length $cit).
		  $cite_info{$format}{before_text_with_cit}; 
	  } else {
	      $output .=
		  $cite_info{$format}{before_cit} .
		  $cit .
		  $cite_info{$format}{after_cit}.
		  $cite_info{$format}{before_text_with_cit};
	  }
    }
    else
    {
	  $output .=
	      $cite_info{$format}{before_text}; 
    }
    return $output;
}
#+end_src

** maybe_use_cit
#+begin_src perl
sub maybe_use_cit
{
    my $self = shift;
    my $cit = $self->get_citation;
    my ($higher, $line);
    if ($cit =~ m/^(.*)\.(\d+)$/) {
	  $higher = $1;
	  $line = $2;
    } else {
	  $higher = "";
	  $line = "";
    }
    my $output = '';
    unless ($higher and $line) {
	  # For works with only line numbers and no higher levels
	  if ($cit =~ m/^(\d+)$/) {
	      $line = $1;
	  }
    }
    return '' unless $line;
    $self->{higher_levels} = $higher unless $self->{higher_levels};
#     print STDERR "($higher)\n";
#     print STDERR "+--$higher +++ $line\n";
    if ($self->{work_num} != $self->{current_work})
    {
	  $self->{current_work} = $self->{work_num};
	  $output = $work{$self->{type}}{$self->{auth_num}}{$self->{work_num}} . ' ';
    }
    if ($output or ($self->{higher_levels} and $higher ne $self->{higher_levels}))
    {
	  $self->{higher_levels} = $higher;
	  $output .= $higher . '.' . $line;
    }
    elsif ($line % $self->{line_print_modulus} == 0
	     or
	     $cit and $self->{target_citation} and $cit eq $self->{target_citation}
	     or
	     $self->{last_line} and $line != $self->{last_line} + 1 )
    {
	   # use this to just print the line number; but it looks a bit odd in prose 
#         $output .= $line;
	  $output .=  $higher ? $higher . '.' . $line : $line;
    }

    $self->{last_line} = $line;

    return $output;
}
#+end_src

  
** browse_half_backward
#+begin_src perl
sub browse_half_backward
  {
      # The first time the browser is called, we usually want to move
      # half a page backward.
      my $self = shift;
      my @args = @_;
      my $lines = $self->{browse_lines};
      $self->{browse_lines} = $lines/2 - 2;
      $self->{browse_backwards_scan} = 1;
      my @location = $self->browse_backward(@args);
      my @a = ($location[0], -1, $args[2], $args[3]);
      print STDERR join '--', @a if $self->{debug};
      $self->{browse_lines} = $lines;
      $self->{browse_backwards_scan} = 0;
      $self->{browse_end} = -1;
      return $self->browse_forward(@a);
  }

#+end_src

** browse_backward
Method to print out the lines immediately preceding the previously
specified point in our work.  With browse_backwards_scan, just scan
backwards and do not print anything.

#+begin_src perl
sub browse_backward 
{
    my $self = shift;
    my ($abs_begin, $abs_end, $auth, $work);
    my ($ref, $begin, $end, $line, $result, $buf, $offset);
    
    if (ref $self eq 'Diogenes::Browser')
    {   # Get persistent browser info from object
        $ref = $self->{browse_buf_ref};
        $end = $self->{browse_begin};
        $self->{browse_end} = $end;
        $offset = 0;
    }
    elsif (ref $self eq 'Diogenes::Browser::Stateless')
    {       # Browser info is passed as arguments
        ($abs_begin, $abs_end, $auth, $work) = @_;
        $auth = 1 if  $self->{type} eq 'bib' and $auth =~ m/9999/;
        
        $end = $abs_begin;
        $self->{current_work} = $work;
        $self->parse_idt ($auth);
        $self->{browse_auth} = $auth;
        $self->{browse_work} = $work;
        
        # open the file and seek to the beginning of the first block containing
        # our start-point
        open INP, "$self->{cdrom_dir}$self->{file_prefix}$auth$self->{txt_suffix}" or
            $self->barf("Couldn't open $self->{file_prefix}$auth$self->{txt_suffix}");
        binmode INP;
        
        my $end_block = $end >> 13;
        # read four 8k blocks -- should be enough!
        my $blocks = 4;
        my $start_block = $end_block - $blocks + 1;
        $start_block = 0 if $start_block < 0;
        $offset = $start_block  << 13;
        seek INP, $offset, 0;

        my $amount = 8192 * $blocks;
        read INP, $buf, $amount or 
            die "Could not read from file $self->{file_prefix}$auth.txt!\n" ;
        
        close INP or die "Couldn't close $self->{file_prefix}$auth.txt";
        $ref = \$buf;
        $self->{browse_end} = $end;
        $end = $end - $offset;
    }
    else
    { 
        die "What is ".ref $self."?\n";
    }
    
    $begin = $end;

    # Seek to beginning of any preceding  non-ascii block
    while (ord (substr ($$ref, --$begin, 1)) >> 7)  { };
        
    # find the right length of chunk
  CHUNK:
    for ($line = 0; 
         ($line <= $self->{browse_lines}) and ($begin > 0);
         $begin--) 
    {
        next if (ord (substr ($$ref, $begin, 1)) == 0);
        $line++ if ((ord (substr ($$ref, $begin, 1)) >> 7) and not
                    (ord (substr ($$ref, $begin - 1, 1)) >> 7)) ; 
        # for papyri, etc. get only one document at a time
        if ($self->{documentary} and ord (substr ($$ref, $begin, 1)) >= hex 'd0'
            and ord (substr ($$ref, $begin, 1)) <= hex 'df'
            and not ord (substr ($$ref, $begin - 1, 1)) >> 7)
        {       # Seek to end of non-ascii block beginning with \xd0 -- \xdf
            while (ord (substr ($$ref, $begin, 1)) >> 7)    { $begin++ };
            $begin--;
            last CHUNK;
        }
    }

    while (ord (substr ($$ref, ++$begin, 1)) >> 7)  { };

    $self->{browse_begin} = $offset + $begin;
    print STDERR "Beginning: $begin\n" if $self->{debug}; 
    return ($self->{browse_begin}, $self->{browse_end}) if $self->{browse_backwards_scan};
    
    my ($start_point, $end_point) = ($begin, $end);
    $result = substr ($$ref, $start_point, ($end_point - $start_point));
    my $base = ($self->{current_lang} eq 'g')
        ? '$'
        : '&';
    $result = $base . $result ;
    
    if ($self->print_location ($start_point + 1, $ref))
    {
        $self->{interleave_printing} = $self->interleave_citations(\$result);
        $self->print_output (\$result);
    }
    else
    {
        my @beginning = (0) x $self->{target_levels};
        my $ret = $self->seek_passage ($self->{browse_auth}, $self->{browse_work}, @beginning);
        if ($ret eq 'fail') {
            print "Passage not found!\n";
            return(0,0);
        }
        else {
            $self->browse_forward;
        }
    }
    # Store and pass back the start and end points of the whole session
    return ($self->{browse_begin}, $self->{browse_end});  # $abs_begin and $abs_end
}
#+end_src

** Diogenes::Browser::Stateless;
CGI File Browser

As above, except with CGI scripts we have to re-read the text, since
we don't want to hold it in memory between invocations.

Everything is delegated to the parent -- browse_forward and
browse_backward work somewhat differently and expect arguments

#+begin_src perl
package Diogenes::Browser::Stateless;
@Diogenes::Browser::Stateless::ISA = qw( Diogenes::Browser );
#+end_src

** END
#+begin_src perl
1;
#+end_src

* Diogenes::Indexed
** Präambel
#+begin_src perl
package Diogenes::Indexed;
use Diogenes::Base qw(%work %author %last_work %work_start_block);
@Diogenes::Indexed::ISA = ('Diogenes::Search');
#+end_src
** Variablen
#+begin_src perl
my ($tlgwlinx, $tlgwlist, $tlgwcinx, $tlgwcnts, $tlgawlst) =
    ('tlgwlinx.inx', 'tlgwlist.inx', 'tlgwcinx.inx', 
     'tlgwcnts.inx', 'tlgawlst.inx');
#+end_src
** read_index
#+begin_src perl
sub read_index 
{
    my $self = shift;
    my $pattern = shift;
    # Evidently some like to mount their CD-Roms in uppercase
    if ($self->{uppercase_files})
    {
        $tlgwlinx = uc $tlgwlinx;
        $tlgwlist = uc $tlgwlist;
        $tlgwcinx = uc $tlgwcinx;
        $tlgwcnts = uc $tlgwcnts;
        $tlgawlst = uc $tlgawlst;
    }

    $pattern = $self->{input_encoding} eq 'Unicode' ? $self->unicode_pattern($pattern) :
        $self->simple_latin_to_beta ($pattern);

    my ($ref, @wlist) = $self->parse_word_list($pattern);
    
    if ($self->{filtered} or $self->{blacklist_file})
    {
        # If we are selecting texts, find out what words are in our texts.
        $self->parse_wcnts(@wlist);
        my @new_wlist;
        # Keep Greek alphabetical order.
        map {$self->{found_word}{$_} and push @new_wlist, $_} @wlist;
        $ref = $self->{word_total};
        @wlist = @new_wlist;
    }
    
    return $ref, @wlist;
}
#+end_src
** do_search (Indexed)
#+begin_src perl
sub do_search 
{
    my $self = shift;
    
    $self->{pattern_list} = [];
    $self->{current_chunk} = 0;

    $self->{reject_pattern} = ($self->{input_encoding} eq 'Unicode') ?
        $self->unicode_pattern($self->{reject_pattern}) :
        $self->make_greek_pattern_from_translit($self->{reject_pattern});

    print STDERR "Using reject pattern: $self->{reject_pattern}\n" if $self->{debug}
                                                         and $self->{reject_pattern};
    my @wlist = @_;
    $self->parse_wcnts(@wlist);
    $self->make_big_regexp;
    
    $self->begin_boilerplate;
    my $retval = $self->do_word_search;
    $self->print_wlist_report($retval);
    $self->end_boilerplate;
    return $retval
}
#+end_src
** private subs and methods
*** parxe_wlinx                                                                             
Subroutine to calculate which blocks of the file tlgwlist.inx to            
search in, based upon the first two letters of the pattern (not counting    
diacritics, except for "'").  Eg. for the two letters AB, the first block   
to look in is the one indexed for AB, and the last is the one indexed AG.   
This leads to a certain amount of unneccessary searching, but it allows     
us to apply our regexp to a limited section of the large word list file.           
                                                                             
#+begin_src perl
sub parse_wlinx 
{
    my $self = shift;
        
    my ($pb_offset, $block);
    my ($pa_block, $pb_block) = (0, 0);
        
    # the order of the Greek alphabet in terms of its Roman representation in
    # BETA code ("'" is 1, who knows why?).
    my @gk = (2, 3, 16, 5, 6, 23, 4, 9, 11, 0, 12, 13, 14, 15, 17, 18, 10, 19, 20,
              21, 22, 7, 26, 24, 25, 8);                      
                        
    # A hash of the  Greek alphabet, each letter pointing to the next.
    my %incr = ('\'', 'A', 'A', 'B', 'B', 'G', 'G', 'D', 'D', 'E', 'E', 'Z', 'Z', 'H',
                'H', 'Q', 'Q', 'I', 'I', 'K', 'K', 'L', 'L', 'M', 'M',
                'N', 'N', 'C', 'C', 'O', 'O', 'P', 'P', 'R', 'R', 'S', 'S', 'T', 'T', 'U',
                'U', 'F', 'F', 'X', 'X', 'Y', 'Y', 'W', 'W', '\'');
        
    # get pattern, which should not include diacritics in its first two
    # letters, and make sure it is uppercase
    my $pattern = shift;
    # This input  must be at least 2 letters long 
    # (the index is indexed by the first 2 letters).
    $pattern =~ tr/a-z/A-Z/;
    die "Input pattern is not long enough (must be at least 2 letters).\n" 
        if $pattern =~ tr/A-Z'/A-Z'/ < 2;
    $pattern =~ tr/A-Z'//cd;
    print STDERR "pattern: $pattern\n" if $self->{debug};
    
    # @pa holds the first two letters of $pattern
    my @pa = (substr ($pattern, 0, 1), substr ($pattern, 1, 1));
        
    # generate starting offset
    my $pa_offset = ((($pa[0] eq '\'') ? 1 : $gk[(ord($pa[0]) - 65)]) - 1) * 27;
    $pa_offset += (ord($pa[1]) eq '\'') ? 1 : ($gk[(ord($pa[1]) - 65)]) + 1;

    # open the index to the word index and get the whole thing
    open WLINX, $self->{cdrom_dir}."$tlgwlinx" or 
        $self->barf("Could not open $self->{cdrom_dir}$tlgwlinx");
    binmode WLINX;
    local $/;
    undef $/;
    my $buf = <WLINX>;
    close WLINX or $self->barf("Couldn't close $tlgwlinx");

    # add up the cumulative data in the index to get block numbers for the
    # starting block.
    for (my $i = 0; $i < $pa_offset; $i++) 
    {
        $pa_block += ord (substr($buf, $i, 1));
    }
        
    # @pb gets the two letters in Greek alphabetical sequence after @pa 
    my @pb = @pa;

    # For some reason, degenerate cases in which one has impossible combinations 
    # of letters do not properly index to their imaginary place in the list.
    # Thus QH has many words, but QQ begins in the same block (681) as QH and
    # not where it should, which is in the block where QI starts -- where QQ
    # *would* be if there were any words that began with theta-theta.
    # So we have to keep incrementing letters until we find one that points to
    # a different block than the first set of letters.  This is wasteful and I
    # would regard it as a bug in the TLG index.
    while ($pb_block <= $pa_block) 
    {
        # `increment' the two letter string
        if ($pb[0] eq 'W' and $pb[1] eq 'W') 
        {   # end -- WW is the last two-letter group in the Greek alphabet
            last;
        }
        elsif ($pb[1] eq 'W') 
        {                               
            $pb[0] = $incr{$pb[0]};                 # eg. BW -> GA
            $pb[1] = 'A';                                           
        } 
        else 
        { 
            $pb[1] = $incr{$pb[1]};                 # the usual case: BB -> BG
        }
        
        # generate finishing offset
        $pb_offset = ((($pb[0] eq '\'') ? 1 : $gk[(ord($pb[0]) - 65)]) - 1) * 27;
        $pb_offset += (ord($pb[1]) eq '\'') ? 1 : ($gk[(ord($pb[1]) - 65)]) + 1;
        
        # add up the cumulative data in the index to get block numbers
        for (my $i = 0; $i < $pb_offset; $i++) 
        {
            $pb_block += ord (substr($buf, $i, 1));
        }
    }
    
    # return the starting and ending blocks between which to search
    print STDERR "@pa : @pb ;  $pa_block : $pb_block       \n" if $self->{debug};
    return ($pa_block, $pb_block);
}
#+end_src
*** parse_word_list 
Method to search the greek word-list for a pattern. 
                                                     
#+begin_src perl
sub parse_word_list 
{       
    my $self = shift;
    my $pattern = shift;
    
    my ($buf, $block, $data, $word, $word_hits, $last_pos, $word_num);
    my ($before, $tally, $i);
    my (%words, @word_list);
    
    # get the parts of the file to search
    print STDERR "1>$pattern \n" if $self->{debug};
    
    # modify pattern to match diacritics before and after each letter
    $pattern =~ tr/a-z/A-Z/;
    my $original_pattern = $pattern;
    $pattern =~ s#([A-Z][\\\\\)\(]*)#$1\[\'\\\\\/\+\(\)\|\!\=\]\*#g;
    #$pattern =~ s#^#\['!]\*#g;
        
    print STDERR "2>$pattern \n" if $self->{debug};

    my $start_pat = 0;
    # h looks ahead for a rough breathing 
    $start_pat++ if $pattern =~ s#\x072#(?=\\\(|[AEHIOWU/\\\\)=+?!|']+\\\()#gi;
    # non-rough breathing (possibly not at word beginning) 
    $pattern =~ s#\x071#(?!\\\(|[AEHIOWU/\\\\)=+?!|']+\\\()#gi;                
    $start_pat++ if $pattern =~ s#^\s+#(?<!['!A-Z)(/\\\\+=])#;
    $pattern =~ s#^#\['!A-Z)(/\\\\+=]\*#g unless $start_pat;
    $pattern =~ s#\s+$#(?!['!A-Z)(/\\\\+=])#;
        
    print STDERR "3>$pattern ($start_pat)\n" if $self->{debug};
        
    my ($start_block, $end_block);
    open WLIST, $self->{cdrom_dir}."$tlgwlist"
        or die("Couldn't open $self->{cdrom_dir}$tlgwlist: $!");
    binmode WLIST;
    if ($self->{use_tlgwlinx})
    {   # Use the index to the word list, only looking at the bit of the word-list 
        # containing the first two letters of our word.
        ($start_block, $end_block) = $self->parse_wlinx($original_pattern);
        seek WLIST, ($start_block * 8192), 0 or $self->barf("Couldn't seek in $tlgwlist");
    }
    else
    {   # Just read in the whole thing
        $start_block = 0;
        $end_block = (-s WLIST) / 8192 + 1;
    }
    print STDERR "WL: $pattern \n" if $self->{debug};
    $tally = 0;
    for ($block = $start_block; $block <= $end_block; $block++) 
    {
        # read each block
        # Must not check for errors here, because often end-block is way
        # beyond the end of the file. -- Not sure why.
        read WLIST, $buf, 8192;
        $last_pos = 0;
        $word_num = 0;
                
        # look for the pattern, capturing it and the non-ascii count data
        # preceding it
        while ($buf =~ m#([\x80-\xff]+)($pattern[\x20-\x60\x7c]*)#g) 
        {
            $data = $1;
            $word = $2; 
            $tally++;
                        
#            print "block: ".(sprintf "%lx", $block)."\n";
#            print "pos: " . (sprintf "%lx", pos $buf) . "\n";
            # parse the non-ascii data
            for ($i = 0, $word_hits = 0; $i < length ($data); $i++) 
            {
#                print "data: ".(ord (substr($data, $i, 1))-128)."\n";
#                print "old: ".($word_hits << 7)."\n";
                $word_hits = ($word_hits << 7) + (ord (substr($data, $i, 1)) - 128);
#                print "hits: $word_hits\n";
            }
            print STDERR "$word: $word_hits\n\n" if $self->{debug};
                        
            # count the number of words between this and the previous hit (or
            # start of block to determine the word number within this block
            
            $before = substr ($buf, $last_pos, ((pos $buf) - $last_pos));
            $word_num++ while ($before =~ m#[\x80-\xff]+#go);
                        
            # store the important data: the word found, the count data, the
            # block in was found in and the number within that block
            push @word_list, $word;
            $words{$word} = $word_hits;
            push @{ $self->{word_list}{$word} }, ($word_hits, $block, $word_num);
            $last_pos = pos $buf;
        }
    }
    close WLIST or $self->barf("Couldn't close $tlgwlist");
        
    return \%words, @word_list;
}       
#+end_src
*** get_word_info 
#+begin_src perl
sub get_word_info 
{
    my ($self, $word) = @_;
    return @{ $self->{word_list}{$word} };
}
#+end_src

*** parse_wcnts 
Method to calculate the authors and works in which a word found in the 
word list is to be located.                                                                                                                   
#+begin_src perl
sub parse_wcnts 
{
    my $self = shift;
    my ($word, $first_byte, $serial_num, $next_byte, $word_count, $aw_data);
    my ($offset, $first_char, $second_char, $third_char, $junk, $entry_length);
    my ($total_count, $block_num, $word_num, $author_num, $work_num, $length);
    my ($entry, $buf ,$i);
    $self->{list_total} = 0;

    # get the words to use 
    my @words;
    if (@_ == 1 or not ref $_[0])
    {
        # A simple list of words
        map { warn ("Bad input in word list: $_") if ref $_ } @_[1 .. -1];
        $self->{check_word_stats} = 1;
        push @words, ref $_[0] ? @{ $_[0] } : @_;
        $self->{word_set}[0] = [@words];
        $self->{single_list} = 1;
    }
    else
    {
        # A list of lists of words
        $self->{single_list} = 0;
        my $j = 0;
        foreach my $x (@_)
        {
            next unless $x;
            warn ("Bad input in word list: $x") if ref $x and ref $x ne 'ARRAY';
            $self->{check_word_stats} = 0;
            # A simple word becomes a one-element list
            $x = [$x] unless ref $x;
            $self->{word_set}[$j++] = $x;
            push @words, @{ $x };
        }
        print STDERR "<p>Words: @{$self->{word_set}[0]}<p>\n" if $self->{debug};
        print STDERR "<p>Words: @{$self->{word_set}[1]}<p>\n" if $self->{debug};
        
    }
    $self->{check_word_stats} = 0 if $self->{reject_pattern};
    
    $self->{min_matches_int} = $self->{min_matches};
    $self->{min_matches_int} = 1 if $self->{min_matches} eq 'any';
    $self->{min_matches_int} =  scalar @{ $self->{word_set} } if 
        $self->{min_matches} eq 'all';

    print STDERR "MM: $self->{min_matches}\n" if $self->{debug};
    print STDERR "MMI: $self->{min_matches_int}\n" if $self->{debug};
    
    print STDERR Data::Dumper->Dump([$self->{word_set}]), "\n" if $self->{debug};  
    # open the index files
    open WCINX, $self->{cdrom_dir}."$tlgwcinx" or $self->barf("Couldn't open $tlgwcinx");
    binmode WCINX;
    open WCNTS, $self->{cdrom_dir}."$tlgwcnts" or $self->barf("Couldn't open $tlgwcnts");
    binmode WCNTS;
    open AWLST, $self->{cdrom_dir}."$tlgawlst" or $self->barf("Couldn't open $tlgawlst");
    binmode AWLST;
    
    # We may want to blacklist some authors
    my $blacklist = '';
    if ($self->{blacklist_file})
    {
        open BL, "<$self->{blacklist_file}" or 
            die "Couldn't open blacklist file: $self->{blacklist_file}: $!\n";
        {
            local $/;
            undef $/;
            $blacklist = <BL>;
        }
    }
    
    my ($current_block, $current_word_num) = (-1, -1);
    # iterate through the list
    foreach $word (@words) 
    {
        # get the info for this word
        ($total_count, $block_num, $word_num) = @{ $self->{word_list}{$word} };
        
        # Skip if we already have the info stored.
        next if $self->{found_word}{$word};
        return if $Diogenes_Daemon::flag and not print ("\0");
        
        # An important optimization is to check to see if this is the next word in the
        # current block, in which case, we just read the next record.  If you feed back
        # the words to this routine in the same order in which they were output, this will
        # generally be the case.  If not, we have to reseek to the start of the block and 
        # reparse the file up to the word number.
        
        print STDERR ">> $block_num: $word_num ($word)\n" if $self->{debug};
        print STDERR "|| $current_block: $current_word_num\n\n" if $self->{debug};
        unless ($block_num == $current_block and $word_num == $current_word_num + 1)
        {
            # get the offset data (based on the block number in the word list)
            seek WCINX, ($block_num * 4), 0 or $self->barf("Couldn't seek in $tlgwcinx");
            read WCINX, $offset, 4 or $self->barf("Couldn't read from $tlgwcinx");
            
            # the offset data (32 bits) is big-endian 
            $offset = unpack "N", $offset;
            
            # seek in the big nasty file with all the data to the offset for our
            # block
            seek WCNTS, $offset, 0 or $self->barf("Couldn't seek in $tlgwcnts");
            $current_block = $block_num;
            
            # we now must read every entry in this section of the file (the only one
            # which is not itself broken into 8k blocks, unfortunately) beacuse the
            # entries are of variable length and apparently are not indexed, until we 
            # come to our word
            
        
            for ($i = 1; $i < $word_num; $i++) 
            {
#                 print STDERR "] $offset: $i ($word)\n" if $self->{debug};
                # ignore `word form byte' (whatever that is)
                read WCNTS, $junk, 1 or $self->barf("Couldn't read from $tlgwcnts");
                
                # the next byte(s) give the length of this entry (which we want to
                # skip)
                read WCNTS, $length, 1 or $self->barf("Couldn't read from $tlgwcnts");
                $entry_length = ord ($length); 
                if ($entry_length & hex("80")) 
                {
                    read WCNTS, $next_byte, 1 or 
                        $self->barf("Couldn't read from $tlgwcnts");
                    $entry_length = (($entry_length & hex("7f")) << 8 ) + 
                        ord ($next_byte);
                }
                                
                # now we seek past the rest of this entry
                seek WCNTS, $entry_length, 1 or 
                    $self->barf("Couldn't seek through $tlgwcnts");
            }
        }
        $current_word_num = $word_num;
        $self->{word_total}{$word} = 0;
        
        # We should now be at the entry we are interested in
                
        # ignore `word form byte'
        read WCNTS, $junk, 1 or $self->barf("Couldn't read from $tlgwcnts"); 
        # the next byte(s) give the length of our entry 
        read WCNTS, $length, 1 or $self->barf("Couldn't read from $tlgwcnts");
        $entry_length = ord ($length);
        if ($entry_length & hex("80")) 
        {
            read WCNTS, $next_byte, 1 or $self->barf("Couldn't read from $tlgwcnts");
            $entry_length = (($entry_length & hex("7f")) << 8 ) + 
                ord ($next_byte);
        }
        # read the rest of the entry into $buf and close the file
        read WCNTS, $buf, $entry_length or $self->barf("Couldn't read from $tlgwcnts");
                
        # go back to the start of the index of authors and works
        seek AWLST, 0, 0 or $self->barf("Couldn't seek to the start of $tlgawlst");
        
        my $entry = 0;          # An index for the entries in the author/work file.
        my $running_count = 0;  # We add the number of hits reported for each work
        # and compare this total against the total
        # reported in the word list. 
        my $i = -1;                             # This is an index into $buf
      ENTRY:  
        while ($i < $entry_length - 1) 
        {
            # first we get a serial code number which is a pointer to a (cumulative)
            # offset within another file (tlgawlst.inx) that encodes the author/work
            # combinations 
                        
            $first_byte = substr ($buf, ++$i, 1);
            $serial_num = ord ($first_byte);
            if ($serial_num & hex("80")) 
            {
                $next_byte = substr ($buf, ++$i, 1);
                $serial_num = (($serial_num & hex("7c")) << 6 ) + ord ($next_byte);
            }
            else 
            {
                $serial_num = $serial_num >> 2;
            }
            
            # now we get the number of times our word is found in the
            # author/work combination under present consideration
                        
            $word_count = ord ($first_byte) & hex("03");
            if ($word_count == 0) 
            {
                $word_count = substr ($buf, ++$i, 1);
                $word_count = ord ($word_count);
                if  ($word_count & hex("80")) 
                {
                    $next_byte = substr ($buf, ++$i, 1);
                    $word_count = (($word_count - hex("80")) << 8 ) + 
                        ord ($next_byte);
                }
                elsif ($word_count == 0) 
                {
                    $word_count = substr ($buf, ++$i, 1);
                    $next_byte = substr ($buf, ++$i, 1);
                    $word_count = ((ord ($word_count)) << 8) + ord ($next_byte);
                }
            }
            
                
            # the serial numbers begin from 1, not 0.  If the serial num is 1,
            # then it indicates the next work of this author -- we want that
            # to go to 0, so that we don't seek forward and skip anything at all, 
            # and the next read will just get the next 3 bytes in tlgawlst.inx.
            $serial_num = $serial_num - 1;
            print STDERR "Serial Num: $serial_num; " if $self->{debug};
            
            # each record in tlgawlst.inx, the file containing a sequential list
            # of the codes for each author/work combination in the TLG is three 
            # bytes long
            $offset = (3 * $serial_num);
            
            # the offset is cumulative; we go forward in the file relative to the
            # last author/work combination in which our word was found
            seek AWLST, $offset, 1 or $self->barf("Couldn't seek in $tlgawlst");
            read AWLST, $aw_data, 3 or $self->barf("Couldn't read from $tlgawlst");
                        
            # decode the three bytes to yield the author number, work number and
            # the number of times our word is found within that work.
            # The first byte gives the more significant bits ( > 6) of the author number;
            # the second byte contains the lower six bits of the author
            # number, and its two low bits are the more significant bits 
            # of the work number, whose low byte is the third byte.
            $first_char = ord (substr ($aw_data, 0, 1));
            $second_char = ord (substr ($aw_data, 1, 1));
            $third_char = ord (substr ($aw_data, 2, 1));
            $author_num = ($first_char << 6) + ($second_char >> 2);
            $work_num = (($second_char & hex("03")) << 8) + $third_char;
            
            $author_num = sprintf '%04d', $author_num;
            $work_num = sprintf '%03d', $work_num;
            
            print STDERR "Auth: $author_num; Work: $work_num; Word: $word; Word count: $word_count\n" if $self->{debug};
                
            # keep a running total, to make sure that we find all of the instances
            # that we should.
            $running_count += $word_count;
            $entry++;
            
            # Skip if we are selecting texts and this one was not chosen.
            next ENTRY if $self->{filtered} and 
                not ($self->{req_authors}{$author_num} 
                     or $self->{req_auth_wk}{$author_num}{$work_num} );
            if ($blacklist)
            {
                if ($blacklist =~ m/$self->{tlg_file_prefix}$author_num/i)
                {
                    print STDERR "Skipping blacklisted author: $author_num\n" if 
                        $self->{debug};
                    next ENTRY;
                }
            }
                        
            $self->{word_counts}{$author_num}{$work_num}{$word} = $word_count;
            $self->{word_total}{$word} += $word_count;
            $self->{found_word}{$word} = 1;
            # using this for testing ...
            $self->{temp_var}{$word}{$author_num} = 1;
        }
        if ($running_count != $total_count) 
        {
            # if the totals don't jibe, halt
            if ($word eq 'KAI/')
            {
                warn("\nWord-list totals don't agree for $word: this is a known error.\n");
            }
            else
            {
                warn( 
#                       $self->barf( 
"\n\n#########################################################################\n".
"ERROR: For the word $word ". 
"The total count in the word list is $total_count, ".
"but I only see $running_count in $tlgwcnts.\n\n".
"Please send a copy of ".
"this error message to the author of the program.\n".
"Diogenes version ($Diogenes::Base::Version).".
"\n#########################################################################\n\n");
            }
        }
    } # end of the iteration for each word
    continue
    {
        # Add the total of words selected form list
        $self->{list_total}     += $self->{word_total}{$word};
    }

    close AWLST or $self->barf("Couldn't close $tlgawlst");
    close WCNTS or $self->barf("Couldn't close $tlgwcnts");
    close WCINX or $self->barf("Couldn't close $tlgwcinx");
        
#     print STDERR Data::Dumper->Dump([$self->{word_counts}], ['word_counts']) if $self->{debug};
    # return the number of works in which the word was found (went one too
    # far)
    return --$entry;
}
#+end_src

*** make_big_regexp
#+begin_src perl
sub make_big_regexp
{
    my $self = shift;
    # Construct the mammoth regexps to test for all patterns in each set, in
    # descending order of length.   
    
    foreach my $set (@{ $self->{word_set} })
    {
        my $pattern = '';
        foreach my $word (sort {length $b <=> length $a } @{ $set })
        {       
            # Skip if word was not found in the selected texts
            next unless $self->{found_word}{$word};
            my ($lw, $w) = $self->make_tlg_regexp ($word);
            $self->{tlg_regexps}{$word} = $lw;
            $pattern .= '(?:' . $w . ')|';
        }
        if ($pattern) {
            chop $pattern;
            $pattern = $Diogenes::Indexed::lookback . $pattern;
            print STDERR "Big pattern: $pattern \n" if $self->{debug};
            push @{ $self->{pattern_list} }, $pattern;
        }
    }
}
#+end_src

*** ??? workarounds?
#+begin_src perl
# $lookback is used globally in order to exclude bits with preceding word
# elements any hyphenation, and to catch leading accents and asterisks (prefix
# must not be used globally, for it causes a major efficiency hit).  Revised to
# skip such things as PERI- @1 BALLO/MENOS (0007, 041).  Watch out for
# PROS3BA/LLEIN.

# This is a sadly ad hoc procedure, which will not help us with
# eliminating SUM- (lots of binary data) BAI/NEI (0086, 014) across
# blocks.  When Perl has variable-length, zero-width lookbehind, we
# will be able to fix this.  Had to remove (?<![!\]]), as it
# improperly rejects some words.

my $usedch = '\\x27-\\x29\\x2f\\x3d\\x41-\\x5a\\x7c';


# This is the RIGHT line:
#$Diogenes::Indexed::lookback = '(?<!S\d)(?<!\-\ [@"]\d\ [\\x80-\\xff])(?<!\-[\\x80-\\xff][@"]\d)(?<!\-[\\x80-\\xff][@"])(?<!\-[\\x80-\\xff][\\x80-\\xff])(?<!\-[\\x80-\\xff])(?<!['.$usedch.']\\*)(?<!['.$usedch.'])';
# This is the workaround for the TLG disk e hyphenation bug:
$Diogenes::Indexed::lookback = '(?<!S\d)(?<!\-\ [@"]\d\ [\\x80-\\xff])(?<!\-[\\x80-\\xff][\\x80-\\xff])(?<!\-[\\x80-\\xff])(?<!['.$usedch.']\\*)(?<!['.$usedch.'])';
#+end_src


*** make_tlg_regexp
Method to generate a regular expression that corresponds to
the TLG word list's definition of a `word' from the word as 
it appears in the word-list.                                
                                                             
#+begin_src perl
sub make_tlg_regexp 
{
    my ($self, $word, $not_begin, $not_end) = @_;
    # $not_begin and $not_end inhibit search for word-boundaries, front and end.
        
    my ($front, $sep, $back);
    my $diacrits = '\/\\\\\=\+\?\!\)\(\|\'';
        
    # Copy args if passed, otherwise assume full word with boundaries
    my $begin = $not_begin ? 1 : 0;
    my $end   = $not_end   ? 1 : 0;
                                
    my $vow = 'AEHIOWU';
    my $cons = 'BCDFGKLMNPQRSTVXYZ';

    # These are the bytes which do not appear in the word list. I (added "/"),
    # because of the bug shown by BRUXW/O(/)MENOS in 5014.  This, however,
    # produces many false positives where the word is meant to have no accent.
    # Added also "(" and ")", because there are sometimes breathings mid-word.
    # Added apostrophe as well.  Removed / and addressed the problem below. 
    # Removed space and \ 
    my $unused =
'\\x02-\\x19\\x22-\\x27\\x28-\\x2e\\x30-\\x3c\\x3e-\\x40\\x5b\\x5d-\\x7b\\x7d-\\xff';
    # these are the characters used in the word list
    my $used = '\\x21\\x27-\\x29\\x2f\\x3d\\x41-\\x5a\\x7c';
    my $unused_plus_space =
'\\x02-\\x20\\x22-\\x27\\x28-\\x2e\\x30-\\x3c\\x3e-\\x40\\x5b\\x5d-\\x7b\\x7d-\\xff';

    $word = quotemeta $word;
    $word =~ s/(?:\\\s)+/ /g;               # other spaces (not at start or end)
    print STDERR "Quotemeta: $word \n\n" if $self->{debug};

    # Unfortunately, early works in the corpus like Euripides have things like 
    # *)AMAZO/- ^250{[STR.} .^63NWN for *)AMAZO/NWN.
    # We make allowance first for hyphenation, with line breaks and block breaks
    # in between.  We then allow for anything else intervening between any two
    # letters: formatting codes, etc. 
    # This part of the regexp is the primary cause of the program's slowness.
    # Must allow for BA?- ...SKOPAI/, with ? before the hyphenation.
    # Also Latin strings: eg. A)NAI/- ^288{&Str. 2.$} .^63DEIAN
        
    # We allow for anything to intervene after a -, until there us a $used letter.
    # this didn't work for the Euripides example above
    #my $mid_word = "[?+]?(?:\-(?:[\\x00-\\xff](?![$used])|(?:\&[^\$]+))*[\\x00-\\xff])?[$unused]*";
    #Instead, we allow any non-binary data between a hyphen and some binary
    #Why did I abandon this solution earlier?
    my $mid_word = "[?+]?(?:\-(?:[\\x01-\\x7f]*[\\x00\\x80-\\xff]+))?[$unused]*";
                        
    # permit non-(alphabetic & diacritical) bytes to intervene
    $word =~ s#([$used])(?!$)#$1$mid_word#g;
    # spaces between words
    $word =~ s# (?!$)# [$unused_plus_space]*#g;
    print STDERR "Mid-word: $word\n\n" if $self->{debug};
    
    # ! (papyrus dot) at beginning or end is often ] or [ in the
    # texts, in which case we know that that is where the `word'
    # ends. v.9: added dot "." for tlg e
    my $front_dot = '[\!\]\.]+';
    $begin++ if $word =~ s#^(?:\\\!)#$front_dot#;
    #$begin++ if $word =~ s#^(?:\\\!)#\[\\!\\\]\\.\]\+#;
    # This is the RIGHT line:
    #$end++ if $word =~ s#(?:\\\!)$#\[\\!\\\[\\.\]#;
    # This is a workaround for TLG E hyphenation bug:
    # allow a word ending in ! to end at a hyphenation and a quote on the new line
    $end++ if $word =~ s#(?:\\\!)$#(?:\[\\!\\\[\\.\]|-(?=[\\d\\x80-\\xff\\x00]*\")|-(?=[_ .!\\]\\d\\x80-\\xff\\x00]*\\\]))#;
    print STDERR "!: $word\n\n" if $self->{debug};
                                
    # allow for capitalized words with diacritics moved in front
    $word =~
#               s#^([AEHIOWUR])\Q$mid_word\E(\\(?:\)|\())\Q$mid_word\E([\\\/=+|]*)#\(\?\:$1$2$3\|\\\*$2$3$1\)$mid_word#;
#               s#(^(?:\Q$front_dot\E)?(?:\Q$mid_word\E)?)([AEHIOWUR])\Q$mid_word\E(\\(?:\)|\())\Q$mid_word\E([\\\/=+|]*)#\(\?\:$1$2$3$4\|$1\\\*$3$4$2\)$mid_word#;
        s#(\b(?:\Q$front_dot\E)?(?:\Q$mid_word\E)?)([AEHIOWUR])\Q$mid_word\E(\\(?:\)|\())\Q$mid_word\E([\\\/=+|]*)#\(\?\:$1$2$3$4\|$1\\\*$3$4$2\)$mid_word#;
                                
    ##################################################################
    #                                                                #
    #  let oxytone accent become barytone:                           #
    # $word =~ s#\\\/$#\[\\/\\\\\]# or                               #
    #                $word =~ s#\\\/([^AEHIOWU]+)$#\[\\/\\\\\]$1#;   #
    #  The above would be more grammatical, but the TLG converts all #
    #  grave accents in the text to acute in the index, even when    #
    #  they are not on the final syllable, as in pseuo-word          #
    #  artifacts like KATALHKTIKO/NON, from KATALHK-TIKO\N[1O/N]1    #
    #  in 5014, 007.                                                 #
    #                                                                #
    ##################################################################
    $word =~ s#\\\/#\[\\/\\\\\]#g;
                        
    # allow for r)r( mid-word.
    $word =~ s#\*R#\*R\[\\(\\)]\?#g;
    print STDERR "rr: $word\n\n" if $self->{debug};
                                
                                
    #############################################################################
    #                                                                           #
    #  allow for accents thrown back from following enclitic                    #
    # if ($word_key =~ m#\/[\|$cons]*[$vow]+[$cons]*[$vow]+[$cons]*$            #
    #                        or $word_key =~ m#\=[\|$cons]*[$vow]+[$cons]*$#) { #
    #        # proparoxytone or properispomenon                                 #
    #        $word =~ s#(.*[$vow])#$1\\/?                                       #
    # }                                                                         #
    #  The above is the grammatically correct answer, but it fails              #
    #  in some cases, since apparently the TLG word list simply                 #
    #  strips the second accent from a `word', even from something              #
    #  like BRUXW/<6O/>6MENOS, where the second accent is really a              #
    #  variant, thus giving BRUXW/OMENOS in the word list.                      #
    #  So instead we allow any accent after any vowel after the                 #
    #  first accent (/=) in the word list entry.                                #
    #                                                                           #
    #############################################################################
                                
    $word =~ m#(.*)()#;
    $word =~ m#([^=/]*\\[=/])(.*)#;
    ($front, $back) = ($1, $2);
    print STDERR "Front: $front\nBack: $back\n\n" if $self->{debug};
    $back =~ s#([$vow])#$1\[\\=\\/\\\\\]?#g;
    $word = $front.$back;
    
# End of the regexp -- it is nearly the same as $used, except with the hyphen
# and with * added. We use a lookahead assertion, so that we don't step on the
# next search (in the case of *BRO/MIE *BRO/MIE, ktl.) We cannot end on a "*".
# We also allow ( because of words like A)GKONI/WAI( and KATANEU=AI( and we
# allow ) because of words like A)GLAI+ZE'QW), and diallow lower-case Latin so
# that the first letter of Anon. is not counted as an Alpha. If the pattern
# ends in a !, then we allow that.                        

# Added ] [ + and \ to the second group; had to delete + and ] and [
# We must allow AAA! before any word.

## For Disk E, we have to match A)POLOGHSAMEN!N, so allow anything to follow a final dot in the pattern
##      $end ?
##              $word =~
##              s/$/(?![\\x27\\x2a\\x2d\\x2f\\x3d\\x41-\\x5a\\x61-\\x7a\\x7c])/
##      :       $word =~
##              s/$/(?![\\x21\\x27\\x2a\\x2d\\x2f\\x3d\\x41-\\x5a\\x5c\\x61-\\x7a\\x7c])/;

    unless ($end)
    {
        $word =~
            s/$/(?![\\x21\\x27\\x2a\\x2d\\x2f\\x3d\\x41-\\x5a\\x5c\\x61-\\x7a\\x7c])/;
    }       
    my $full_word = $begin ? $word : $Diogenes::Indexed::lookback.$word;
    
    $word =~ s#^#\\*?#; # To catch leading capitalization
    
    # The first, longer regexp includes the lookback stuff that comes before
    # the word; the shorter one is for inclusion in a larger, compound regexp
    return ($full_word, $word);
}
#+end_src

*** do_word_search 

Method to do the actual search, using the data that has been gleaned 
from the TLG word list by other methods.                             

#+begin_src perl
sub do_word_search 
{
    my $self = shift;
    my ($author, $word, $work, $word_key, $author_num, $start_block, $end_block);
    my ($filename, $offset, $bare_word);
    $self->{current_chunk} = 0;
    print STDERR ">>", $self->{seen_author_list}, "\n";
    my %already_seen = map { $_ => 1 } @{ $self->{seen_author_list} };

    local $/;
    undef $/;
    my $buf;
    $self->{buf} = \$buf;
        
    # Loop through each author in which one or more of our words were found
    # (according to the word list)

   my @ordered_authors = ();
    if ($self->{tlg_use_chronology} and $self->{type} eq 'tlg') {
        foreach my $num (@{ $self->{tlg_ordered_authnums} }) {
            if (exists $self->{word_counts}{$num}) {
                push @ordered_authors, $num;
            }
        }
    }
    else {
        @ordered_authors = sort numerically keys %{ $self->{word_counts} };
    }

    foreach $author (@ordered_authors)
    {
        next if $already_seen{$author};

        $filename = $self->{file_prefix} . $author;
        # open the .txt file 
        open INP, "$self->{cdrom_dir}$filename$self->{txt_suffix}" 
            or $self->barf("Couln't open $filename$self->{txt_suffix}!");
        binmode INP;
        
        # loop through each work in which a match was found
      WORK:   foreach $work (sort keys %{ $self->{word_counts}{$author} }) 
      {
          my %counts = ();
          unless ($self->{single_list})
          {
              # Loop over the contents of each set, adding up hits in this work
              foreach my $set_num (0 .. $#{ $self->{word_set} })
              {
                  local $^W = 0; # no warnings for patterns not in this work
                  $counts{$set_num} += $self->{word_counts}{$author}{$work}{$_} 
                  for @{ $self->{word_set}[$set_num] };
              }
              print STDERR ((join ', ', values %counts), " | ") if $self->{debug};
              my $sets = grep { $_ > 0 } (values %counts);
              #print ">$sets\n";
              
              # Skip this work if a match is impossible here
              next WORK unless $sets >= $self->{min_matches_int};
          }
          # /Now/ parse .idt file
          $self->parse_idt($author);
          
          # get only those blocks of the file containing the work in question
          $start_block = $work_start_block{$self->{type}}{$author}{$work};
          $offset = $start_block << 13;
          seek INP, $offset, 0;
          if ($work == $last_work{$self->{type}}{$author})
          {
              $buf = <INP>;
              print STDERR "\nReading from $offset to the end of $filename.txt!\n" if $self->{debug};
              $self->barf ("Couln't read the rest of $filename!") unless
                  defined $buf;
          }
          else
          {
              # Subtle stringification wierdness here to make the 
              # automagic increment work right 
              my $next = "$work"; 
              ++$next;
              ++$next until 
                  exists ($work_start_block{$self->{type}}{$author}{$next});
              $end_block = $work_start_block{$self->{type}}{$author}{$next};
              print STDERR "\nReading from $offset to ", $end_block << 13, 
                  " of $filename.txt!\n" if $self->{debug};
              read INP, $buf, (($end_block - $start_block + 1) << 13) or
                  $self->barf ("Couln't read from $filename");
          }
                                                
          my @order;
          if ($self->{single_list})
          {
              @order = (0);
              $counts{0}++;
          }
          else
          {
              # Optimal searching order for sets within this work
              @order = sort { $counts{$a} <=> $counts{$b} } keys %counts;
              
              # Cut off needless sets at top end of list
              $#order = @{ $self->{word_set} } - $self->{min_matches_int};
          }
          foreach my $set_num (@order)
          {
              # Skip this set if there are no hits in it for this work
              next unless $counts{$set_num};
              
              foreach my $word_key (@{ $self->{word_set}[$set_num] })
              {
                  next unless $self->{word_counts}{$author}{$work}{$word_key};
                  print STDERR 
                      "\nSearching in $author{$self->{type}}{$author}, ", 
                      "$work{$self->{type}}{$author}{$work} for $word_key \n" if
                      $self->{debug};
                  $self->{word_key} = $word_key;
                  print STDERR "\nWord list entry: $word_key\n" if $self->{debug};
                  
                  # use in the form of a suitable regexp
                  $word = $self->{tlg_regexps}{$word_key};
                  print STDERR "Using pattern: $word in author $author\n\n" if 
                      $self->{debug};
                  # clear the last search
                  undef $self->{seen}{$author};
                  undef $self->{match_start}{$author};

                  return if $Diogenes_Daemon::flag and not print ("\0");
                                        
                  # this does the search, storing the locations in %seen
                  while ($buf =~ m#$word#g)
                  {
                      push @{ $self->{seen}{$author} }, (pos $buf);
                      push @{ $self->{match_start}{$author} }, $-[0];
                  }
                  
                  print STDERR "Seen: " . @{ $self->{seen}{$author} }. "\n" if 
                      $self->{seen}{$author} and $self->{debug};
                  # print the hits, after finding location and context
                  $self->{current_work} = $work;
                  $self->extract_hits($author);
                  if ($self->{check_word_stats} 
                      and $self->{word_counts}{$author}{$work}{$word_key} >
                      ($self->{hits_hash}{$author}{$work}{$word_key} || 0) )
                  {
                      # We have a false negative.  
                      if ($author eq '2892' and $work eq '110')
                      {   # Maximus Confessor
                          warn 
                              "Word list counts are off for author $author, work $work. ".
                              "This is a known error.\n\n";
                      }
                      else
                      {
                          warn (
        "ERROR: The TLG word list indicates that there ".
        "should be $self->{word_counts}{$author}{$work}{$word_key} instance(s)\n".
        "of the word $word_key for author number $author, work number $work, but \n".
        "Diogenes found " . ( $self->{hits_hash}{$author}{$work}{$word_key} || 0 ) .
        " of them.\n");
                      }
                  }
                  elsif ($self->{check_word_stats} 
                         and $self->{word_counts}{$author}{$work}{$word_key} <
                         $self->{hits_hash}{$author}{$work}{$word_key}) 
                  {
                      # We have one or more false positives.  
                      if ($word eq 'KAI/')
                      {
                          warn(
                              "\nWord-list totals don't agree for $word: ".
                              "this is a known error.\n");
                      }
                      else
                      {
                          my $inst = ($self->{hits_hash}{$author}{$work}{$word_key} -
                                      $self->{word_counts}{$author}{$work}{$word_key});
                          warn (
                              "WARNING: Diogenes found $inst extra instance".
                              ($inst == 1 ? '' : 's').
                              " of $word_key in author $author, work $work. \n");
                      }
                  }
              }
          }
      }
      close INP or $self->barf("Couln't close $filename!");
      push @{$self->{seen_author_list}}, $author;
      return $self->{seen_author_list} if $self->{current_chunk} > $self->{chunk_size};
    }
    return 'done';
}
#+end_src

*** print_word_search 
Uninteresting debugging subroutine
#+begin_src perl
sub print_word_search 
{
    my $self = shift;
    my $total = 0;
        
    my ($author, $word, $work);
        
    # This stuff is mostly for debugging
    foreach $author (sort numerically keys %{ $self->{word_counts} }) 
    {
        print STDERR "------------------------------ \n\n" if $self->{debug};
        print STDERR "author: $author \n" if $self->{debug};
        foreach $work (sort numerically keys %{ $self->{word_counts}{$author} }) 
        {
            foreach $word (sort keys %{ $self->{word_counts}{$author}{$work} }) 
            {
                print STDERR "word: $word \n" if $self->{debug};
                $total += $self->{word_counts}{$author}{$work}{$word};
                print STDERR "work: $work --> word count: $self->{word_counts}{$author}{$work}{$word} \n\n" if $self->{debug};
            }
        }
    }
    print "\n##########\n";
    print "Total instances reported by word list: $total\n";
    print "Total hits: $self->{hits}\n";
    print "##########\n\n";
}
#+end_src

*** print_wlist_report 
                                                                   
Method to print the overall results of a word-list search.        
It's expected that Diogenes may find more matches than            
anticipated, since it values comprehensiveness over selectivity.  
                                                                   
#+begin_src perl
sub print_wlist_report 
{
    my $self = shift;
    my $message = shift;
    my $output = "\&\nIncidence of all words as reported by word list: ";
    $output .= ($self->{list_total} || 0) . "\n";
    if ($message eq 'done') {
        $output .= "Passages containing those words reported by Diogenes: ";
    }
    else {
        $output .= "Cumulative total of passages containing those words found so far: ";
    }
    $output .= $self->{hits} || 0;
    $output .= "\n\n";
    $output .= "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n" 
        unless $self->{output_format} eq 'html';
    $self->print_output(\$output);
        
}
#+end_src

*** numerically
#+begin_src perl
sub numerically { $a <=> $b; }
#+end_src

** END
#+begin_src perl
1;
#+end_src

* Diogenes::UnicodeInput

** Präambel
#+begin_src perl
package Diogenes::UnicodeInput;
use vars '%unicode_equivs', '%upper_to_lower';
# use encoding 'utf8';
# use utf8;
no bytes;
#+end_src

** unicode-equivs.pl
#+begin_src perl
# do "unicode-equivs.pl" or die ($! or $@);
do "Diogenes/unicode-equivs.pl" or die ("Couldn't open unicode-equivs.pl; Run 'make' to build it. (error: $!)");
#+end_src

#+begin_src perl
# This is auto-generated by make_unicode_compounds.pl.  Do not edit.

%Diogenes::UnicodeInput::unicode_equivs = (
"\x{0386}" => ["\x{0391}", "\x{0301}"], 
"\x{0388}" => ["\x{0395}", "\x{0301}"], 
"\x{0389}" => ["\x{0397}", "\x{0301}"], 
"\x{038A}" => ["\x{0399}", "\x{0301}"], 
"\x{038C}" => ["\x{039F}", "\x{0301}"], 
"\x{038E}" => ["\x{03A5}", "\x{0301}"], 
"\x{038F}" => ["\x{03A9}", "\x{0301}"], 
"\x{0390}" => ["\x{03CA}", "\x{0301}"], 
"\x{03AA}" => ["\x{0399}", "\x{0308}"], 
"\x{03AB}" => ["\x{03A5}", "\x{0308}"], 
"\x{03AC}" => ["\x{03B1}", "\x{0301}"], 
"\x{03AD}" => ["\x{03B5}", "\x{0301}"], 
"\x{03AE}" => ["\x{03B7}", "\x{0301}"], 
"\x{03AF}" => ["\x{03B9}", "\x{0301}"], 
"\x{03B0}" => ["\x{03CB}", "\x{0301}"], 
"\x{03CA}" => ["\x{03B9}", "\x{0308}"], 
"\x{03CB}" => ["\x{03C5}", "\x{0308}"], 
"\x{03CC}" => ["\x{03BF}", "\x{0301}"], 
"\x{03CD}" => ["\x{03C5}", "\x{0301}"], 
"\x{03CE}" => ["\x{03C9}", "\x{0301}"], 
"\x{1F00}" => ["\x{03B1}", "\x{0313}"], 
"\x{1F01}" => ["\x{03B1}", "\x{0314}"], 
"\x{1F02}" => ["\x{1F00}", "\x{0300}"], 
"\x{1F03}" => ["\x{1F01}", "\x{0300}"], 
"\x{1F04}" => ["\x{1F00}", "\x{0301}"], 
"\x{1F05}" => ["\x{1F01}", "\x{0301}"], 
"\x{1F06}" => ["\x{1F00}", "\x{0342}"], 
"\x{1F07}" => ["\x{1F01}", "\x{0342}"], 
"\x{1F08}" => ["\x{0391}", "\x{0313}"], 
"\x{1F09}" => ["\x{0391}", "\x{0314}"], 
"\x{1F0A}" => ["\x{1F08}", "\x{0300}"], 
"\x{1F0B}" => ["\x{1F09}", "\x{0300}"], 
"\x{1F0C}" => ["\x{1F08}", "\x{0301}"], 
"\x{1F0D}" => ["\x{1F09}", "\x{0301}"], 
"\x{1F0E}" => ["\x{1F08}", "\x{0342}"], 
"\x{1F0F}" => ["\x{1F09}", "\x{0342}"], 
"\x{1F10}" => ["\x{03B5}", "\x{0313}"], 
"\x{1F11}" => ["\x{03B5}", "\x{0314}"], 
"\x{1F12}" => ["\x{1F10}", "\x{0300}"], 
"\x{1F13}" => ["\x{1F11}", "\x{0300}"], 
"\x{1F14}" => ["\x{1F10}", "\x{0301}"], 
"\x{1F15}" => ["\x{1F11}", "\x{0301}"], 
"\x{1F18}" => ["\x{0395}", "\x{0313}"], 
"\x{1F19}" => ["\x{0395}", "\x{0314}"], 
"\x{1F1A}" => ["\x{1F18}", "\x{0300}"], 
"\x{1F1B}" => ["\x{1F19}", "\x{0300}"], 
"\x{1F1C}" => ["\x{1F18}", "\x{0301}"], 
"\x{1F1D}" => ["\x{1F19}", "\x{0301}"], 
"\x{1F20}" => ["\x{03B7}", "\x{0313}"], 
"\x{1F21}" => ["\x{03B7}", "\x{0314}"], 
"\x{1F22}" => ["\x{1F20}", "\x{0300}"], 
"\x{1F23}" => ["\x{1F21}", "\x{0300}"], 
"\x{1F24}" => ["\x{1F20}", "\x{0301}"], 
"\x{1F25}" => ["\x{1F21}", "\x{0301}"], 
"\x{1F26}" => ["\x{1F20}", "\x{0342}"], 
"\x{1F27}" => ["\x{1F21}", "\x{0342}"], 
"\x{1F28}" => ["\x{0397}", "\x{0313}"], 
"\x{1F29}" => ["\x{0397}", "\x{0314}"], 
"\x{1F2A}" => ["\x{1F28}", "\x{0300}"], 
"\x{1F2B}" => ["\x{1F29}", "\x{0300}"], 
"\x{1F2C}" => ["\x{1F28}", "\x{0301}"], 
"\x{1F2D}" => ["\x{1F29}", "\x{0301}"], 
"\x{1F2E}" => ["\x{1F28}", "\x{0342}"], 
"\x{1F2F}" => ["\x{1F29}", "\x{0342}"], 
"\x{1F30}" => ["\x{03B9}", "\x{0313}"], 
"\x{1F31}" => ["\x{03B9}", "\x{0314}"], 
"\x{1F32}" => ["\x{1F30}", "\x{0300}"], 
"\x{1F33}" => ["\x{1F31}", "\x{0300}"], 
"\x{1F34}" => ["\x{1F30}", "\x{0301}"], 
"\x{1F35}" => ["\x{1F31}", "\x{0301}"], 
"\x{1F36}" => ["\x{1F30}", "\x{0342}"], 
"\x{1F37}" => ["\x{1F31}", "\x{0342}"], 
"\x{1F38}" => ["\x{0399}", "\x{0313}"], 
"\x{1F39}" => ["\x{0399}", "\x{0314}"], 
"\x{1F3A}" => ["\x{1F38}", "\x{0300}"], 
"\x{1F3B}" => ["\x{1F39}", "\x{0300}"], 
"\x{1F3C}" => ["\x{1F38}", "\x{0301}"], 
"\x{1F3D}" => ["\x{1F39}", "\x{0301}"], 
"\x{1F3E}" => ["\x{1F38}", "\x{0342}"], 
"\x{1F3F}" => ["\x{1F39}", "\x{0342}"], 
"\x{1F40}" => ["\x{03BF}", "\x{0313}"], 
"\x{1F41}" => ["\x{03BF}", "\x{0314}"], 
"\x{1F42}" => ["\x{1F40}", "\x{0300}"], 
"\x{1F43}" => ["\x{1F41}", "\x{0300}"], 
"\x{1F44}" => ["\x{1F40}", "\x{0301}"], 
"\x{1F45}" => ["\x{1F41}", "\x{0301}"], 
"\x{1F48}" => ["\x{039F}", "\x{0313}"], 
"\x{1F49}" => ["\x{039F}", "\x{0314}"], 
"\x{1F4A}" => ["\x{1F48}", "\x{0300}"], 
"\x{1F4B}" => ["\x{1F49}", "\x{0300}"], 
"\x{1F4C}" => ["\x{1F48}", "\x{0301}"], 
"\x{1F4D}" => ["\x{1F49}", "\x{0301}"], 
"\x{1F50}" => ["\x{03C5}", "\x{0313}"], 
"\x{1F51}" => ["\x{03C5}", "\x{0314}"], 
"\x{1F52}" => ["\x{1F50}", "\x{0300}"], 
"\x{1F53}" => ["\x{1F51}", "\x{0300}"], 
"\x{1F54}" => ["\x{1F50}", "\x{0301}"], 
"\x{1F55}" => ["\x{1F51}", "\x{0301}"], 
"\x{1F56}" => ["\x{1F50}", "\x{0342}"], 
"\x{1F57}" => ["\x{1F51}", "\x{0342}"], 
"\x{1F59}" => ["\x{03A5}", "\x{0314}"], 
"\x{1F5B}" => ["\x{1F59}", "\x{0300}"], 
"\x{1F5D}" => ["\x{1F59}", "\x{0301}"], 
"\x{1F5F}" => ["\x{1F59}", "\x{0342}"], 
"\x{1F60}" => ["\x{03C9}", "\x{0313}"], 
"\x{1F61}" => ["\x{03C9}", "\x{0314}"], 
"\x{1F62}" => ["\x{1F60}", "\x{0300}"], 
"\x{1F63}" => ["\x{1F61}", "\x{0300}"], 
"\x{1F64}" => ["\x{1F60}", "\x{0301}"], 
"\x{1F65}" => ["\x{1F61}", "\x{0301}"], 
"\x{1F66}" => ["\x{1F60}", "\x{0342}"], 
"\x{1F67}" => ["\x{1F61}", "\x{0342}"], 
"\x{1F68}" => ["\x{03A9}", "\x{0313}"], 
"\x{1F69}" => ["\x{03A9}", "\x{0314}"], 
"\x{1F6A}" => ["\x{1F68}", "\x{0300}"], 
"\x{1F6B}" => ["\x{1F69}", "\x{0300}"], 
"\x{1F6C}" => ["\x{1F68}", "\x{0301}"], 
"\x{1F6D}" => ["\x{1F69}", "\x{0301}"], 
"\x{1F6E}" => ["\x{1F68}", "\x{0342}"], 
"\x{1F6F}" => ["\x{1F69}", "\x{0342}"], 
"\x{1F70}" => ["\x{03B1}", "\x{0300}"], 
"\x{1F71}" => "\x{03AC}", 
"\x{1F72}" => ["\x{03B5}", "\x{0300}"], 
"\x{1F73}" => "\x{03AD}", 
"\x{1F74}" => ["\x{03B7}", "\x{0300}"], 
"\x{1F75}" => "\x{03AE}", 
"\x{1F76}" => ["\x{03B9}", "\x{0300}"], 
"\x{1F77}" => "\x{03AF}", 
"\x{1F78}" => ["\x{03BF}", "\x{0300}"], 
"\x{1F79}" => "\x{03CC}", 
"\x{1F7A}" => ["\x{03C5}", "\x{0300}"], 
"\x{1F7B}" => "\x{03CD}", 
"\x{1F7C}" => ["\x{03C9}", "\x{0300}"], 
"\x{1F7D}" => "\x{03CE}", 
"\x{1F80}" => ["\x{1F00}", "\x{0345}"], 
"\x{1F81}" => ["\x{1F01}", "\x{0345}"], 
"\x{1F82}" => ["\x{1F02}", "\x{0345}"], 
"\x{1F83}" => ["\x{1F03}", "\x{0345}"], 
"\x{1F84}" => ["\x{1F04}", "\x{0345}"], 
"\x{1F85}" => ["\x{1F05}", "\x{0345}"], 
"\x{1F86}" => ["\x{1F06}", "\x{0345}"], 
"\x{1F87}" => ["\x{1F07}", "\x{0345}"], 
"\x{1F88}" => ["\x{1F08}", "\x{0345}"], 
"\x{1F89}" => ["\x{1F09}", "\x{0345}"], 
"\x{1F8A}" => ["\x{1F0A}", "\x{0345}"], 
"\x{1F8B}" => ["\x{1F0B}", "\x{0345}"], 
"\x{1F8C}" => ["\x{1F0C}", "\x{0345}"], 
"\x{1F8D}" => ["\x{1F0D}", "\x{0345}"], 
"\x{1F8E}" => ["\x{1F0E}", "\x{0345}"], 
"\x{1F8F}" => ["\x{1F0F}", "\x{0345}"], 
"\x{1F90}" => ["\x{1F20}", "\x{0345}"], 
"\x{1F91}" => ["\x{1F21}", "\x{0345}"], 
"\x{1F92}" => ["\x{1F22}", "\x{0345}"], 
"\x{1F93}" => ["\x{1F23}", "\x{0345}"], 
"\x{1F94}" => ["\x{1F24}", "\x{0345}"], 
"\x{1F95}" => ["\x{1F25}", "\x{0345}"], 
"\x{1F96}" => ["\x{1F26}", "\x{0345}"], 
"\x{1F97}" => ["\x{1F27}", "\x{0345}"], 
"\x{1F98}" => ["\x{1F28}", "\x{0345}"], 
"\x{1F99}" => ["\x{1F29}", "\x{0345}"], 
"\x{1F9A}" => ["\x{1F2A}", "\x{0345}"], 
"\x{1F9B}" => ["\x{1F2B}", "\x{0345}"], 
"\x{1F9C}" => ["\x{1F2C}", "\x{0345}"], 
"\x{1F9D}" => ["\x{1F2D}", "\x{0345}"], 
"\x{1F9E}" => ["\x{1F2E}", "\x{0345}"], 
"\x{1F9F}" => ["\x{1F2F}", "\x{0345}"], 
"\x{1FA0}" => ["\x{1F60}", "\x{0345}"], 
"\x{1FA1}" => ["\x{1F61}", "\x{0345}"], 
"\x{1FA2}" => ["\x{1F62}", "\x{0345}"], 
"\x{1FA3}" => ["\x{1F63}", "\x{0345}"], 
"\x{1FA4}" => ["\x{1F64}", "\x{0345}"], 
"\x{1FA5}" => ["\x{1F65}", "\x{0345}"], 
"\x{1FA6}" => ["\x{1F66}", "\x{0345}"], 
"\x{1FA7}" => ["\x{1F67}", "\x{0345}"], 
"\x{1FA8}" => ["\x{1F68}", "\x{0345}"], 
"\x{1FA9}" => ["\x{1F69}", "\x{0345}"], 
"\x{1FAA}" => ["\x{1F6A}", "\x{0345}"], 
"\x{1FAB}" => ["\x{1F6B}", "\x{0345}"], 
"\x{1FAC}" => ["\x{1F6C}", "\x{0345}"], 
"\x{1FAD}" => ["\x{1F6D}", "\x{0345}"], 
"\x{1FAE}" => ["\x{1F6E}", "\x{0345}"], 
"\x{1FAF}" => ["\x{1F6F}", "\x{0345}"], 
"\x{1FB0}" => ["\x{03B1}", "\x{0306}"], 
"\x{1FB1}" => ["\x{03B1}", "\x{0304}"], 
"\x{1FB2}" => ["\x{1F70}", "\x{0345}"], 
"\x{1FB3}" => ["\x{03B1}", "\x{0345}"], 
"\x{1FB4}" => ["\x{03AC}", "\x{0345}"], 
"\x{1FB6}" => ["\x{03B1}", "\x{0342}"], 
"\x{1FB7}" => ["\x{1FB6}", "\x{0345}"], 
"\x{1FB8}" => ["\x{0391}", "\x{0306}"], 
"\x{1FB9}" => ["\x{0391}", "\x{0304}"], 
"\x{1FBA}" => ["\x{0391}", "\x{0300}"], 
"\x{1FBB}" => "\x{0386}", 
"\x{1FBC}" => ["\x{0391}", "\x{0345}"], 
"\x{1FC2}" => ["\x{1F74}", "\x{0345}"], 
"\x{1FC3}" => ["\x{03B7}", "\x{0345}"], 
"\x{1FC4}" => ["\x{03AE}", "\x{0345}"], 
"\x{1FC6}" => ["\x{03B7}", "\x{0342}"], 
"\x{1FC7}" => ["\x{1FC6}", "\x{0345}"], 
"\x{1FC8}" => ["\x{0395}", "\x{0300}"], 
"\x{1FC9}" => "\x{0388}", 
"\x{1FCA}" => ["\x{0397}", "\x{0300}"], 
"\x{1FCB}" => "\x{0389}", 
"\x{1FCC}" => ["\x{0397}", "\x{0345}"], 
"\x{1FD0}" => ["\x{03B9}", "\x{0306}"], 
"\x{1FD1}" => ["\x{03B9}", "\x{0304}"], 
"\x{1FD2}" => ["\x{03CA}", "\x{0300}"], 
"\x{1FD3}" => "\x{0390}", 
"\x{1FD6}" => ["\x{03B9}", "\x{0342}"], 
"\x{1FD7}" => ["\x{03CA}", "\x{0342}"], 
"\x{1FD8}" => ["\x{0399}", "\x{0306}"], 
"\x{1FD9}" => ["\x{0399}", "\x{0304}"], 
"\x{1FDA}" => ["\x{0399}", "\x{0300}"], 
"\x{1FDB}" => "\x{038A}", 
"\x{1FE0}" => ["\x{03C5}", "\x{0306}"], 
"\x{1FE1}" => ["\x{03C5}", "\x{0304}"], 
"\x{1FE2}" => ["\x{03CB}", "\x{0300}"], 
"\x{1FE3}" => "\x{03B0}", 
"\x{1FE4}" => ["\x{03C1}", "\x{0313}"], 
"\x{1FE5}" => ["\x{03C1}", "\x{0314}"], 
"\x{1FE6}" => ["\x{03C5}", "\x{0342}"], 
"\x{1FE7}" => ["\x{03CB}", "\x{0342}"], 
"\x{1FE8}" => ["\x{03A5}", "\x{0306}"], 
"\x{1FE9}" => ["\x{03A5}", "\x{0304}"], 
"\x{1FEA}" => ["\x{03A5}", "\x{0300}"], 
"\x{1FEB}" => "\x{038E}", 
"\x{1FEC}" => ["\x{03A1}", "\x{0314}"], 
"\x{1FF2}" => ["\x{1F7C}", "\x{0345}"], 
"\x{1FF3}" => ["\x{03C9}", "\x{0345}"], 
"\x{1FF4}" => ["\x{03CE}", "\x{0345}"], 
"\x{1FF6}" => ["\x{03C9}", "\x{0342}"], 
"\x{1FF7}" => ["\x{1FF6}", "\x{0345}"], 
"\x{1FF8}" => ["\x{039F}", "\x{0300}"], 
"\x{1FF9}" => "\x{038C}", 
"\x{1FFA}" => ["\x{03A9}", "\x{0300}"], 
"\x{1FFB}" => "\x{038F}", 
"\x{1FFC}" => ["\x{03A9}", "\x{0345}"], 
);

%Diogenes::UnicodeInput::upper_to_lower = (
"\x{0370}" => "\x{0371}", 
"\x{0372}" => "\x{0373}", 
"\x{0376}" => "\x{0377}", 
"\x{037F}" => "\x{03F3}", 
"\x{0386}" => "\x{03AC}", 
"\x{0388}" => "\x{03AD}", 
"\x{0389}" => "\x{03AE}", 
"\x{038A}" => "\x{03AF}", 
"\x{038C}" => "\x{03CC}", 
"\x{038E}" => "\x{03CD}", 
"\x{038F}" => "\x{03CE}", 
"\x{0391}" => "\x{03B1}", 
"\x{0392}" => "\x{03B2}", 
"\x{0393}" => "\x{03B3}", 
"\x{0394}" => "\x{03B4}", 
"\x{0395}" => "\x{03B5}", 
"\x{0396}" => "\x{03B6}", 
"\x{0397}" => "\x{03B7}", 
"\x{0398}" => "\x{03B8}", 
"\x{0399}" => "\x{03B9}", 
"\x{039A}" => "\x{03BA}", 
"\x{039B}" => "\x{03BB}", 
"\x{039C}" => "\x{03BC}", 
"\x{039D}" => "\x{03BD}", 
"\x{039E}" => "\x{03BE}", 
"\x{039F}" => "\x{03BF}", 
"\x{03A0}" => "\x{03C0}", 
"\x{03A1}" => "\x{03C1}", 
"\x{03A3}" => "\x{03C3}", 
"\x{03A4}" => "\x{03C4}", 
"\x{03A5}" => "\x{03C5}", 
"\x{03A6}" => "\x{03C6}", 
"\x{03A7}" => "\x{03C7}", 
"\x{03A8}" => "\x{03C8}", 
"\x{03A9}" => "\x{03C9}", 
"\x{03AA}" => "\x{03CA}", 
"\x{03AB}" => "\x{03CB}", 
"\x{03E2}" => "\x{03E3}", 
"\x{03E4}" => "\x{03E5}", 
"\x{03E6}" => "\x{03E7}", 
"\x{03E8}" => "\x{03E9}", 
"\x{03EA}" => "\x{03EB}", 
"\x{03EC}" => "\x{03ED}", 
"\x{03EE}" => "\x{03EF}", 
"\x{03F7}" => "\x{03F8}", 
"\x{03FA}" => "\x{03FB}", 
"\x{1F08}" => "\x{1F00}", 
"\x{1F09}" => "\x{1F01}", 
"\x{1F0A}" => "\x{1F02}", 
"\x{1F0B}" => "\x{1F03}", 
"\x{1F0C}" => "\x{1F04}", 
"\x{1F0D}" => "\x{1F05}", 
"\x{1F0E}" => "\x{1F06}", 
"\x{1F0F}" => "\x{1F07}", 
"\x{1F18}" => "\x{1F10}", 
"\x{1F19}" => "\x{1F11}", 
"\x{1F1A}" => "\x{1F12}", 
"\x{1F1B}" => "\x{1F13}", 
"\x{1F1C}" => "\x{1F14}", 
"\x{1F1D}" => "\x{1F15}", 
"\x{1F28}" => "\x{1F20}", 
"\x{1F29}" => "\x{1F21}", 
"\x{1F2A}" => "\x{1F22}", 
"\x{1F2B}" => "\x{1F23}", 
"\x{1F2C}" => "\x{1F24}", 
"\x{1F2D}" => "\x{1F25}", 
"\x{1F2E}" => "\x{1F26}", 
"\x{1F2F}" => "\x{1F27}", 
"\x{1F38}" => "\x{1F30}", 
"\x{1F39}" => "\x{1F31}", 
"\x{1F3A}" => "\x{1F32}", 
"\x{1F3B}" => "\x{1F33}", 
"\x{1F3C}" => "\x{1F34}", 
"\x{1F3D}" => "\x{1F35}", 
"\x{1F3E}" => "\x{1F36}", 
"\x{1F3F}" => "\x{1F37}", 
"\x{1F48}" => "\x{1F40}", 
"\x{1F49}" => "\x{1F41}", 
"\x{1F4A}" => "\x{1F42}", 
"\x{1F4B}" => "\x{1F43}", 
"\x{1F4C}" => "\x{1F44}", 
"\x{1F4D}" => "\x{1F45}", 
"\x{1F59}" => "\x{1F51}", 
"\x{1F5B}" => "\x{1F53}", 
"\x{1F5D}" => "\x{1F55}", 
"\x{1F5F}" => "\x{1F57}", 
"\x{1F68}" => "\x{1F60}", 
"\x{1F69}" => "\x{1F61}", 
"\x{1F6A}" => "\x{1F62}", 
"\x{1F6B}" => "\x{1F63}", 
"\x{1F6C}" => "\x{1F64}", 
"\x{1F6D}" => "\x{1F65}", 
"\x{1F6E}" => "\x{1F66}", 
"\x{1F6F}" => "\x{1F67}", 
"\x{1F88}" => "\x{1F80}", 
"\x{1F89}" => "\x{1F81}", 
"\x{1F8A}" => "\x{1F82}", 
"\x{1F8B}" => "\x{1F83}", 
"\x{1F8C}" => "\x{1F84}", 
"\x{1F8D}" => "\x{1F85}", 
"\x{1F8E}" => "\x{1F86}", 
"\x{1F8F}" => "\x{1F87}", 
"\x{1F98}" => "\x{1F90}", 
"\x{1F99}" => "\x{1F91}", 
"\x{1F9A}" => "\x{1F92}", 
"\x{1F9B}" => "\x{1F93}", 
"\x{1F9C}" => "\x{1F94}", 
"\x{1F9D}" => "\x{1F95}", 
"\x{1F9E}" => "\x{1F96}", 
"\x{1F9F}" => "\x{1F97}", 
"\x{1FA8}" => "\x{1FA0}", 
"\x{1FA9}" => "\x{1FA1}", 
"\x{1FAA}" => "\x{1FA2}", 
"\x{1FAB}" => "\x{1FA3}", 
"\x{1FAC}" => "\x{1FA4}", 
"\x{1FAD}" => "\x{1FA5}", 
"\x{1FAE}" => "\x{1FA6}", 
"\x{1FAF}" => "\x{1FA7}", 
"\x{1FB8}" => "\x{1FB0}", 
"\x{1FB9}" => "\x{1FB1}", 
"\x{1FBA}" => "\x{1F70}", 
"\x{1FBB}" => "\x{1F71}", 
"\x{1FBC}" => "\x{1FB3}", 
"\x{1FC8}" => "\x{1F72}", 
"\x{1FC9}" => "\x{1F73}", 
"\x{1FCA}" => "\x{1F74}", 
"\x{1FCB}" => "\x{1F75}", 
"\x{1FCC}" => "\x{1FC3}", 
"\x{1FD8}" => "\x{1FD0}", 
"\x{1FD9}" => "\x{1FD1}", 
"\x{1FDA}" => "\x{1F76}", 
"\x{1FDB}" => "\x{1F77}", 
"\x{1FE8}" => "\x{1FE0}", 
"\x{1FE9}" => "\x{1FE1}", 
"\x{1FEA}" => "\x{1F7A}", 
"\x{1FEB}" => "\x{1F7B}", 
"\x{1FEC}" => "\x{1FE5}", 
"\x{1FF8}" => "\x{1F78}", 
"\x{1FF9}" => "\x{1F79}", 
"\x{1FFA}" => "\x{1F7C}", 
"\x{1FFB}" => "\x{1F7D}", 
"\x{1FFC}" => "\x{1FF3}", 
"\x{2C80}" => "\x{2C81}", 
"\x{2C82}" => "\x{2C83}", 
"\x{2C84}" => "\x{2C85}", 
"\x{2C86}" => "\x{2C87}", 
"\x{2C88}" => "\x{2C89}", 
"\x{2C8A}" => "\x{2C8B}", 
"\x{2C8C}" => "\x{2C8D}", 
"\x{2C8E}" => "\x{2C8F}", 
"\x{2C90}" => "\x{2C91}", 
"\x{2C92}" => "\x{2C93}", 
"\x{2C94}" => "\x{2C95}", 
"\x{2C96}" => "\x{2C97}", 
"\x{2C98}" => "\x{2C99}", 
"\x{2C9A}" => "\x{2C9B}", 
"\x{2C9C}" => "\x{2C9D}", 
"\x{2C9E}" => "\x{2C9F}", 
"\x{2CA0}" => "\x{2CA1}", 
"\x{2CA2}" => "\x{2CA3}", 
"\x{2CA4}" => "\x{2CA5}", 
"\x{2CA6}" => "\x{2CA7}", 
"\x{2CA8}" => "\x{2CA9}", 
"\x{2CAA}" => "\x{2CAB}", 
"\x{2CAC}" => "\x{2CAD}", 
"\x{2CAE}" => "\x{2CAF}", 
"\x{2CB0}" => "\x{2CB1}", 
"\x{2CB2}" => "\x{2CB3}", 
"\x{2CB4}" => "\x{2CB5}", 
"\x{2CB6}" => "\x{2CB7}", 
"\x{2CB8}" => "\x{2CB9}", 
"\x{2CBA}" => "\x{2CBB}", 
"\x{2CBC}" => "\x{2CBD}", 
"\x{2CBE}" => "\x{2CBF}", 
"\x{2CC0}" => "\x{2CC1}", 
"\x{2CC2}" => "\x{2CC3}", 
"\x{2CC4}" => "\x{2CC5}", 
"\x{2CC6}" => "\x{2CC7}", 
"\x{2CC8}" => "\x{2CC9}", 
"\x{2CCA}" => "\x{2CCB}", 
"\x{2CCC}" => "\x{2CCD}", 
"\x{2CCE}" => "\x{2CCF}", 
"\x{2CD0}" => "\x{2CD1}", 
"\x{2CD2}" => "\x{2CD3}", 
"\x{2CD4}" => "\x{2CD5}", 
"\x{2CD6}" => "\x{2CD7}", 
"\x{2CD8}" => "\x{2CD9}", 
"\x{2CDA}" => "\x{2CDB}", 
"\x{2CDC}" => "\x{2CDD}", 
"\x{2CDE}" => "\x{2CDF}", 
"\x{2CE0}" => "\x{2CE1}", 
"\x{2CE2}" => "\x{2CE3}", 
"\x{2CEB}" => "\x{2CEC}", 
"\x{2CED}" => "\x{2CEE}", 
"\x{2CF2}" => "\x{2CF3}", 
);

1;
#+end_src

** new (UnicodeInput)
#+begin_src perl
sub new {
    my $self = {};
    bless $self;
    return $self;
}
#+end_src

** IsMyGreekCopt
#+begin_src perl
sub IsMyGreekCopt {
    return <<END;
0001\t007F
0300\t036F
0370\t03FF
1F00\t1FFF
2C80\t2CFF
END
}
#+end_src

** my %greek_punctuation
#+begin_src perl
my %greek_punctuation = (
    "\x{0387}" => ':',
    "\x{037E}" => ';',
    "\x{2014}" => '_',
    # All marks of elision need to be turned into apostrophes
    "\x{0027}" => '\'',
    "\x{2019}" => '\'',
    "\x{1FBD}" => '\''
    );
#+end_src

** unicode_pattern
#+begin_src perl
sub unicode_pattern {
    my $self = shift;
    my $pat = shift;

    if ($pat =~ m/^\p{InBasicLatin}+$/) {
        # All ascii
        if (ref $self eq 'Diogenes::Search') {
            return $self->latin_pattern($pat);
        }
        else {
            return $pat;
        }
    }

    if (ref $self eq 'Diogenes::Indexed') {
        $pat = $self->unicode_greek_to_beta($pat);
        # No diacrits, for searching the word-list
        $pat =~ s/[^A-Z]//;
        return $pat;
    }
    elsif (ref $self eq 'Diogenes::Search') {
        $pat =~ s#\(#\x073#g;                           # protect parens
        $pat =~ s#\)#\x074#g;
        $pat = $self->unicode_greek_to_beta($pat);

        if ($pat =~ m/[\\\/=|\*]/) {
            # Accent(s) present, so significant
            $pat = $self->make_strict_greek_pattern($pat);
        }
        else {
            $pat =~ s/\b([AEIOUHW]*)\)/\x071$1/g;               # mark where smooth breathing goes
            $pat =~ s/\b([AEIOUHW]*)\(/\x072$1/g;               # mark where rough breathing goes
            $pat = $self->make_loose_greek_pattern($pat);
        }
        return $pat;
    }
    else {
        # For Perseus, etc.
        $pat = $self->unicode_greek_to_beta($pat);
        $pat =~ tr /A-Z/a-z/;
        return $pat;
    }
    warn "Flow error!\n"
}
#+end_src

** unicode_greek_to_beta
Also works for Coptic
#+begin_src perl
sub unicode_greek_to_beta {
    my $self = shift;
    my $pat = shift;

    unless ($pat =~ m/^ʼ|\p{Diogenes::UnicodeInput::IsMyGreekCopt}*$/) {
        $pat =~ m/(\P{Diogenes::UnicodeInput::IsMyGreekCopt})/;
        warn "WARNING: Character(s) of input $pat not understood! ($1)";
        return;
    }

    my $out = '';
    # Koronis (for elision) is not included in \p{P} class
    while ($pat =~ m/(\s*)(\p{L})(\p{Mn}*)([\p{P}\x{1FBD}]*)(\s*)/g) {
        my $front_space = $1 || '';
        my $initial_char = $2;
        my $initial_diacrits = $3 || '';
        my $punct = $4 || '';
        my $end_space = $5 || '';
        # print STDERR "|$1|$2|$3|$4|$5|\n";
        my ($char, $diacrits) = $self->decompose($initial_char, $initial_diacrits);
        my $cap;
        if (exists $upper_to_lower{$char}) {
            $cap = '*';
            $char = $upper_to_lower{$char}
        }
        if (exists $greek_punctuation{$punct}) {
            $punct = $greek_punctuation{$punct};
        }

        if (exists $unicode_to_beta{$char}) {
            $char = $unicode_to_beta{$char};
        }
        else {
            warn "I don't know what to do with character $char in $pat\n";
            return 0;
        }
        my $temp = '';
        my @diacrits = split //, $diacrits;
        for my $d (@diacrits) {
            if (exists $unicode_to_beta{$d}) {
                $temp .= $unicode_to_beta{$d};
            }
            else {
                warn "I don't know what to do with diacritical mark $d";
                return;
            }
        }
        # Put the diacrits in the correct order
        my $beta_diacrits = '';
        for my $d (qw{ ) ( / \ = | + }) {
            my $r = quotemeta $d;
            $beta_diacrits .= $d if $temp =~ m/$r/;
        }
        if ($cap) {
            $out .= $front_space.$cap.$beta_diacrits.$char.$punct.$end_space;
        }
        else {
            $out .= $front_space.$char.$beta_diacrits.$punct.$end_space;
        }
    }
    return $out;
#+end_src
}

** decompose
#+begin_src perl
sub decompose {
    my ($self, $compound, $extra_diacrits) = @_;
    my $ret = $unicode_equivs{$compound};
    if (ref $ret) {
        return $self->decompose($ret->[0], ($ret->[1].$extra_diacrits));
    }
    elsif ($ret) {
        return $self->decompose($ret, $extra_diacrits);
    }
    else {
        return $compound, $extra_diacrits;
    }
}
#+end_src

** %Diogenes::UnicodeInput::unicode_to_beta
#+begin_src perl
%Diogenes::UnicodeInput::unicode_to_beta = (
    "\x{03B1}" => "A",
    "\x{03B2}" => "B",
    "\x{03B3}" => "G",
    "\x{03B4}" => "D",
    "\x{03B5}" => "E",
    "\x{03B6}" => "Z",
    "\x{03B7}" => "H",
    "\x{03B8}" => "Q",
    "\x{03B9}" => "I",
    "\x{03BA}" => "K",
    "\x{03BB}" => "L",
    "\x{03BC}" => "M",
    "\x{03BD}" => "N",
    "\x{03BE}" => "C",
    "\x{03BF}" => "O",
    "\x{03C0}" => "P",
    "\x{03C1}" => "R",
    "\x{03C2}" => "S",
    "\x{03C3}" => "S",
    "\x{03C4}" => "T",
    "\x{03C5}" => "U",
    "\x{03C6}" => "F",
    "\x{03C7}" => "X",
    "\x{03C8}" => "Y",
    "\x{03C9}" => "W",

    "\x{0300}" => "\\",
    "\x{0301}" => "/",
    "\x{0308}" => "+",
    "\x{0313}" => ")",
    "\x{0314}" => "(",
    "\x{0342}" => "=",
    "\x{0345}" => "|",
    "\x{0304}" => "&", # macron
    "\x{0306}" => "'", # vrachy
    "\x{02bc}" => "ʼ", # pass thru Unicode apostrophe

    "\x{03DC}" => "V", # digamma
    "\x{03DD}" => "V",

    # coptic (old block)
    "\x{03E3}" => "s",
    "\x{03E5}" => "f",
    "\x{03E9}" => "h",
    "\x{03EF}" => "t",
    "\x{03EB}" => "j",
    "\x{03ED}" => "g",

    # coptic (new unicode block)

    "\x{2C81}" => "A",
    "\x{2C83}" => "B",
    "\x{2C85}" => "G",
    "\x{2C87}" => "D",
    "\x{2C89}" => "E",
    "\x{2C8D}" => "Z",
    "\x{2CB7}" => "H",
    "\x{2C91}" => "Q",
    "\x{2C93}" => "I",
    "\x{2C95}" => "K",
    "\x{2C97}" => "L",
    "\x{2C99}" => "M",
    "\x{2C9B}" => "N",
    "\x{2C9D}" => "C",
    "\x{2C9F}" => "O",
    "\x{2CA1}" => "P",
    "\x{2CA3}" => "R",
    "\x{2CA5}" => "S",
    "\x{2CA7}" => "T",
    "\x{2CA9}" => "U",
    "\x{2CAB}" => "F",
    "\x{2CAD}" => "X",
    "\x{2CAF}" => "Y",
    "\x{2CB1}" => "W",

    # For the demotic letters, we use the old Greek and Coptic block

    );
#+end_src

** END
#+begin_src 
1;
#+end_src

* EntityTable
#+begin_src perl
# Generated by makefile using utils/ent_to_array.pl
package Diogenes::EntityTable;

%Diogenes::EntityTable::table = (
	'AEligmacr' => chr(0x01e2),
	'Arpress' => '[Arpress]',
	'C' => '[C     ]',
	'D' => '[D     ]',
	'Ebreve' => chr(0x114),
	'Eunc' => '[Eunc  ]',
	'Ibreve' => chr(0x12c),
	'Koppa' => chr(0x3de),
	'Mtilde' => '[Mtilde]',
	'Ndot' => '[Ndot]',
	'Obreve' => chr(0x14e),
	'Ptilde' => '[Ptilde]',
	'Rnull' => '[Rnull ]',
	'San' => '[San   ]',
	'Ybreve' => 'Y',
	'Ymacr' => chr(0x232),
	'acaron' => '[acaron]',
	'acedil' => '[acedil]',
	'acutebreve' => '[acutebreve]',
	'acutemacr' => '[acutemacr]',
	'adot' => '[adot  ]',
	'aeligmacr' => chr(0x01e3),
	'amacracute' => '[amacracute]',
	'anceps' => '[anceps]',
	'angle' => '[angle ]',
	'brevemacr' => '[brevemacr]',
	'brevenote' => '[brevenote]',
	'bstrok' => '[bstrok]',
	'c' => chr(0x2183),
	'cbreve' => '[cbreve]',
	'cgrave' => '[cgrave]',
	'chirho' => chr(0x2ce9),
	'cj' => '[C     ]',
	'cnull' => '[cnull ]',
	'combacute' => '[combacute]',
	'combbreve' => '[combbreve]',
	'combcirc' => '[combcirc]',
	'combgrave' => '[combgrave]',
	'combmacr' => '[combmacr]',
	'dibreve' => '[dibreve]',
	'drachm' => '[drachma]',
	'dram' => '[dram  ]',
	'ebreve' => chr(0x115),
	'ecedil' => '[ecedil]',
	'eglide' => '[eglide]',
	'emacracute' => '[emacracute]',
	'enull' => '[enull ]',
	'epig-rough' => '[epig-rough]',
	'etilde' => '[etilde]',
	'gkhyph' => '[gkhyph]',
	'gklig' => '[gklig]',
	'gtbreve' => '[gtbreve]',
	'gtlt' => '[gtlt  ]',
	'hbreve' => chr(0x1e2b),
	'hudot' => '[hudot ]',
	'ibreve' => chr(0x12d),
	'icaron' => '[icaron]',
	'iglide' => '[iglide]',
	'imacracute' => '[imacracute]',
	'imacrbreve' => '[imacrbreve]',
	'inter2' => chr(0x2236),
	'inter3' => chr(0x22ee),
	'jcaron' => '[jcaron]',
	'kacute' => '[kacute]',
	'kcirc' => '[kcirc ]',
	'kdot' => '[kdot  ]',
	'koopa' => '[koopa ]',
	'koppa' => chr(0x3df),
	'kudot' => '[kudot ]',
	'ldsqb' => chr(0x27e6),
	'lins' => '[lins  ]',
	'lnull' => chr(0x1e37),
	'longs' => chr(0x017f),
	'lpress' => '[lpress]',
	'ltilde' => '[ltilde]',
	'macracute' => '[macracute]',
	'macrbreve' => '[macrbreve]',
	'macrcirc' => '[macrcirc]',
	'macrdot' => '[macrdot]',
	'macutenull' => '[macutenull]',
	'minim' => chr(0x264f),
	'mmacrnull' => '[mmacrnull]',
	'mnull' => chr(0x1e43),
	'mtilde' => '[mtilde]',
	'ncirc' => '[ncirc ]',
	'ndot' => '[ndot  ]',
	'ngnull' => '[ngnull]',
	'ngrave' => '[ngrave]',
	'ngt' => '[ngt   ]',
	'nlt' => '[nlt   ]',
	'nmacrnull' => '[nmacrnull]',
	'nnull' => chr(0x1e47),
	'nring' => '[nring]',
	'null' => '[null  ]',
	'obreve' => chr(0x14f),
	'ocaron' => '[ocaron]',
	'ohbr' => chr(0x01eb),
	'oogon' => '[oogon ]',
	'oolig' => '[oolig ]',
	'ounce' => chr(0x2125),
	'pacute' => '[pacute]',
	'paid' => '[paid	]',
	'pounds' => chr(0x2114),
	'ptilde' => '[ptilde]',
	'qacute' => '[qacute]',
	'qgrave' => '[qgrave]',
	'qring' => '[qring ]',
	'qtilde' => '[qtilde]',
	'quad' => '[quad  ]',
	'quantity1' => chr(0x2114),
	'quantity2' => chr(0x2125),
	'quantity3' => chr(0x2108),
	'que' => '[que   ]',
	'queacute' => '[queacute]',
	'quetilde' => '[quetilde]',
	'quml' => '[quml  ]',
	'rcirc' => '[rcirc]',
	'rdot' => '[rdot  ]',
	'rdsqb' => chr(0x27e7),
	'rmacr' => '[rmacr ]',
	'rnull' => chr(0x1e5b),
	'root' => '[root  ]',
	'rough' => '[rough ]',
	'rpress' => '[rpress]',
	'rtilde' => '[rtilde]',
	'sampi' => '[sampi ]',
	'san' => '[san   ]',
	'sbreve' => '[sbreve]',
	'schwa' => '[schwa]',
	'scron' => '[scron]',
	'scruple' => chr(0x2108),
	'sdot' => '[sdot	]',
	'shortnote' => '[brevenote]',
	'smooth' => '[smooth]',
	'snull' => '[snull ]',
	'staur' => chr(0x2ce7),
	'stigma' => '[stigma]',
	'tnull' => '[tnull ]',
	'tnum' => '[tnum  ]',
	'triangle' => '[triangle]',
	'ttilde' => '[ttilde]',
	'ucaron' => '[ucaron]',
	'udot' => '[udot  ]',
	'uglide' => '[uglide]',
	'umacracute' => '[umacracute]',
	'wacute' => '[wacute]',
	'x1000' => '[x1000 ]',
	'ybreve' => 'y',
	'ygrave' => '[ygrave]',
	'ymacr' => chr(0x233),
	'yogh' => '[yogh  ]',
	'ytilde' => '[ytilde]',
	'zcirc' => '[zcirc ]',
	'zgrave' => '[zgrave]',
);
#+end_src

* Script (Auszüge)

* Perseus (Auszüge)

** $greek_parse_setup
#+begin_src perl
my $greek_parse_setup = sub {
    $idt_file = File::Spec->catfile($perseus_dir, 'greek-analyses.idt');
    $txt_file = File::Spec->catfile($perseus_dir, 'greek-analyses.txt');
    $comp_fn = $ascii_comp_fn;
    $key_fn = $tab_key_fn;
};
#+end_src

** $latin_parse_setup

#+begin_src perl
my $latin_parse_setup = sub {
    $idt_file = File::Spec->catfile($perseus_dir, 'latin-analyses.idt');
    $txt_file = File::Spec->catfile($perseus_dir, 'latin-analyses.txt');
    $comp_fn = $ascii_comp_fn;
    $key_fn = $tab_key_fn;
};
#+end_src

** $parse_prelims
#+begin_src perl
my $parse_prelims = sub {
    open $idt_fh, "<$idt_file" or die $!;
    local $/ = undef;
    my $code = <$idt_fh>;
    eval $code;
    warn "Error eval'ing $idt_file: $@" if $@;
    open $search_fh, "<$txt_file" or die $!;
};
#+end_src

** $binary_search
#+begin_src perl
# Recursive, line-wise binary search

# NB. This search is sloppy, since we don't know record boundaries.
# Results in lots of extra comparisons in failure case, but fast when
# successful.  The initial lower bound ($start) must be two less than
# the true bound, or the first record will never be found (not an
# issue when it's 0, i.e starting from the beginning of the file, as
# this is dealt with as a special case).

# $dict_offset tells us where the successful match began (for passing
# to next and prev entry), or in the case of an unsuccessful search,
# where the nearest-miss entry begins.

# We use global var to avoid leaking memory with recursive anon subs.
use vars '$binary_search';
our $binary_search = sub {
    # "local" fails and becomes slurping on versions of Windows
    # local $/ = "\n";
    $/ = "\n";
    my $word = shift;
    my $start = shift;
    my $stop = shift;
    my $mid = int(($start + $stop) / 2);
    return undef if $start == $mid or $stop == $mid;
    # This may land in the middle of a utf8 char, but that should not matter.
    seek $search_fh, $mid, 0;
    <$search_fh> unless $mid == 0;
    $dict_offset = tell $search_fh;
    my $line = <$search_fh>;
    chomp $line;
    (my $key, my $value) = $key_fn->($line);
    my $cmp = $comp_fn->($word, $key);
    # print STDERR "debug: $start -> $mid -> $stop  cmp: $cmp; $word vs $key\n";
    return $binary_search->($word, $start, $mid) if ($cmp == -1);
    return $binary_search->($word, $mid, $stop) if ($cmp == 1);
    return $value;
};
#+end_src

** $try_parse
#+begin_src perl
my $try_parse = sub {
    my $word = shift;
    my $key = substr($word, 0, 3);
    my $start = defined $index_start{$key} ? $index_start{$key} - 2 : 0;
    my $stop = $index_end{$key} || $index_max;
    return $binary_search->($word, $start, $stop);
};
#+end_src

** $normalize_latin_lemma
#+begin_src perl
my $normalize_latin_lemma = sub {
    my $lemma = shift;

    # Remove accents from utf8 text
    $lemma = NFKD( $lemma );
    $lemma =~ s/\p{NonspacingMark}//g;
    # Remove macrons and breves from ascii text
    $lemma =~ s/[_^]//g;

    if ($lemma =~ m/-/) {
        $lemma =~ s/(.*)-(.*)/$1$2/;
    }
    $lemma =~ s/\d$//;
    return $lemma;
};
#+end_src

** $normalize_greek_lemma
#+begin_src perl
my $normalize_greek_lemma = sub {
    my $lemma = shift;
    $lemma = lc $lemma;
    # We strip breathings, too, because that surprises less
    $lemma =~ s/[_^,-\\\/=+\d)(]//g;
    return $lemma;
};
#+end_src

** $do_lookup
#+begin_src perl
my $do_lookup = sub {
    my $word = shift;
    my $exact = shift;
    if ($lang eq 'grk' ) {
        $lsj_search_setup->();
    }
    elsif ($lang eq 'lat' ) {
        $lewis_search_setup->();
    }
    elsif ($lang eq 'eng' ) {
        $gcide_search_setup->();
    }
    else {
        warn "Bad Perseus request (e)";
    }
    my $pretty_word = ($lang eq "grk") ? $beta_to_utf8->($word) : $word;

    $word =~ tr/A-Z/a-z/;
    $word =~ s/[^a-z]//g;
    my $output = $binary_search->($word, 0, $size);
    if ($output) {
        $format_dict->($output);
        return 1;
    }
    elsif (not $exact) {
        print "<p>Could not find dictionary headword for $pretty_word.  Showing nearest entry.</p>";
        seek $search_fh, $dict_offset, 0;
        my $entry = <$search_fh>;
        $format_dict->($entry);
    }
    else {
        return undef;
    }
};
#+end_src

** $format_analysis
#+begin_src perl
my $format_analysis = sub {
    my $anl = shift;
    $query = $beta_to_utf8->($query) if $lang eq 'grk';
    my (@out, @suppl);
#     print "\n\n$anl\n\n";
    while ($anl =~ m/{([^\}]+)}((?:\[\d+\])*)/g) {
#     while ($anl =~ m/{([^\}]+)}/g) {
        my $entry = $1;
        my $suppl = $2;
        if ($entry =~ m/^(\d+) (\d) (.*?)\t(.*?)\t(.*?)$/) {
            my ($dict, $conf, $lemma, $trans, $info) = ($1, $2, $3, $4, $5);
            $lemma = $beta_to_utf8->($lemma) if $lang eq 'grk';
            $lemma = $munge_ls_lemma->($lemma) if $lang eq 'lat';
            # The greek-analyses.txt file is subtly utf8, as the short defs include some Unicode punctuation.
            $trans = Encode::decode('utf-8', $trans);
            $lemma .= " ($trans)" if $trans =~ m/\S/;
            $lemma .= ": $info";
            push @out, [$dict, $conf, $lemma];
        }
        else {
            warn "Bad analysis: $entry";
        }
        if ($suppl) {
            while ($suppl =~ m/\[(\d+)\]/g) {
                push @suppl, $1;
            }
        }
    }
    my (@dicts, %conf);
    if (scalar @out == 1) {
        my ($dict, $conf, $lemma) = @{ $out[0] };
        print $f->h1("Perseus analysis of $query:");
        print $f->p($lemma);
        @dicts = ($dict);
        $conf{$dict} = $conf;
    }
    else {
        print $f->h1("Perseus analyses of $query:");
        print "<ol>\n";
        for (@out) {
            my ($dict, $conf, $lemma) = @{ $_ };
            print $f->li($lemma);
            push @dicts, $dict unless exists $conf{$dict};
            $conf{$dict} += $conf;
        }
        print "</ol>";
    }
    if (@suppl) {
        for (@suppl) {
            unless (exists $conf{$_}) {
                $conf{$_} = -1;
                push @dicts, $_;
            }
        }
    }
    print "\n";
    if (scalar @dicts == 1) {
        print $f->h1("$dict_name entry");
    } else {
        print $f->h1("$dict_name entries");
    }
    for my $dict (@dicts) {
        if ($conf{$dict} == -1) {
            print $f->p("Supplementary prefix entry:");
        } elsif ($conf{$dict} == 0) {
            print $f->p("(NB. Could not find dictionary headword; this is around
the spot it should appear.)");
        } elsif ($conf{$dict} <= 2) {
            print $f->p("(NB. This dictionary headword is a guess.)");
        }
        open my $dict_fh, "<$dict_file" or die $!;
        seek $dict_fh, $dict, 0;
        $dict_offset = $dict;
        my $entry = <$dict_fh>;
#        print STDERR "\n\n== $entry\n\n";
        $format_dict->($entry);
    }
};
#+end_src

** $format_inflect
#+begin_src perl
my $format_inflect = sub {
    $lem_num++;
    my ($lem, $out) = @_;
    my @out = split /\t/, $out;
    my $dict = shift @out;
    my $link = qq{<a onClick="getEntry$lang('$dict');">}.
        ($lang eq "grk" ? $beta_to_utf8->($lem) : $lem).
        qq{</a>};
    print qq{<h2><a onClick="toggleLemma('$lem_num');"><img src="${picture_dir}opened.png" srcset="${picture_dir}opened.hidpi.png 2x"
align="bottom" id="lemma_$lem_num" /></a>&nbsp;$link</h2>};

    print qq{<span class="lemma_span_visible" id="lemma_span_$lem_num">};
    for (@out) {
        m/^(\S+)(.*)$/;
        my ($form, $infl) = ($1, $2);
        my $label = ($lang eq "grk" ? $beta_to_utf8->($form) : $form) . ": $infl";
        print qq{<span class="form_span_visible" infl="$infl"><input type="checkbox" name="lemma_list" value="$form">$label</input><br/></span>};
    }
    print '</span>';
};

my $failed_inflect = sub {
    print "Could not find lemma for $qquery\n";
};
#+end_src

** $do_inflect
#+begin_src perl
my $do_inflect = sub {
    my $lemma = shift;
    my $filename = ($lang eq 'grk' ? 'greek' : 'latin') . '-lemmata.txt';
    $txt_file = File::Spec->catfile($perseus_dir, $filename);
    $size = -s $txt_file;
    $comp_fn = $ascii_comp_fn;
    $key_fn = $tab_key_fn;
    open $search_fh, "<$txt_file" or die $!;
    my $output = $binary_search->($lemma, 0, $size);
    if ($output) {
        $format_inflect->($lemma, $output);
    }
    else {
        $failed_inflect->();
    }
};
#+end_src

** $do_inflects
#+begin_src perl
my $do_inflects = sub {
    my @lemmata = split /{}/, $query;
    for (@lemmata) {
        next if m/^\s*$/;
        $do_inflect->($_);
    }
};
#+end_src

** $find_lemma
#+begin_src perl
my $find_lemma = sub {
    my $filename = ($lang eq 'grk' ? 'greek' : 'latin') . '-lemmata.txt';
    my $norm_func = ($lang eq 'grk') ? $normalize_greek_lemma : $normalize_latin_lemma;
    $txt_file = File::Spec->catfile($perseus_dir, $filename);
    my $target = $norm_func->($query);
    $target =~ s/[,\s]+/ /g;
    $target = quotemeta $target;
    $target =~ s/\\ /\\b/g;
    open my $fh, "<$txt_file" or die $!;
    my (@results, %dicts);
    $/ = "\n";
    # Linear search, since we are looking for any partial match
    while (<$fh>) {
        m/^(.*?)\t(.*?)\t/;
        my $key = $1;
        my $dict = $2;
        my $norm_key = $norm_func->($1);
        if ($norm_key =~ /$target/) {
            push @results, $key;
            $dicts{$key} = $dict;
        }
    }
    my $qq = $f->param('q');
    if (@results) {
        my %labels;
        $labels{$_} = qq{<a onClick="getEntry$lang('$dicts{$_}');">}.
            ($lang eq "grk" ? $beta_to_utf8->($_) : $_).
            qq{</a>} for @results;
        print $f->h2("Lemma matches for $qq:");
        $f->autoEscape(0);
        print $f->checkbox_group(-name=> "lemma_list",
                                 -values=>\@results,
                                 -labels=>\%labels,
                                 -linebreak=>1);
        $f->autoEscape(1);
    } else {
        print "Sorry, no lemma matches were found for $qq (language = $lang)\n";
    }

};
#+end_src

** $get_entry
#+begin_src perl
my $get_entry = sub {
    my $direction = shift;
    die "Bad seek parameter for query" unless $query =~ m/^\d+$/;
    open my $fh, "<$dict_file" or die $!;
    seek $fh, $query, 0 or die $!;
    my $entry;
    if ($direction eq 'next') {
        $entry = <$fh>;
    } elsif ($direction eq 'prev') {
        my $char = '';
        while ($char ne "\n") {
#             print STDERR "$char";
            seek $fh, -2, 1;
            read $fh, $char, 1;
        }
    }
    $dict_offset = tell $fh;
    $entry = <$fh>;
#     print STDERR "\n\n$entry\n\n";
    $format_dict->($entry);
    close $fh or die $!;
};
#+end_src

** $do_parse
#+begin_src perl
my $do_parse = sub {
    if ($lang eq 'grk' ) {
        $greek_parse_setup->();
    }
    elsif ($lang eq 'lat' ) {
        $latin_parse_setup->();
    }
    else {
        warn "Bad Perseus request (e)";
    }
    $parse_prelims->();

    # Normalize barytone
    $query =~ s#\\#/#g;
    # Remove ~hit~ and punctuation
    $query =~ s/~hit~//;
    # remove leading & trailing spaces
    $query =~ s/^\s+//g;
    $query =~ s/\s+$//g;
    # Do not remove apostrophes from Greek! (Morpheus knows about elided forms) ...
    $query =~ s/[~,.;:?!"]//g;
    # ... but do change Unicode koronis or curly quote into an
    # apostrophe when it shows elision, or Morpheus won't understand.
    $query =~ s/[᾽’]$/'/g;
    # In Latin, however, apostrophes are just single quotation marks and need to be removed.
    $query =~ s/[']//g if $lang eq 'lat';
    my $word = $query;
    # remove diareses
    $word =~ s/\+//g;
    # print STDERR "\n\n-$word-$query-\n";
    # Accent thrown back from enclitic?
    $word =~ s/^(.*[\\\/=].*)[\\\/=]/$1/;
    my $analysis = $try_parse->($word);
    if (not defined $analysis) {
        # Try lower-case if upper
        if ($lang eq 'lat' and $word =~ m/^[A-Z]/) {
            $word =~ tr/A-Z/a-z/;
            $analysis = $try_parse->($word);
        }
        elsif ($lang eq 'grk' and $word =~ m/^\*/) {
            $word =~ s/\*//g;
            $word =~ s/^([\\\/=|)(]+)([aeiouhw])/$2$1/;
            $analysis = $try_parse->($word);
            if (not defined $analysis) {
                if ($word =~ s/^([aeiouhw])([\\\/=|)(]+)([aeiouhw])/$1$3$2/) {
                    # print STDERR "Try-$word-$query-\n";
                    $analysis = $try_parse->($word);
                }
            }
        }
    }

    if (defined $analysis) {
        $format_analysis->($analysis);
    }
    else {
        print "<p>Could not parse $qquery.  Looking in dictionary.</p>";
        # do search in dict
        $do_lookup->($query);
    }
};
#+end_src
